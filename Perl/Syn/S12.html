<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
           "http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>S12</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" >
<link rel="stylesheet" type="text/css" title="pod_stylesheet" href="http://dev.perl.org/css/perl.css">

<script type="text/javascript">
var agt = navigator.userAgent.toLowerCase();

var is_opera = (agt.indexOf("opera") != -1);
var is_ie = (agt.indexOf("msie") != -1) && document.all && !is_opera;
var is_ie5 = (agt.indexOf("msie 5") != -1) && document.all;

function tog() {
  // tog: toggle the visibility of html elements (arguments[1..]) from none to
  // arguments[0].  Return what should be returned in a javascript onevent().
  display = arguments[0];
  for( var i=1; i<arguments.length; i++ ) {
    var x = document.getElementById(arguments[i]);
    if (!x) continue;
    if (x.style.display == "none" || x.style.display == "") {
      x.style.display = display;
    } else {
      x.style.display = "none";
    }
  }

  var e = is_ie ? window.event : this;
  if (e) {
    if (is_ie) {
      e.cancelBubble = true;
      e.returnValue = false;
      return false;
    } else {
      return false;
    }
  }
}

function tog_quote( idnum ) {
  return tog( 'block', 'header_shown_' + idnum, 'header_hidden_' + idnum,
       'hide_' + idnum );
}

</script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.03,
  using Pod::Simple::PullParser v2.02,
  under Perl v5.008007 at Mon Oct  9 11:02:51 2006 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
            <I>This page was generated at 2006-10-09 11:02:51 GMT.
            (syn <strong>r12875</strong>, pugs <strong>r14123</strong>)</I>
        
<a name='___top' class='dummyTopAnchor' ></a>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#TITLE'>TITLE</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#Overview'>Overview</a>
  <li class='indexItem indexItem1'><a href='#Classes'>Classes</a>
  <li class='indexItem indexItem1'><a href='#Methods'>Methods</a>
  <li class='indexItem indexItem1'><a href='#Class_methods'>Class methods</a>
  <li class='indexItem indexItem1'><a href='#Submethods'>Submethods</a>
  <li class='indexItem indexItem1'><a href='#Attributes'>Attributes</a>
  <li class='indexItem indexItem1'><a href='#Construction_and_Initialization'>Construction and Initialization</a>
  <li class='indexItem indexItem1'><a href='#Mutating_methods'>Mutating methods</a>
  <li class='indexItem indexItem1'><a href='#Calling_sets_of_methods'>Calling sets of methods</a>
  <li class='indexItem indexItem1'><a href='#Parallel_dispatch'>Parallel dispatch</a>
  <li class='indexItem indexItem1'><a href='#Multisubs_and_Multimethods'>Multisubs and Multimethods</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Method_call_vs._Subroutine_call'>Method call vs. Subroutine call</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#Multi_dispatch'>Multi dispatch</a>
  <li class='indexItem indexItem1'><a href='#Roles'>Roles</a>
  <li class='indexItem indexItem1'><a href='#Traits'>Traits</a>
  <li class='indexItem indexItem1'><a href='#Delegation'>Delegation</a>
  <li class='indexItem indexItem1'><a href='#Types_and_Subtypes'>Types and Subtypes</a>
  <li class='indexItem indexItem1'><a href='#Enums'>Enums</a>
  <li class='indexItem indexItem1'><a href='#Open_vs_Closed_Classes'>Open vs Closed Classes</a>
  <li class='indexItem indexItem1'><a href='#Interface_Consistency'>Interface Consistency</a>
  <li class='indexItem indexItem1'><a href='#Introspection'>Introspection</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TITLE"
>TITLE</a></h1>

<p>Synopsis 12: Objects</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Larry Wall &#60;larry@wall.org&#62;</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<pre>  Maintainer: Larry Wall &#60;larry@wall.org&#62;
  Date: 27 Oct 2004
  Last Modified: 4 Oct 2006
  Number: 12
  Version: 28</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Overview"
>Overview</a></h1>

<p>This synopsis summarizes Apocalypse 12, which discusses object-oriented programming.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Classes"
>Classes</a></h1>

<a href="#" onclick="return tog_quote(50);">
<div ID="header_shown_50" style="display: none;">
- Hide the snippet from t/oo/class/basic.t (line 13 ~ line 38) -
</div>
<div ID="header_hidden_50" style="display: block;">
- Show the snippet from t/oo/class/basic.t (line 13 ~ line 38) -
</div>
</a>
<div ID="hide_50" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S12/&quot;Classes&quot;&gt;
class Foo {}

my $foo = Foo.new();
ok($foo ~~ Foo, '... smartmatch our $foo to the Foo class');

# note that S12 says that .isa() should be called on metaclasses.
# However, making it an object .isa() means that classes are free to
# override the behaviour without playing with the metamodel via traits
ok($foo.isa(Foo), '.isa(Foo)');
ok($foo.isa(::Foo), '.isa(::Foo)');
ok($foo.isa(&quot;Foo&quot;), '.isa(&quot;Foo&quot;)');
ok(!$foo.isa(&quot;Bar&quot;), '!.isa(&quot;Bar&quot;)');

my $foo_clone = $foo.clone();
ok($foo_clone ~~ Foo, '... smartmatch our $foo_clone to the Foo class');

class Foo::Bar {}

my $foo_bar = Foo::Bar.new();
ok($foo_bar ~~ Foo::Bar, '... smartmatch our $foo_bar to the Foo::Bar class');

ok($foo_bar.isa(Foo::Bar), '.isa(Foo::Bar)');
ok(!$foo_bar.isa(::Foo), '!Foo::Bar.new.isa(::Foo)');</pre>
</div>


<p>A class is a module declared with the <code>class</code> keyword. As with modules, the public storage, interface, and name of the class is represented by a package and its name, which is usually (but not necessarily) a global name.</p>

<p>Taken as an object, a class represents all of the possible values of its type, and the class object can thus be used as a proxy for any &#34;real&#34; object of that type in calculating what a generic object of that type can do. The class object is an Object, but it is not a Class, because there is no mandatory Class class in Perl 6. We wish to support both class-based and prototype-based OO programming. So all metaprogramming is done through the current object&#39;s <code>HOW</code> object, which can delegate metaprogramming to any metamodel it likes. However, by default, objects derived from Object support a fairly standard class-based model.</p>

<p>There are two basic class declaration syntaxes:</p>

<pre>    class Foo;          # rest of file is class definition
    ...

    class Bar {...}     # block is class definition</pre>

<p>The first form is allowed only as the first declaration in a compilation unit (that is, file or eval string).</p>

<p>In either case, the code represented by <code>...</code> executes at compile time as the body of a method of the metaclass, which is responsible for interpreting the keywords of the class definition. (And since a class is also a module, it also handles any module-oriented keywords. You can export subs from a class at &#34;use&#34; time, for instance.)</p>

<p>A named class declaration can occur as part of an expression, just like named subroutine declarations.</p>

<p>Classes are primarily for instance management, not code reuse. Consider using <code>roles</code> when you simply want to factor out common code.</p>

<p>Perl 6 supports multiple inheritance, anonymous classes, and autoboxing.</p>

<p>All public method calls are &#34;virtual&#34; in the C++ sense. More surprisingly, any class name mentioned in a method is also considered virtual, that is, polymorphic on the actual type of the object.</p>

<p>You may derive from any built-in type, but the derivation of a low-level type like <code>int</code> may only add behaviors, not change the representation. Use composition and/or delegation to change the representation.</p>

<p>Since there are no barewords in Perl 6, bare class names must be predeclared. You can predeclare a stub class and fill it in later just as you would a subroutine. Alternately, you can define a local class or type variable using the <code>::</code> type sigil. In an rvalue context the <code>::</code> prefix is a no-op, but in a declarational context, it binds a new type name within its declared scope.</p>

<p>Without a <code>my</code> or other scoping declarator, a bare <code>class</code> declarator declares an <code>our</code> declarator, that is, a name within the current package. Since class files begin parsing in the <code>*</code> (<code>GLOBAL</code>) package, the first class declaration in the file installs itself as a global name, and subsequent declarations then install themselves into the current class rather than the global package.</p>

<p>Hence, to declare an inner class in the current package (or module, or class), use <code>our class</code> or just <code>class</code>. To declare a lexically scoped class, use <code>my class</code>. Class names are always searched for from innermost scopes to outermost. As with an initial <code>::</code>, the presence of a <code>::</code> within the name does not imply globalness (unlike in Perl 5). So the outward search can look in children of the searched namespaces.</p>

<p>Class traits are set using <code>is</code>:</p>

<pre>    class MyStruct is rw {...}</pre>

<p>An &#34;isa&#34; is just a trait that happens to be another class:</p>

<a href="#" onclick="return tog_quote(49);">
<div ID="header_shown_49" style="display: none;">
- Hide the snippet from t/oo/class/basic.t (line 39 ~ line 63) -
</div>
<div ID="header_hidden_49" style="display: block;">
- Show the snippet from t/oo/class/basic.t (line 39 ~ line 63) -
</div>
</a>
<div ID="hide_49" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S12/&quot;Classes&quot; /An \&quot;isa\&quot; is just a trait that happens to be another class\:/&gt;
class Bar is Foo {}

ok(Bar ~~ Foo, '... smartmatch our Bar to the Foo class');

my $bar = Bar.new();
ok($bar ~~ Bar, '... smartmatch our $bar to the Bar class');
ok($bar.isa(Bar), &quot;... .isa(Bar)&quot;);
ok($bar ~~ Foo, '... smartmatch our $bar to the Foo class');
ok($bar.isa(Foo), &quot;new Bar .isa(Foo)&quot;);

my $bar_clone = $bar.clone();
ok($bar_clone ~~ Bar, '... smartmatch our $bar_clone to the Bar class');
ok($bar_clone.isa(Bar), &quot;... .isa(Bar)&quot;);
ok($bar_clone ~~ Foo, '... smartmatch our $bar_clone to the Foo class');
ok($bar_clone.isa(Foo), &quot;... .isa(Foo)&quot;);


# Same, but with the &quot;is Foo&quot; declaration inlined
class Baz { is Foo }

ok(Baz ~~ Foo, '... smartmatch our Baz to the Foo class');
my $baz = Baz.new();
ok($baz ~~ Baz, '... smartmatch our $baz to the Baz class');
ok($baz.isa(Baz), &quot;... .isa(Baz)&quot;);</pre>
</div>


<pre>    class Dog is Mammal {...}</pre>

<p>MI is specified with multiple <code>is</code> modifiers:</p>

<pre>    class Dog is Mammal is Pet {...}</pre>

<p>Roles use <code>does</code> instead of <code>is</code>:</p>

<pre>    class Dog is Mammal does Pet {...}</pre>

<p>You may put these inside as well:</p>

<pre>    class Dog {
        is Mammal;
        does Pet;
        ...
    }</pre>

<p>Every object (including any class object) delegates to an instance of its metaclass. You can get at the metaclass of any object via the <code>HOW</code> method. A &#34;class&#34; object is just considered an &#34;empty&#34; instance in Perl 6, more properly called a &#34;prototype&#34; object. The actual class object is the metaclass object pointed to by the <code>HOW</code> syntax. So when you say &#34;Dog&#34;, you&#39;re referring to both a package and a prototype object, that latter of which points to the actual object representing the class via <code>HOW</code>. The prototype object differs from an instance object not by having a different type but rather in the extent to which it is defined. Some objects may tell you that they are defined, while others may tell you that they are undefined. That&#39;s up to the object, and depends on how the metaclass chooses to dispatch the .defined method.</p>

<p>The notation <code>^Dog</code> is syntactic sugar for <code>Dog.HOW</code>, so <code>^</code> can be considered the &#34;class&#34; sigil when you want to talk about the current metaclass instance.</p>

<p>Classes are open and non-final by default, but may easily be closed or finalized not by themselves but by the entire application, provided nobody issued an explicit compile-time request that the class stay open or non-final. (Or a site policy could close any applications that use the policy.) Platforms that do dynamic loading of sub-applications probably don&#39;t want to close or finalize classes wholesale, however.</p>

<p>Roles take on some of the compile-time function of closed classes, so you should probably use those instead anyway.</p>

<p>A private class can be declared using <code>my</code>; most privacy issues are handled with lexical scoping in Perl 6. The fact that importation is lexical by default also means that any names your class imports are also private by default.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Methods"
>Methods</a></h1>

<p>Methods are routines declared in a class with the <code>method</code> keyword:</p>

<pre>    method doit ($a, $b, $c) { ... }
    method doit ($self: $a, $b, $c) { ... }
    method doit (MyName $self: $a, $b, $c) { ... }
    method doit (::?CLASS $self: $a, $b, $c) { ... }</pre>

<p>Declaration of the invocant is optional. You may always access the current invocant using the keyword <code>self</code>. You need not declare the invocant&#39;s type, since the lexical class of the invocant is known in any event because methods must be declared in the class of the invocant, though of course the actual (virtual) type may be a derived type of the lexical type. You could declare a more restrictive type, but that would probably be a bad thing for proper polymorphism. You may explicitly type the invocant with the lexical type, but any check for that will be optimized away. (The current lexically-determined class may always be named as <code>::?CLASS</code> even in anonymous classes or roles.)</p>

<a href="#" onclick="return tog_quote(8);">
<div ID="header_shown_8" style="display: none;">
- Hide the snippet from t/oo/attributes/recursive.t (line 55 ~ line 92) -
</div>
<div ID="header_hidden_8" style="display: block;">
- Show the snippet from t/oo/attributes/recursive.t (line 55 ~ line 92) -
</div>
</a>
<div ID="hide_8" style="display:none; border:1px solid">
<pre style="margin-left: 6px">#L&lt;S12/Methods/current lexically-determined class ::?CLASS&gt;
{
&nbsp; &nbsp; class C {
&nbsp; &nbsp; &nbsp; &nbsp; has ::?CLASS $.attr is rw;
&nbsp; &nbsp; };
&nbsp; &nbsp; ok !($!), 'Can create class with attribute of type ::?CLASS';
&nbsp; &nbsp; 
&nbsp; &nbsp; my C $a;
&nbsp; &nbsp; my C $b;
&nbsp; &nbsp; try {
&nbsp; &nbsp; &nbsp; &nbsp; $a .= new();
&nbsp; &nbsp; &nbsp; &nbsp; $b .= new(:attr($a));
&nbsp; &nbsp; };
&nbsp; &nbsp; ok !($!), 'Can instantiate class with ::?CLASS attribute';
&nbsp; &nbsp; is $b.attr, $a, '::?CLASS attribute stores correctly';
&nbsp; &nbsp; try {
&nbsp; &nbsp; &nbsp; &nbsp; $a.attr = $b;
&nbsp; &nbsp; };
&nbsp; &nbsp; ok !($!), '::?CLASS cycles are fine';
&nbsp; &nbsp; is $b.attr.attr, $b, '::?CLASS cycles resolve correctly';
&nbsp; &nbsp; try {
&nbsp; &nbsp; &nbsp; &nbsp; $a.attr .= new();
&nbsp; &nbsp; };
&nbsp; &nbsp; ok !($!), 'Can instantiate attribute of type ::?CLASS';
&nbsp; &nbsp; isa_ok $a.attr, C, '::?CLASS instantiates to correct class';


&nbsp; &nbsp; class D is C { };
&nbsp; &nbsp; ok !($!), 'Can create a subclass of class with ::?CLASS attribute';
&nbsp; &nbsp; my D $d;
&nbsp; &nbsp; try {
&nbsp; &nbsp; &nbsp; &nbsp; $d .= new();
&nbsp; &nbsp; &nbsp; &nbsp; $d.attr .= new();
&nbsp; &nbsp; };
&nbsp; &nbsp; ok !($!), 'Can instantiate derived class with ::?CLASS attribute';
&nbsp; &nbsp; isa_ok $d.attr, C, '::?CLASS is lexical, not virtual', :todo&lt;bug&gt;;
}</pre>
</div>


<p>To mark an explicit invocant, just put a colon after it:</p>

<pre>    method doit ($x: $a, $b, $c) { ... }</pre>

<p>This is true also for multi methods:</p>

<pre>    multi method doit ($x: $a; $b; $c) { ... }</pre>

<p>Private methods are declared using <code>my</code>:</p>

<pre>    my method think (Brain $self: $thought)</pre>

<p>(Such methods are completely invisible to ordinary method calls, and are in fact called with a different syntax that uses <code>!</code> in place of the <code>.</code> character. See below.)</p>

<p>To call an ordinary method with ordinary method-dispatch semantics, use either the dot notation or indirect object notation:</p>

<a href="#" onclick="return tog_quote(7);">
<div ID="header_shown_7" style="display: none;">
- Hide the snippet from t/oo/methods/instance.t (line 13 ~ line 91) -
</div>
<div ID="header_hidden_7" style="display: block;">
- Show the snippet from t/oo/methods/instance.t (line 13 ~ line 91) -
</div>
</a>
<div ID="hide_7" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S12/&quot;Methods&quot; /&quot;either the dot notation or indirect object notation:&quot;&gt;
class Foo {
&nbsp; method doit ($a, $b, $c) { $a + $b + $c }
&nbsp; method noargs () { 42 }
&nbsp; method nobrackets { 'mice' }
&nbsp; method callsmethod1() { .noargs(); }
&nbsp; method callsmethod2 { .noargs(); }
}

my $foo = Foo.new();
is($foo.doit(1,2,3), 6, &quot;dot method invocation&quot;);

my $val;
lives_ok {
&nbsp; &nbsp; $val = doit $foo: 1,2,3;
}, '... indirect method invocation works';
is($val, 6, '... got the right value for indirect method invocation');

is($foo.noargs, 42, &quot;... no parentheses after method&quot;);
is($foo.noargs(), 42, &quot;... parentheses after method&quot;);

{
&nbsp; &nbsp; my $val;
&nbsp; &nbsp; lives_ok {
&nbsp; &nbsp; &nbsp; &nbsp; eval '$val = $foo.noargs()';
&nbsp; &nbsp; &nbsp; &nbsp; die $! if $!;
&nbsp; &nbsp; }, &quot;... &lt;space&gt; + parentheses after method&quot;;
&nbsp; &nbsp; is($val, 42, '... we got the value correctly');
}

{
&nbsp; &nbsp; my $val;
&nbsp; &nbsp; lives_ok {
&nbsp; &nbsp; &nbsp; &nbsp; #eval '$val = $foo.noargs.()';
&nbsp; &nbsp; &nbsp; &nbsp; #die $! if $!;
&nbsp; &nbsp; &nbsp; &nbsp; die 'cannot parse &quot;val = $foo.noargs.()&quot;'
&nbsp; &nbsp; }, &quot;... '.' + parentheses after method&quot;, :todo&lt;bug&gt;;
&nbsp; &nbsp; is($val, 42, '... we got the value correctly', :todo&lt;feature&gt;);
}

{
&nbsp; &nbsp; my $val;
&nbsp; &nbsp; lives_ok {
&nbsp; &nbsp; &nbsp; &nbsp; #eval '$val = $foo.noargs .()';
&nbsp; &nbsp; &nbsp; &nbsp; #die $! if $!;
&nbsp; &nbsp; &nbsp; &nbsp; die 'cannot parse &quot;$foo.noargs .()&quot;'
&nbsp; &nbsp; }, &quot;... &lt;space&gt; + '.' + parentheses after method&quot;, :todo&lt;bug&gt;;
&nbsp; &nbsp; is($val, 42, '... we got the value correctly', :todo&lt;feature&gt;);
}

{
&nbsp; &nbsp; my $val;
&nbsp; &nbsp; lives_ok { $val = $foo.nobrackets() }, 'method declared with no brackets';
&nbsp; &nbsp; is($val, 'mice', '... we got the value correctly');
}

{
&nbsp; &nbsp; my $val;
&nbsp; &nbsp; lives_ok { $val = $foo.callsmethod1() }, 'method calling method';
&nbsp; &nbsp; is($val, 42, '... we got the value correctly');
};

{
&nbsp; &nbsp; my $val;
&nbsp; &nbsp; lives_ok { $val = $foo.callsmethod2() }, 'method calling method with no brackets';
&nbsp; &nbsp; is($val, 42, '... we got the value correctly');
};

{
&nbsp; &nbsp; # This test could use peer review to make sure it complies with the spec.
&nbsp; &nbsp; class Zoo {
&nbsp; &nbsp; &nbsp; &nbsp; method a () { my %s; %s.b }
&nbsp; &nbsp; &nbsp; &nbsp; method c () { my %s; b(%s) }
&nbsp; &nbsp; &nbsp; &nbsp; method b () { 1 }
&nbsp; &nbsp; }
&nbsp; &nbsp; dies_ok( { Zoo.new.a }, &quot;can't call current object methods on lexical data structures&quot;, :todo&lt;bug&gt;);
&nbsp; &nbsp; dies_ok( { Zoo.new.c }, &quot;meth(%h) is not a valid method call syntax&quot;, :todo&lt;bug&gt;);
}</pre>
</div>


<pre>    $obj.doit(1,2,3)
    doit $obj: 1,2,3</pre>

<p>Indirect object notation now requires a colon after the invocant if there are any arguments. If there are no arguments and you omit the colon, the notation is parsed either as a named unary operator or a list operator with one argument.</p>

<p>These two are considered method calls, which will fall back to a subroutine call if the method was not found:</p>

<pre>    $handle.close
    close $handle:</pre>

<p>To reject method call and only consider subs, simply omit the colon from the invocation line:</p>

<pre>    close($handle)
    close $handle</pre>

<p>However, here the built-in <b>IO</b> class defines <code>method close is export ()</code>, which puts a <code>multi sub close (IO)</code> in scope by default. Thus if the <code>$handle</code> evaluates to an IO object, then the two subroutine calls above are still translated into method calls.</p>

<p>Dot notation can omit the invocant if it&#39;s in <code>$_</code>:</p>

<pre>    .doit(1,2,3)</pre>

<p>It can use a simple scalar variable for the method name:</p>

<pre>    $obj.$methodname(1,2,3)</pre>

<p>The method name may also be quoted with either single or double quotes:</p>

<pre>    $obj.&#34;$methodname&#34;(1,2,3)   # same as previous
    $obj.&#39;$methodname&#39;(1,2,3)   # call method with $ in name!</pre>

<p>The latter is especially useful for postfix forms that might be confusing to the lexer or to the human reader:</p>

<pre>    $filename.&#39;-e&#39;      # same as -e $filename.
    .&#39;-e&#39;               # same as -e $_</pre>

<p>And in fact, if there is a choice between a unary prefix and a postfix operator, the indirect forms will choose the prefix operator. See S03. Likewise, presuming that <code>$op</code> does not name an ordinary method on <code>$left</code>, this calls any arbitrary infix operator:</p>

<pre>    $left.$op($right)</pre>

<p>Of course you can force that with:</p>

<pre>    $left.infix:{$op}($right)</pre>

<p>The <code>q</code> forms of quoting are not allowed for method indirection, since they&#39;d be taken as ordinary method names.</p>

<p>You must use a special syntax to call a private method:</p>

<pre>    $mybrain!think($pinky)</pre>

<p>Parentheses (or a colon) are required on the dot notation if there are any arguments (not counting adverbial arguments). There may be no space between the method name and the left parenthesis unless you use the dot form of parentheses:</p>

<pre>    .doit       # okay, no arguments
    .doit()     # okay, no arguments
    .doit ()    # ILLEGAL (two terms in a row)
    .doit.()    # okay, no arguments, same as .doit()
    .doit\ .()  # okay, no arguments, same as .doit() (long dot form)</pre>

<p>However, you can turn any of the legal forms above into a list operator by appending a colon:</p>

<pre>    .doit: 1,2,3        # okay, three arguments
    .doit(1): 2,3       # okay, one argument plus list
    .doit (): 1,2,3     # ILLEGAL (two terms in a row)
    .doit.(1): 2,3      # okay, same as .doit(1,2,3)
    .doit\ .(1,2): 3    # okay, same as .doit(1,2,3)</pre>

<p>In particular, this allows us to pass a closure in addition to the &#34;normal&#34; arguments:</p>

<pre>    .doit: { $^a &#60;=&#62; $^b }              # okay
    .doit(): { $^a &#60;=&#62; $^b }            # okay
    .doit(1,2,3): { $^a &#60;=&#62; $^b }       # okay</pre>

<p>In case of ambiguity between indirect object notation and dot form, the nearest thing wins:</p>

<pre>    dothis $obj.dothat: 1,2,3</pre>

<p>means</p>

<pre>    dothis ($obj.dothat(1,2,3))</pre>

<p>and you must say</p>

<pre>    dothis ($obj.dothat): 1,2,3</pre>

<p>or</p>

<pre>    $obj.dothat.dothis: 1,2,3</pre>

<p>if you mean the other thing.</p>

<p>Also note that if any term in a list is a bare closure or pointy sub, it will be considered to be the final argument of its list unless the closure&#39;s right curly is followed immediately by comma or comma surrogate. In particular, a method call does *not* extend the list, so you can say:</p>

<pre>    @list.grep: { $_ % 2 }.map: { $_ - 1 }.say</pre>

<p>and that will be taken as equivalent to</p>

<pre>    @list.grep({ $_ % 2 }).map({ $_ - 1 }).say</pre>

<p>Methods (and subs) may be declared as lvalues with <code>is rw</code>. You can use an argumentless <code>rw</code> method anywhere you can use a variable, including in <code>temp</code> and <code>let</code> statements. (In fact, you can use an <code>rw</code> method with arguments as a variable as long as the arguments are used only to identify the actual value to change, and don&#39;t otherwise have strange side effects that differ between rvalue and lvalue usage. Setter methods that expect the new value as an argument do not fall into the well-behaved category, however.)</p>

<p>Method calls on mutable scalars always go to the object contained in the scalar (autoboxing value types as necessary):</p>

<pre>    $result = $object.doit();
    $length = &#34;mystring&#34;.codes;</pre>

<p>Method calls on non-scalar variables just calls the <code>Array</code>, <code>Hash</code> or <code>Code</code> object bound to the variable:</p>

<pre>    $elems = @array.elems;
    @keys  = %hash.keys;
    $sig   = &#38;sub.signature;</pre>

<p>Use the <code>VAR</code> pseudo-function on a scalar variable to get at its underlying <code>Scalar</code> object:</p>

<pre>    if VAR($scalar).readonly {...}</pre>

<p>There&#39;s also a corresponding postfix:&#60;VAR&#62; macro that can be used as if it were a method:</p>

<pre>    if $scalar.VAR.readonly {...}</pre>

<p>(But since it&#39;s a macro, <code>VAR</code> is not dispatched as a real method. To dispatch to a real <code>.VAR</code> method use the indirect <code>$obj.&#34;VAR&#34;</code> form.)</p>

<p>You can also get at the container through the appropriate symbol table:</p>

<pre>    if MY::&#60;$scalar&#62;.readonly {...}</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Class_methods"
>Class methods</a></h1>

<p>Other OO languages give you the ability to declare &#34;class&#34; methods that either don&#39;t need or actively prohibit calls on instances. Perl 6 gives you a choice. If you declare an ordinary method, it can function as a &#34;class&#34; method when you pass it a prototype object such as &#34;Dog&#34; regardless of how defined the prototype object is, as long as the method body doesn&#39;t try to access any information that is undefined in the current instance.</p>

<p>Alternately, you can associate a class method with the current metaclass instance, which as a singleton object knows your package, and can function as a more traditional &#34;class&#34; method:</p>

<pre>    our $count;
    method ^count { return $count }</pre>

<p>Such a <i>metaclass method</i> is always delegated to the <code>HOW</code> object just as methods like <code>.does</code> are, so it&#39;s possible to call this as <code>Dog.count</code> or <code>$dog.count</code>. However, best practice is probably to call such a class method as <code>Dog.^count</code> or <code>$dog.^count</code> to make it clear that it&#39;s in its own namespace separate from ordinary methods, and so that your class method cannot be accidentally overridden by an ordinary method in a subclass--presuming you don&#39;t want to allow for that possibility.</p>

<a href="#" onclick="return tog_quote(20);">
<div ID="header_shown_20" style="display: none;">
- Hide the snippet from t/oo/attributes/class.t (line 12 ~ line 47) -
</div>
<div ID="header_hidden_20" style="display: block;">
- Show the snippet from t/oo/attributes/class.t (line 12 ~ line 47) -
</div>
</a>
<div ID="hide_20" style="display:none; border:1px solid">
<pre style="margin-left: 6px">#L&lt;S12/Class methods/metaclass method always delegated&gt;

plan 17;

ok eval('class Foo { our $.bar = 23; our $.yada is rw = 13; }; 1'), 'class attributes are parsed';

my $test = 0;
ok eval('$test = Foo.bar'), 'accessors for class attributes work';
is $test, 23, 'class attributes really work';

ok eval('class Baz is Foo {}; 1'), 'inheriting class attributes parsed';

my $test2 = 0;
ok eval('$test2 = Baz.bar'), 'inherited class attribute accessors work';
is $test2, 23, 'inherited class attributes really work';

my $test3 = 0;
ok eval('Baz.yada = 42; $test3 = Baz.yada'), 'inherited rw class attribute accessors work';
is $test3, 42, 'inherited rw class attributes really work';

ok eval('class Quux is Foo { has $.bar = 17; }; 1'),
&nbsp; &nbsp; 'overriding with instance method allowed';
my $test4 = 0;
ok eval('$test4 = Quux.new()'),
&nbsp; &nbsp; 'Can instantiate with overridden instance method';
is $test4.bar, 17, 'Instance call gets instance attribute, not class attribute';
my $test5 = 0;
ok eval('$test5 = Quux.bar'), 'class attribute still accessible via class name', :todo&lt;feature&gt;;
is $test5, 23, 'class attribute really works, even when overridden', :todo&lt;feature&gt;;
my $test6 = 0;
ok eval('$test6 = Quux.^bar'), 'class attribute accessible via ^name', :todo&lt;feature&gt;;
is $test6, 23, 'class attribute via ^name really works', :todo&lt;feature&gt;;
my $test7 = 0;
ok eval('$test7 = $test4.^bar'),
&nbsp; &nbsp; 'class attribute accessible via ^name called on instance', :todo&lt;feature&gt;;
is $test7, 23, 'class attribute via $obj.^name really works', :todo&lt;feature&gt;;</pre>
</div>


<h1><a class='u' href='#___top' title='click to go to top of document'
name="Submethods"
>Submethods</a></h1>

<a href="#" onclick="return tog_quote(2);">
<div ID="header_shown_2" style="display: none;">
- Hide the snippet from t/oo/submethods.t (line 12 ~ line 122) -
</div>
<div ID="header_hidden_2" style="display: block;">
- Show the snippet from t/oo/submethods.t (line 12 ~ line 122) -
</div>
</a>
<div ID="hide_2" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S12/Submethods&gt;
{
&nbsp; my $was_in_foo_build = 0;
&nbsp; my $was_in_bar_build = 0;

&nbsp; lives_ok {
&nbsp; &nbsp; class Foo &nbsp; &nbsp; &nbsp; &nbsp;{ submethod BUILD() { $was_in_foo_build++ } }
&nbsp; &nbsp; class Bar is Foo { submethod BUILD() { $was_in_bar_build++ } }
&nbsp; }, &quot;class definitions were parsed/run/compiled&quot;;

&nbsp; my $a;
&nbsp; ok eval('$a = Foo.new()'), &nbsp; &nbsp;&quot;Foo.new() worked (1)&quot;;
&nbsp; is $was_in_foo_build, 1, &nbsp; &nbsp; &nbsp;&quot;Foo's BUILD was called&quot;;
&nbsp; # is instead of todo_is to avoid unexpected succeedings
&nbsp; is $was_in_bar_build, 0, &nbsp; &nbsp; &nbsp;&quot;Bar's BUILD was not called&quot;;

&nbsp; my $b;
&nbsp; ok eval('$b = Bar.new()'), &nbsp; &nbsp;&quot;Bar.new() worked&quot;;
&nbsp; is $was_in_foo_build, 2, &nbsp; &nbsp; &nbsp;&quot;Foo's BUILD was called again&quot;;
&nbsp; is $was_in_bar_build, 1, &nbsp; &nbsp; &nbsp;&quot;Bar's BUILD was called, too&quot;;

&nbsp; # The next three tests are basically exactly the same as the first three tests
&nbsp; # (not counting the initial class definition). This is to verify our call to
&nbsp; # Bar.new didn't removed/changed some internal structures which'd prevent
&nbsp; # Foo.BUILD of getting called.
&nbsp; my $c;
&nbsp; ok eval('my $c = Foo.new()'), &quot;Foo.new() worked (2)&quot;;
&nbsp; is $was_in_foo_build, 3, &nbsp; &nbsp; &nbsp;&quot;Foo's BUILD was called again&quot;;
&nbsp; is $was_in_bar_build, 1, &nbsp; &nbsp; &nbsp;&quot;Bar's BUILD was not called again&quot;;
}

# See thread &quot;BUILD and other submethods&quot; on p6l
# L&lt;<a href="http://groups-beta.google.com/group/perl.perl6.language/msg/e9174e5538ded4a3">&quot;http://groups-beta.google.com/group/perl.perl6.language/msg/e9174e5538ded4a3&quot;</a>&gt;
{
&nbsp; my $was_in_baz_submethod &nbsp;= 0;
&nbsp; my $was_in_grtz_submethod = 0;

&nbsp; class Baz &nbsp; &nbsp; &nbsp; &nbsp; { submethod blarb() { $was_in_baz_submethod++ } }
&nbsp; class Grtz is Baz { submethod blarb() { $was_in_grtz_submethod++ } }

&nbsp; my ($baz, $grtz);
&nbsp; ok eval('$baz &nbsp;= Baz.new'), &nbsp;&quot;Baz.new() worked&quot;;
&nbsp; ok eval('$grtz = Grtz.new'), &quot;Grtz.new() worked&quot;;

&nbsp; try { $baz.blarb };
&nbsp; is $was_in_baz_submethod, &nbsp;1, &quot;Baz's submethod blarb was called&quot;;
&nbsp; # No :todo to avoid unexpected suceedings
&nbsp; is $was_in_grtz_submethod, 0, &quot;Grtz's submethod blarb was not called&quot;;

&nbsp; try { $grtz.blarb };
&nbsp; is $was_in_baz_submethod, &nbsp;1, &quot;Baz's submethod blarb was not called again&quot;;
&nbsp; # No :todo to avoid unexpected suceedings
&nbsp; is $was_in_grtz_submethod, 1, &quot;Grtz's submethod blarb was called now&quot;;

&nbsp; try { $grtz.Baz::blarb };
&nbsp; is $was_in_baz_submethod, &nbsp;2, &quot;Baz's submethod blarb was called again now&quot;;
&nbsp; # No :todo to avoid unexpected suceedings
&nbsp; is $was_in_grtz_submethod, 1, &quot;Grtz's submethod blarb was not called again&quot;;
}

# Roles with BUILD
# See thread &quot;Roles and BUILD&quot; on p6l
# L&lt;<a href="http://www.nntp.perl.org/group/perl.perl6.language/21277">&quot;http://www.nntp.perl.org/group/perl.perl6.language/21277&quot;</a>&gt;
{
&nbsp; my $was_in_a1_build = 0;
&nbsp; my $was_in_a2_build = 0;
&nbsp; role RoleA1 &nbsp;{ multi submethod BUILD() { $was_in_a1_build++ } }
&nbsp; role RoleA2 &nbsp;{ multi submethod BUILD() { $was_in_a2_build++ } }
&nbsp; class ClassA does RoleA1 does RoleA2 {}

&nbsp; ClassA.new;

&nbsp; is $was_in_a1_build, 1, &quot;roles' BUILD submethods were called when mixed in a class (1)&quot;;
&nbsp; is $was_in_a2_build, 1, &quot;roles' BUILD submethods were called when mixed in a class (2)&quot;;
}

{
&nbsp; my $was_in_b1_build = 0;
&nbsp; my $was_in_b2_build = 0;
&nbsp; role RoleB1 &nbsp;{ multi submethod BUILD() { $was_in_b1_build++ } }
&nbsp; role RoleB2 &nbsp;{ multi submethod BUILD() { $was_in_b2_build++ } }
&nbsp; class ClassB {}

&nbsp; my $B = ClassB.new;
&nbsp; is $was_in_b1_build, 0, &quot;roles' BUILD submethods were not yet called (1)&quot;;
&nbsp; is $was_in_b2_build, 0, &quot;roles' BUILD submethods were not yet called (2)&quot;;

&nbsp; eval '$B does RoleB1 does RoleB2';
&nbsp; is $was_in_b1_build, 1, &quot;roles' BUILD submethods were called now (1)&quot;, :todo&lt;feature&gt;;
&nbsp; is $was_in_b2_build, 1, &quot;roles' BUILD submethods were called now (2)&quot;, :todo&lt;feature&gt;;
};

# BUILD with signatures that don't map directly to attributes
{
&nbsp; class ClassC
&nbsp; {
&nbsp; &nbsp; has $.double_value;

&nbsp; &nbsp; submethod BUILD ( $value = 1 )
&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; $.double_value = $value * 2;
&nbsp; &nbsp; }
&nbsp; }

&nbsp; my $C = ClassC.new();
&nbsp; is( $C.double_value, 2,
&nbsp; &nbsp; 'BUILD() should allow default values of optional params in signature' );

&nbsp; my $C2 = ClassC.new( :value(100) );
&nbsp; is( $C2.double_value, 200, '... or value passed in' );
}</pre>
</div>


<p>Submethods are for declaring infrastructural methods that shouldn&#39;t be inherited by subclasses, such as initializers:</p>

<pre>    submethod BUILD ($arg) {
        $.attr = $arg;
    }</pre>

<p>Apart from the keyword, submethod declaration and call syntax is identical to method syntax. You may mix methods and submethods of the same name within the class hierarchy, but only the methods are visible to derived classes via inheritance. A submethod is called only when a method call is dispatched directly to the current class.</p>

<p>[Conjecture: there is some relationship between &#34;submethod BUILD&#34; and &#34;method ^BUILD&#34; that possibly rises to the level of a unifiable identity...]</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Attributes"
>Attributes</a></h1>

<a href="#" onclick="return tog_quote(48);">
<div ID="header_shown_48" style="display: none;">
- Hide the snippet from t/oo/attributes/array.t (line 3 ~ line 21) -
</div>
<div ID="header_hidden_48" style="display: block;">
- Show the snippet from t/oo/attributes/array.t (line 3 ~ line 21) -
</div>
</a>
<div ID="hide_48" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S12/&quot;Attributes&quot;&gt;
# ( The spec doesn't explicitly method that this should
# &nbsp; work, but audreyt and markstos agree it should. 
# &nbsp; Perhaps the spec can be clarified on this point.)

{
&nbsp; &nbsp; class Foo {
&nbsp; &nbsp; &nbsp; &nbsp; has @.a is rw;
&nbsp; &nbsp; &nbsp; &nbsp; method param (*%h) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; @.a = @( %h&lt;key&gt; );
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; self;
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; &nbsp; # The workaround until this is fixed:
&nbsp; &nbsp; # my @f = @( Foo.new.param( key =&gt; &lt;c d&gt;).a );
&nbsp; &nbsp; my @f = Foo.new.param( key =&gt; &lt;c d&gt; ).a;
&nbsp; &nbsp; is_deeply(@f, &lt;c d&gt;, &quot;@.a attribute is returned as array&quot;);
}</pre>
</div>


<a href="#" onclick="return tog_quote(47);">
<div ID="header_shown_47" style="display: none;">
- Hide the snippet from t/oo/attributes/attribute_initialization.t (line 7 ~ line 48) -
</div>
<div ID="header_hidden_47" style="display: block;">
- Show the snippet from t/oo/attributes/attribute_initialization.t (line 7 ~ line 48) -
</div>
</a>
<div ID="hide_47" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S12/&quot;Attributes&quot;&gt;

plan 8;

diag('Test for class attribute initialization');


{
	class T1 { }
	class T2 { }
	ok eval(q{class T1 is also { has $.t = 1 }; 1}),
		&quot;Try to initialize public attribute&quot;;

	ok eval(q{
		class T2 is also {
		 &nbsp; &nbsp;has $!t = 2;
		 &nbsp; &nbsp;method get { $!t };
		}; 1 }),
		&quot;Try to initialize private attribute&quot;;


	my T1 $o1;
	my T2 $o2;

	$o1 = T1.new();
	$o2 = T2.new();
	is $o1.t, 1,
		&quot;Testing value for initialized public attribute.&quot;;
	dies_ok { $o2.t },
		&quot;Try to access the initialized private attribute.&quot;;
	is try { $o2.get }, 2,
		&quot;Testing value for initialized private attribue.&quot;;

	$o1 = T1.new( t =&gt; 3 );
	$o2 = T2.new( t =&gt; 4 );
	is $o1.t, 3,
		&quot;Testing value for attributes which is initialized by constructor.&quot;;
	dies_ok { $o2.t },
		&quot;Try to access the private attribute which is initialized by constructor.&quot;;
	is try { $o2.get }, 4,
		&quot;Testing value for private attribue which is initialized by constructor.&quot;;
}</pre>
</div>


<a href="#" onclick="return tog_quote(40);">
<div ID="header_shown_40" style="display: none;">
- Hide the snippet from t/oo/attributes/instance.t (line 87 ~ line 127) -
</div>
<div ID="header_hidden_40" style="display: block;">
- Show the snippet from t/oo/attributes/instance.t (line 87 ~ line 127) -
</div>
</a>
<div ID="hide_40" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S12/&quot;Attributes&quot;&gt;

class Foo5 {
&nbsp; has $.tail is rw;
&nbsp; has @.legs;
&nbsp; has $!brain;

&nbsp; method set_legs &nbsp;(*@legs) { @.legs = @legs }
&nbsp; method inc_brain () &nbsp; &nbsp; &nbsp;{ $!brain++ }
&nbsp; method get_brain () &nbsp; &nbsp; &nbsp;{ $!brain }
};

{
&nbsp; &nbsp; my $foo = Foo5.new();
&nbsp; &nbsp; ok($foo ~~ Foo5, '... our Foo5 instance was created');
&nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; lives_ok {
&nbsp; &nbsp; &nbsp; &nbsp; $foo.tail = &quot;a&quot;;
&nbsp; &nbsp; }, &quot;setting a public rw attribute&quot;;
&nbsp; &nbsp; is($foo.tail, &quot;a&quot;, &quot;getting a public rw attribute&quot;);
&nbsp; &nbsp; 
&nbsp; &nbsp; lives_ok {
&nbsp; &nbsp; &nbsp; &nbsp; $foo.set_legs(1,2,3)
&nbsp; &nbsp; }, &quot;setting a public ro attribute (1)&quot;;
&nbsp; &nbsp; is($foo.legs.[1], 2, &quot;getting a public ro attribute (1)&quot;);
&nbsp; &nbsp; 
&nbsp; &nbsp; dies_ok {
&nbsp; &nbsp; &nbsp; &nbsp; $foo.legs = (4,5,6);
&nbsp; &nbsp; }, &quot;setting a public ro attribute (2)&quot;, :todo&lt;feature&gt;;
&nbsp; &nbsp; is($foo.legs.[1], 2, &quot;getting a public ro attribute (2)&quot;, :todo&lt;feature&gt;);
&nbsp; &nbsp; 
&nbsp; &nbsp; lives_ok {
&nbsp; &nbsp; &nbsp; &nbsp; $foo.inc_brain();
&nbsp; &nbsp; }, &nbsp;&quot;modifiying a private attribute (1)&quot;;
&nbsp; &nbsp; is($foo.get_brain, 1, &quot;getting a private attribute (1)&quot;);
&nbsp; &nbsp; lives_ok {
&nbsp; &nbsp; &nbsp; &nbsp; $foo.inc_brain();
&nbsp; &nbsp; }, &nbsp;&quot;modifiying a private attribute (2)&quot;;
&nbsp; &nbsp; is($foo.get_brain, 2, &quot;getting a private attribute (2)&quot;);
}</pre>
</div>


<a href="#" onclick="return tog_quote(38);">
<div ID="header_shown_38" style="display: none;">
- Hide the snippet from t/oo/attributes/recursive.t (line 13 ~ line 36) -
</div>
<div ID="header_hidden_38" style="display: block;">
- Show the snippet from t/oo/attributes/recursive.t (line 13 ~ line 36) -
</div>
</a>
<div ID="hide_38" style="display:none; border:1px solid">
<pre style="margin-left: 6px">#L&lt;S12/Attributes&gt;
{
&nbsp; &nbsp; class A {
&nbsp; &nbsp; &nbsp; &nbsp; has A $.attr is rw;
&nbsp; &nbsp; };

&nbsp; &nbsp; ok !($!), 'Can create class with a recursively-typed attribute';

&nbsp; &nbsp; my A $a;
&nbsp; &nbsp; my A $b;
&nbsp; &nbsp; try {
&nbsp; &nbsp; &nbsp; &nbsp; $a .= new();
&nbsp; &nbsp; &nbsp; &nbsp; $b .= new(:attr($a));
&nbsp; &nbsp; };
&nbsp; &nbsp; ok !($!), 'Can instantiate class with recursively-typed attribute';
&nbsp; &nbsp; isa_ok $a, 'A', 'Sanity check, $a is of type A';
&nbsp; &nbsp; is $b.attr, $a, &quot;Recursively-typed attribute stores correctly&quot;;
&nbsp; &nbsp; try {
&nbsp; &nbsp; &nbsp; &nbsp; $a.attr = $b;
&nbsp; &nbsp; };
&nbsp; &nbsp; ok !($!), &quot;Cycles are fine&quot;;
&nbsp; &nbsp; is $b.attr.attr, $b, &quot;Cycles resolve correctly&quot;;
}</pre>
</div>


<p>Attributes are stored in an opaque datatype, not in a hash. Not even the class has to care how they&#39;re stored, since they&#39;re declared much like ordinary variables. Instead of <code>my</code>, use <code>has</code>:</p>

<pre>    class Dog is Mammal {
        has $.name = &#34;fido&#34;;
        has $.tail is rw;
        has @.legs;
        has $!brain;
        ...
    }</pre>

<p>Public attributes have a secondary sigil of &#34;dot&#34;, indicating the automatic generation of an accessor method of the same name. Private attributes use an exclamation to indicate that no public accessor is generated.</p>

<a href="#" onclick="return tog_quote(43);">
<div ID="header_shown_43" style="display: none;">
- Hide the snippet from t/oo/attributes/instance.t (line 16 ~ line 31) -
</div>
<div ID="header_hidden_43" style="display: block;">
- Show the snippet from t/oo/attributes/instance.t (line 16 ~ line 31) -
</div>
</a>
<div ID="hide_43" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S12/&quot;Attributes&quot; /the automatic generation of an accessor method of the same name\./&gt;

class Foo1 { has $.bar; };

{
&nbsp; &nbsp; my $foo = Foo1.new();
&nbsp; &nbsp; ok($foo ~~ Foo1, '... our Foo1 instance was created');
&nbsp; &nbsp; my $val;
&nbsp; &nbsp; lives_ok {
&nbsp; &nbsp; &nbsp; &nbsp; $val = $foo.can(&quot;bar&quot;)
&nbsp; &nbsp; }, '.. checking autogenerated accessor existence', :todo&lt;feature&gt;;
&nbsp; &nbsp; ok($val, '... $foo.can(&quot;bar&quot;) should have returned true', :todo&lt;feature&gt;);
&nbsp; &nbsp; is($foo.bar(), undef, '.. autogenerated accessor works');
&nbsp; &nbsp; is($foo.bar, undef, '.. autogenerated accessor works w/out parens'); &nbsp; &nbsp;
}</pre>
</div>


<pre>        has $!brain;</pre>

<p>The &#34;true name&#34; of the private variable always has the exclamation, but much like with <code>our</code> variables, you may declare a lexically scoped alias to the private variable by saying:</p>

<pre>        has $brain;     # also declares $!brain;</pre>

<p>And any later references to the private variable within the same block may either use or omit the exclamation, as you wish to emphasize or ignore the privacy of the variable. Outside the block, you must use the <code>!</code> form. If you declare with the <code>!</code> form, you must use that form consistently everywhere. If you declare with the <code>.</code> form, you also get the private <code>!</code> form as a non-virtual name for the actual storage location, and you may use either <code>!</code> or <code>.</code> form anywhere within the class, even if the class is reopened. Outside the class you must use the public <code>.</code> form, or rely on a method call (which can be a private method call, but only for trusted classes).</p>

<p>For public attributes, some traits are copied to the accessor method. The <code>rw</code> trait causes the generated accessor to be declared <code>rw</code>, making it an lvalue method. The default is a read-only accessor.</p>

<a href="#" onclick="return tog_quote(41);">
<div ID="header_shown_41" style="display: none;">
- Hide the snippet from t/oo/attributes/instance.t (line 45 ~ line 67) -
</div>
<div ID="header_hidden_41" style="display: block;">
- Show the snippet from t/oo/attributes/instance.t (line 45 ~ line 67) -
</div>
</a>
<div ID="hide_41" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S12/&quot;Attributes&quot; /making it an lvalue method/&gt;

class Foo3 { has $.bar is rw; };

{
&nbsp; &nbsp; my $foo = Foo3.new();
&nbsp; &nbsp; ok($foo ~~ Foo3, '... our Foo3 instance was created');
&nbsp; &nbsp; my $val;
&nbsp; &nbsp; lives_ok {
&nbsp; &nbsp; &nbsp; &nbsp; $val = $foo.can(&quot;bar&quot;);
&nbsp; &nbsp; }, '.. checking autogenerated accessor existence', :todo&lt;feature&gt;;
&nbsp; &nbsp; ok($val, '... $foo.can(&quot;bar&quot;) should have returned true', :todo&lt;feature&gt;);
&nbsp; &nbsp; is($foo.bar(), undef, '.. autogenerated accessor works');
&nbsp; &nbsp; lives_ok {
&nbsp; &nbsp; &nbsp; &nbsp; $foo.bar = &quot;baz&quot;;
&nbsp; &nbsp; }, '.. autogenerated mutator as lvalue works';
&nbsp; &nbsp; is($foo.bar, &quot;baz&quot;, '.. autogenerated mutator as lvalue set the value correctly'); &nbsp; &nbsp;
&nbsp; &nbsp; lives_ok {
&nbsp; &nbsp; &nbsp; &nbsp; $foo.bar(&quot;baz2&quot;);
&nbsp; &nbsp; }, '.. autogenerated mutator works as method', :todo&lt;feature&gt;; &nbsp; &nbsp;
&nbsp; &nbsp; is($foo.bar, &quot;baz2&quot;, '.. autogenerated mutator as method set the value correctly', :todo&lt;feature&gt;); &nbsp; &nbsp; &nbsp; &nbsp;
}</pre>
</div>


<p>If you declare the class as <code>rw</code>, then all the class&#39;s attributes default to <code>rw</code>, much like a C struct.</p>

<a href="#" onclick="return tog_quote(39);">
<div ID="header_shown_39" style="display: none;">
- Hide the snippet from t/oo/attributes/is_rw_on_class.t (line 7 ~ line 29) -
</div>
<div ID="header_hidden_39" style="display: block;">
- Show the snippet from t/oo/attributes/is_rw_on_class.t (line 7 ~ line 29) -
</div>
</a>
<div ID="hide_39" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S12/&quot;Attributes&quot; /If you declare the class as/&gt;

class Foo {
&nbsp; &nbsp; has $.readonly_attr;
}

{
&nbsp; &nbsp; my Foo $foo .= new;
&nbsp; &nbsp; dies_ok { $foo.readonly_attr++ }, &quot;basic sanity&quot;, :todo&lt;bug&gt;;
}


class Bar is rw {
&nbsp; &nbsp; has $.readwrite_attr;
}

{
&nbsp; &nbsp; my Bar $bar .= new;
&nbsp; &nbsp; lives_ok { $bar.readwrite_attr++ },
&nbsp; &nbsp; &nbsp; &nbsp; &quot;'is rw' on the class declaration applies to all attributes (1)&quot;;
&nbsp; &nbsp; is $bar.readwrite_attr, 1,
&nbsp; &nbsp; &nbsp; &nbsp; &quot;'is rw' on the class declaration applies to all attributes (2)&quot;;
}</pre>
</div>


<p>You may write your own accessors to override any or all of the autogenerated ones.</p>

<p>The attribute variables may be used within instance methods to refer directly to the attribute values. Outside the instance methods, the only access to attributes is through the accessors since an object has to be specified. The dot form of attribute variables may be used in derived classes because the dot form always implies a virtual accessor call. Every <i>dot</i> declaration also declares a corresponding private <i>exclamation</i> storage location, and the exclamation form may be used only in the actual class, not in derived classes. Reference to the internal storage location via <code>$!foo</code> should generally be restricted to submethods. Ordinary methods should stick to the <code>$.foo</code> form.</p>

<p>Because <code>$.foo</code>, <code>@.foo</code>, <code>%.foo</code>, <code>&#38;.foo</code> are just shorthands of <code>self.foo</code> with different contexts, the class does not need to declare <code>has $.foo</code> as an attribute -- a <code>method foo</code> declaration can work just as well.</p>

<p>The dot form can take an argument list as well. These are all equivalent:</p>

<pre>    self.foo(1,2,3);    # a regular method call
    self.foo.(1,2,3);   # ditto
    $.foo(1,2,3);       # calls self.foo under $ context
    $.foo.(1,2,3);      # ditto
    @.foo(1,2,3);       # calls self.foo under @ context
    @.foo.(1,2,3);      # ditto</pre>

<p>Pseudo-assignment to an attribute declaration specifies the default value. The value on the right is evaluated at class composition time, that is, while the class is being compiled and the class object constructed. However, if the default value is a closure, that closure will be executed later at object initialization time. (Use a double closure to initialize to a closure value.) The topic of the closure will be the attribute being initialized, while &#34;self&#34; refers to the entire object being initialized.</p>

<a href="#" onclick="return tog_quote(45);">
<div ID="header_shown_45" style="display: none;">
- Hide the snippet from t/oo/attributes/defaults.t (line 7 ~ line 21) -
</div>
<div ID="header_hidden_45" style="display: block;">
- Show the snippet from t/oo/attributes/defaults.t (line 7 ~ line 21) -
</div>
</a>
<div ID="hide_45" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S12/&quot;Attributes&quot; /The value on the right is evaluated at class composition/&gt;

my $got_a_num; &nbsp;sub get_a_num &nbsp;{ $got_a_num++; &nbsp;42 }
my $got_a_str; &nbsp;sub get_a_str &nbsp;{ $got_a_str++; &nbsp;&quot;Pugs&quot; }

my $got_a_code;
my $was_in_closure;
sub get_a_code {
&nbsp; &nbsp; $got_a_code++;
&nbsp; &nbsp; return {
&nbsp; &nbsp; &nbsp; &nbsp; $was_in_closure++;
&nbsp; &nbsp; &nbsp; &nbsp; 42;
&nbsp; &nbsp; };
}</pre>
</div>


<a href="#" onclick="return tog_quote(44);">
<div ID="header_shown_44" style="display: none;">
- Hide the snippet from t/oo/attributes/defaults.t (line 22 ~ line 102) -
</div>
<div ID="header_hidden_44" style="display: block;">
- Show the snippet from t/oo/attributes/defaults.t (line 22 ~ line 102) -
</div>
</a>
<div ID="hide_44" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S12/&quot;Attributes&quot; /the attribute being initialized/&gt;

my $set_by_code_attr;

eval 'class Foo {
&nbsp; &nbsp; has $.num &nbsp;= get_a_num();
&nbsp; &nbsp; has $.str &nbsp;= { get_a_str() };
&nbsp; &nbsp; has $.code = { get_a_code() };

&nbsp; &nbsp; has $.set_by_code = {
&nbsp; &nbsp; &nbsp; &nbsp; $set_by_code_attr := $_;
&nbsp; &nbsp; &nbsp; &nbsp; 42;
&nbsp; &nbsp; };

&nbsp; &nbsp; has $.self_in_code = { self.echo };

&nbsp; &nbsp; method echo { &quot;echo&quot; }
}';

{
&nbsp; &nbsp; is $got_a_num, 1, &quot;default should be called at compile-time&quot;, :todo&lt;feature&gt;;
&nbsp; &nbsp; my Foo $foo .= new;
&nbsp; &nbsp; is $got_a_num, 1, &quot;default should be called only once, at compile-time (1)&quot;, :todo&lt;feature&gt;;
&nbsp; &nbsp; is $foo.num, &nbsp;42, &quot;attribute default worked&quot;, :todo&lt;feature&gt;;
&nbsp; &nbsp; is $got_a_num, 1, &quot;default should be called only once, at compile-time (2)&quot;, :todo&lt;feature&gt;;
}

{
&nbsp; &nbsp; $got_a_str = 0; &nbsp;# reset

&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; my Foo $foo .= new;
&nbsp; &nbsp; &nbsp; &nbsp; is $got_a_str, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1, &quot;using a coderef as a default value delays execution&quot;, :todo&lt;feature&gt;;
&nbsp; &nbsp; &nbsp; &nbsp; is try { $foo.str }, &quot;Pugs&quot;, &quot;attribute default worked&quot;, :todo&lt;feature&gt;;
&nbsp; &nbsp; }

&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; my Foo $foo .= new;
&nbsp; &nbsp; &nbsp; &nbsp; is $got_a_str, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2, &quot;using a coderef as a default value delays execution&quot;, :todo&lt;feature&gt;;
&nbsp; &nbsp; &nbsp; &nbsp; is try { $foo.str }, &quot;Pugs&quot;, &quot;attribute default worked&quot;, :todo&lt;feature&gt;;
&nbsp; &nbsp; }
}

{
&nbsp; &nbsp; $got_a_code = 0; &nbsp;# reset

&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; my Foo $foo .= new;
&nbsp; &nbsp; &nbsp; &nbsp; is $got_a_code, &nbsp; &nbsp; 1, &quot;using a coderef as a default value delays execution&quot;, :todo&lt;feature&gt;;
&nbsp; &nbsp; &nbsp; &nbsp; is $was_in_closure, 0, &quot;sub-coderef not yet executed&quot;, :todo&lt;feature&gt;;
&nbsp; &nbsp; &nbsp; &nbsp; try { $foo.code };
&nbsp; &nbsp; &nbsp; &nbsp; is $was_in_closure, 0, &quot;sub-coderef still not executed&quot;, :todo&lt;feature&gt;;
&nbsp; &nbsp; }

&nbsp; &nbsp; {
&nbsp; &nbsp; &nbsp; &nbsp; my Foo $foo .= new;
&nbsp; &nbsp; &nbsp; &nbsp; is $got_a_code, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2, &quot;using a coderef as a default value delays execution&quot;, :todo&lt;feature&gt;;
&nbsp; &nbsp; &nbsp; &nbsp; is $was_in_closure, &nbsp; &nbsp; &nbsp;0, &quot;sub-coderef not yet executed&quot;, :todo&lt;feature&gt;;
&nbsp; &nbsp; &nbsp; &nbsp; is try { $foo.code() }, 42, &quot;sub-coderef execution works&quot;, :todo&lt;feature&gt;;
&nbsp; &nbsp; &nbsp; &nbsp; is $was_in_closure, &nbsp; &nbsp; &nbsp;1, &quot;sub-coderef still not executed&quot;, :todo&lt;feature&gt;;
&nbsp; &nbsp; }
}

{
&nbsp; &nbsp; my Foo $foo .= new;

&nbsp; &nbsp; is try { $foo.set_by_code }, 42, '$_ is the attribute being initialized (1)', :todo&lt;feature&gt;;
&nbsp; &nbsp; is $set_by_code_attr, &nbsp; &nbsp; &nbsp; &nbsp;42, '$_ is the attribute being initialized (2)', :todo&lt;feature&gt;;

&nbsp; &nbsp; lives_ok { $set_by_code_attr++ },
&nbsp; &nbsp; &nbsp; &nbsp; '$_ is the attribute being initialized (3)';

&nbsp; &nbsp; is try { $foo.set_by_code }, 43, '$_ is the attribute being initialized (4)', :todo&lt;feature&gt;;
&nbsp; &nbsp; is $set_by_code_attr, &nbsp; &nbsp; &nbsp; &nbsp;43, '$_ is the attribute being initialized (5)', :todo&lt;feature&gt;;
}

{
&nbsp; &nbsp; my Foo $foo .= new;

&nbsp; &nbsp; is try { $foo.self_in_code }, &quot;echo&quot;, &quot;self is the object being initialized&quot;, :todo&lt;feature&gt;;
}</pre>
</div>


<a href="#" onclick="return tog_quote(42);">
<div ID="header_shown_42" style="display: none;">
- Hide the snippet from t/oo/attributes/instance.t (line 32 ~ line 44) -
</div>
<div ID="header_hidden_42" style="display: block;">
- Show the snippet from t/oo/attributes/instance.t (line 32 ~ line 44) -
</div>
</a>
<div ID="hide_42" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S12/&quot;Attributes&quot; /Pseudo-assignment to an attribute declaration specifies the default/&gt;

eval 'class Foo2 { has $.bar = &quot;baz&quot;; }';

{
&nbsp; &nbsp; my $foo = eval 'Foo2.new()';
&nbsp; &nbsp; ok(eval('$foo ~~ Foo2'), '... our Foo2 instance was created');
&nbsp; &nbsp; ok(eval('$foo.can(&quot;bar&quot;)'), '.. checking autogenerated accessor existence', :todo&lt;feature&gt;);
&nbsp; &nbsp; is(eval('$foo.bar()'), &quot;baz&quot;, '.. autogenerated accessor works');
&nbsp; &nbsp; is(eval('$foo.bar'), &quot;baz&quot;, '.. autogenerated accessor works w/out parens');
&nbsp; &nbsp; # what exactly will happen if we try to set bar()
}</pre>
</div>


<p>Class attributes are declared with either <code>my</code> or <code>our</code>. The only difference from ordinary <code>my</code> or <code>our</code> variables is that an accessor is generated according to the secondary sigil:</p>

<a href="#" onclick="return tog_quote(46);">
<div ID="header_shown_46" style="display: none;">
- Hide the snippet from t/oo/attributes/class.t (line 11 ~ line 47) -
</div>
<div ID="header_hidden_46" style="display: block;">
- Show the snippet from t/oo/attributes/class.t (line 11 ~ line 47) -
</div>
</a>
<div ID="hide_46" style="display:none; border:1px solid">
<pre style="margin-left: 6px">#L&lt;S12/Attributes/&quot;Class attributes are declared&quot;&gt;
#L&lt;S12/Class methods/metaclass method always delegated&gt;

plan 17;

ok eval('class Foo { our $.bar = 23; our $.yada is rw = 13; }; 1'), 'class attributes are parsed';

my $test = 0;
ok eval('$test = Foo.bar'), 'accessors for class attributes work';
is $test, 23, 'class attributes really work';

ok eval('class Baz is Foo {}; 1'), 'inheriting class attributes parsed';

my $test2 = 0;
ok eval('$test2 = Baz.bar'), 'inherited class attribute accessors work';
is $test2, 23, 'inherited class attributes really work';

my $test3 = 0;
ok eval('Baz.yada = 42; $test3 = Baz.yada'), 'inherited rw class attribute accessors work';
is $test3, 42, 'inherited rw class attributes really work';

ok eval('class Quux is Foo { has $.bar = 17; }; 1'),
&nbsp; &nbsp; 'overriding with instance method allowed';
my $test4 = 0;
ok eval('$test4 = Quux.new()'),
&nbsp; &nbsp; 'Can instantiate with overridden instance method';
is $test4.bar, 17, 'Instance call gets instance attribute, not class attribute';
my $test5 = 0;
ok eval('$test5 = Quux.bar'), 'class attribute still accessible via class name', :todo&lt;feature&gt;;
is $test5, 23, 'class attribute really works, even when overridden', :todo&lt;feature&gt;;
my $test6 = 0;
ok eval('$test6 = Quux.^bar'), 'class attribute accessible via ^name', :todo&lt;feature&gt;;
is $test6, 23, 'class attribute via ^name really works', :todo&lt;feature&gt;;
my $test7 = 0;
ok eval('$test7 = $test4.^bar'),
&nbsp; &nbsp; 'class attribute accessible via ^name called on instance', :todo&lt;feature&gt;;
is $test7, 23, 'class attribute via $obj.^name really works', :todo&lt;feature&gt;;</pre>
</div>


<a href="#" onclick="return tog_quote(37);">
<div ID="header_shown_37" style="display: none;">
- Hide the snippet from t/oo/attributes/recursive.t (line 37 ~ line 54) -
</div>
<div ID="header_hidden_37" style="display: block;">
- Show the snippet from t/oo/attributes/recursive.t (line 37 ~ line 54) -
</div>
</a>
<div ID="hide_37" style="display:none; border:1px solid">
<pre style="margin-left: 6px">#L&lt;S12/Attributes/&quot;Class attributes are declared&quot;&gt;
{
&nbsp; &nbsp; class B {
&nbsp; &nbsp; &nbsp; &nbsp; my B $.attr is rw;
&nbsp; &nbsp; };
&nbsp; &nbsp; 
&nbsp; &nbsp; ok !($!), &quot;Can create class with a recursively-typed class lexical&quot;;

&nbsp; &nbsp; my B $a;
&nbsp; &nbsp; try {
&nbsp; &nbsp; &nbsp; &nbsp; $a .= new();
&nbsp; &nbsp; &nbsp; &nbsp; B.attr = $a;
&nbsp; &nbsp; };
&nbsp; &nbsp; ok !($!), &quot;Can instantiate class with recursively-typed class lexical&quot;;
&nbsp; &nbsp; is B.attr, $a, &quot;Recursively-typed class lexical stores correctly&quot;;
&nbsp; &nbsp; 
}</pre>
</div>


<pre>    our $.count;        # generates a public read-only .count accessor
    our %!cache is rw;  # generates no public accessor
    my  $.count;        # generates a public read-only .count accessor
    my  %!cache is rw;  # generates no public accessor</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Construction_and_Initialization"
>Construction and Initialization</a></h1>

<a href="#" onclick="return tog_quote(52);">
<div ID="header_shown_52" style="display: none;">
- Hide the snippet from t/oo/construction.t (line 7 ~ line 51) -
</div>
<div ID="header_hidden_52" style="display: block;">
- Show the snippet from t/oo/construction.t (line 7 ~ line 51) -
</div>
</a>
<div ID="hide_52" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S12/&quot;Construction and Initialization&quot;&gt;

my $in_own = 0;
ok eval('
&nbsp; class OwnConstructor {
&nbsp; &nbsp; has $.x = 13;
&nbsp; &nbsp; method own(Class $class) {
&nbsp; &nbsp; &nbsp; $in_own++;
&nbsp; &nbsp; &nbsp; return $class.bless(:x(42));
&nbsp; &nbsp; }
&nbsp; }
'), &quot;class definition worked&quot;, :todo&lt;feature&gt;;
ok eval('OwnConstr.new ~~ OwnConstr'), &quot;basic class instantiation&quot;, :todo&lt;feature&gt;;
is eval('OwnConstr.new.x'), 13, &nbsp; &nbsp; &nbsp; &nbsp;&quot;basic attribute access&quot;, :todo&lt;feature&gt;;
# As usual, is instead of todo_is to suppress unexpected succeedings
is &nbsp; &nbsp; &nbsp;$in_own, 0, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;own constructor was not called&quot;;
ok eval('OwnConstr.own ~~ OwnConstr'), &quot;own construction instantiated its class&quot;, :todo&lt;feature&gt;;
is eval('OwnConstr.own.x'), 42, &nbsp; &nbsp; &nbsp; &nbsp;&quot;attribute was set from our constructor&quot;, :todo&lt;feature&gt;;
is &nbsp; &nbsp; &nbsp;$in_own, 1, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;own constructor was actually called&quot;, :todo&lt;feature&gt;;


# L&lt;<a href="http://www.mail-archive.com/perl6-language@perl.org/msg20241.html">&quot;http://www.mail-archive.com/perl6-language@perl.org/msg20241.html&quot;</a>&gt;
# provide constructor for single positional argument

class Foo {
&nbsp; has $.a;
&nbsp; 
&nbsp; method new (Class $self: Str $string) {
&nbsp; &nbsp; $.a = $string;
&nbsp; &nbsp; return $self.bless(string =&gt; $string);
&nbsp; }
}


ok 'Foo.new(&quot;a string&quot;) ~~ Foo', '... our Foo instance was created';

is eval('Foo.new(&quot;a string&quot;).a'), 'a string', &quot;our own 'new' was called&quot;, :todo&lt;feature&gt;;


# Using &quot;.=&quot; to create an object
{
&nbsp; class Bar { has $.attr }
&nbsp; my Bar $bar .= new(:attr(42));
&nbsp; is $bar.attr, 42, &quot;instantiating an object using .= worked (1)&quot;;
}</pre>
</div>


<p>All classes inherit a default <code>new</code> constructor from <code>Object</code>. It expects all arguments to be named parameters initializing attributes of the same name. You may write your own <code>new</code> to override the default, or write constructors with any other name you like. As in Perl 5, a constructor is any routine that calls <code>bless</code>. Unlike in Perl 5, you call it as a method on the class object (though any object may be used as a class object), passing the candidate as the first argument. To bless a hash as in Perl 5, say:</p>

<pre>    $object = $class.bless({k1 =&#62; $v1, k2 =&#62; $v2, ...});</pre>

<p>If the candidate is omitted, a candidate object is implicitly created in the current class by calling <code>CREATE</code>:</p>

<pre>    $object = $class.bless(k1 =&#62; $v1, k2 =&#62; $v2, ...)
    $object = $class.bless(:k1($v1), :k2($v2), ...)  # same</pre>

<p>(The default <code>CREATE</code> makes an opaque object.)</p>

<p>All arguments to this form of <code>bless</code> must be named arguments, not positional. Hence, the main purpose of custom constructors is to turn positional arguments into named arguments for <code>bless</code>. The <code>bless</code> method allows an object to be used for its class invocant. (Your constructor need not allow this). In any case, the object is not used as a prototype. Use <code>.clone</code> instead of <code>.bless</code> if that&#39;s what you mean.</p>

<p>Any named arguments to <code>bless</code> are automatically passed to the <code>CREATE</code> and <code>BUILD</code> routines. If you wish to pass special options to the <code>CREATE</code> routine (such as an alternate representation), call <code>CREATE</code> yourself and then pass the resulting candidate to <code>.bless</code>:</p>

<pre>    my $candidate = $class.CREATE(:repr&#60;P6opaque&#62;);
    $object = $class.bless($candidate, :k1($v1), :k2($v2))</pre>

<p>For the built-in default <code>CREATE</code> method, <code>P6opaque</code> is the default representation. Other possiblilities are <code>P6hash</code>, <code>P5hash</code>, <code>P5array</code>, <code>PyDict</code>, <code>Cstruct</code>, etc.</p>

<p>The <code>bless</code> function automatically calls all appropriate <code>BUILD</code> routines by calling the <code>BUILDALL</code> routine for the current class, which initializes the object in least-derived to most-derived order. <code>DESTROY</code> and <code>DESTROYALL</code> work the same way, only in reverse.</p>

<p>The default <code>BUILD</code> and <code>BUILDALL</code> are inherited from <code>Object</code>, so you need to write initialization routines only if you wish to modify the default behavior. If the name of a named argument begins with a <code>::</code> and corresponds to a class or role being built, the list value of that argument is passed as a list of named arguments to that class or role&#39;s <code>BUILD</code>. (If the value of that argument is a closure instead of a list, that closure will be called to return a list. The argument to that closure will be the name of the class currently being initialized.) In the absence of a class-labeled pair, all the arguments to <code>bless</code> are passed to the <code>BUILD</code>.</p>

<p>You can clone an object, changing some of the attributes:</p>

<a href="#" onclick="return tog_quote(53);">
<div ID="header_shown_53" style="display: none;">
- Hide the snippet from t/oo/clone.t (line 7 ~ line 37) -
</div>
<div ID="header_hidden_53" style="display: block;">
- Show the snippet from t/oo/clone.t (line 7 ~ line 37) -
</div>
</a>
<div ID="hide_53" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S12/&quot;Construction and Initialization&quot; /You can clone an object, changing some of the attributes:/&gt;
class Foo { 
&nbsp; &nbsp; has $.attr; 
&nbsp; &nbsp; method set_attr ($attr) { $.attr = $attr; }
&nbsp; &nbsp; method get_attr () { $.attr }
}

my $a = Foo.new(:attr(13));
isa_ok($a, 'Foo');
is($a.get_attr(), 13, '... got the right attr value');

my $c = $a.clone();
isa_ok($c, 'Foo');
is($c.get_attr(), 13, '... cloned object retained attr value');
my $val;
lives_ok {
&nbsp; &nbsp; $val = $c === $a;
}, &quot;... cloned object isn't identity equal to the original object&quot;;
ok($val.defined &amp;&amp; !$val, &quot;... cloned object isn't identity equal to the original object&quot;);

my $d;
lives_ok {
&nbsp; &nbsp; $d = $a.clone(attr =&gt; 42)
}, '... cloning with supplying a new attribute value';

my $val;
lives_ok {
&nbsp; $val = $d.get_attr()
}, '... getting attr from cloned value';

is($val, 42, '... cloned object has proper attr value');</pre>
</div>


<pre>    $newdog = $olddog.clone(:trick&#60;RollOver&#62;);</pre>

<p>You can write your own <code>BUILD</code> submethod to control initialization. If you name an attribute as a parameter, that attribute is initialized directly, so</p>

<a href="#" onclick="return tog_quote(51);">
<div ID="header_shown_51" style="display: none;">
- Hide the snippet from t/oo/attributes/instance.t (line 128 ~ line 302) -
</div>
<div ID="header_hidden_51" style="display: block;">
- Show the snippet from t/oo/attributes/instance.t (line 128 ~ line 302) -
</div>
</a>
<div ID="hide_51" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S12/&quot;Construction and Initialization&quot; /If you name an attribute as a parameter, that attribute is initialized directly, so/&gt;

class Foo6 {
&nbsp; has $.bar is rw;
&nbsp; has $.baz;
&nbsp; has $!hidden;

&nbsp; submethod BUILD($.bar, $.baz, $!hidden) {}
&nbsp; method get_hidden() { $!hidden }
}

{
&nbsp; &nbsp; my $foo = Foo6.new(bar =&gt; 1, baz =&gt; 2, hidden =&gt; 3);
&nbsp; &nbsp; ok($foo ~~ Foo6, '... our Foo6 instance was created');
&nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; is($foo.bar, &nbsp; &nbsp; &nbsp; &nbsp;1, &quot;getting a public rw attribute (1)&quot; &nbsp;);
&nbsp; &nbsp; is($foo.baz, &nbsp; &nbsp; &nbsp; &nbsp;2, &quot;getting a public ro attribute (2)&quot; &nbsp;);
&nbsp; &nbsp; is($foo.get_hidden, 3, &quot;getting a private ro attribute (3)&quot; );
}

# check that doing something in submethod BUILD works
class Foo6a {
&nbsp; has $.bar is rw;
&nbsp; has $.baz;
&nbsp; has $!hidden;

&nbsp; submethod BUILD ($!hidden, $.bar = 10, $.baz?) {
&nbsp; &nbsp; $.baz = 5;
&nbsp; }
&nbsp; method get_hidden() { $!hidden }
}

{
&nbsp; &nbsp; my $foo = Foo6a.new(bar =&gt; 1, hidden =&gt; 3);
&nbsp; &nbsp; ok($foo ~~ Foo6a, '... our Foo6a instance was created');
&nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; is($foo.bar, &nbsp; &nbsp; &nbsp; &nbsp;1, &quot;getting a public rw attribute (1)&quot; &nbsp;);
&nbsp; &nbsp; is($foo.baz, &nbsp; &nbsp; &nbsp; &nbsp;5, &quot;getting a public rw attribute (2)&quot; &nbsp;);
&nbsp; &nbsp; is($foo.get_hidden, 3, &quot;getting a private ro attribute (3)&quot; );
}

# check that assignment in submethod BUILD works with a bare return, too
class Foo6b {
&nbsp; has $.bar is rw;
&nbsp; has $.baz;

&nbsp; submethod BUILD ($.bar = 10, $.baz?) {
&nbsp; &nbsp; $.baz = 9;
&nbsp; &nbsp; return;
&nbsp; }
}

{
&nbsp; &nbsp; my $foo = Foo6b.new(bar =&gt; 7);
&nbsp; &nbsp; ok($foo ~~ Foo6b, '... our Foo6b instance was created');
&nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; is($foo.bar, &nbsp; &nbsp; &nbsp; &nbsp;7, &quot;getting a public rw attribute (1)&quot; &nbsp;);
&nbsp; &nbsp; is($foo.baz, &nbsp; &nbsp; &nbsp; &nbsp;9, &quot;getting a public rw attribute (2)&quot; &nbsp;);
}

# L&lt;A12/&quot;Default Values&quot;&gt;
ok eval('class Foo7 { has $.attr = 42 }'), &quot;class definition worked&quot;, :todo&lt;feature&gt;;
is eval('Foo7.new.attr'), 42, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&quot;default attribute value (1)&quot;;

# L&lt;A12/&quot;Default Values&quot; /is equivalent to this:/&gt;
ok eval('class Foo8 { has $.attr is build(42) }'),
&nbsp; &quot;class definition using 'is build' worked&quot;, :todo&lt;feature&gt;;
is eval('Foo8.new.attr'), 42, &quot;default attribute value (2)&quot;, :todo&lt;feature&gt;;

# L&lt;A12/&quot;Default Values&quot; /is equivalent to this:/&gt;
ok eval('class Foo9 { has $.attr will build(42) }'),
&nbsp; &quot;class definition using 'will build' worked&quot;, :todo&lt;feature&gt;;
is eval('Foo9.new.attr'), 42, &quot;default attribute value (3)&quot;, :todo&lt;feature&gt;;

my $was_in_supplier = 0;
sub forty_two_supplier() { $was_in_supplier++; 42 }
# XXX: Currently hard parsefail!
#ok eval('class Foo10 { has $.attr = { forty_two_supplier() } }'),
# &nbsp;&quot;class definition using '= {...}' worked&quot;;
flunk &quot;hard parsefail&quot;, :todo&lt;feature&gt;;
is eval('Foo10.new.attr'), 42, &quot;default attribute value (4)&quot;, :todo&lt;feature&gt;;
is &nbsp; &nbsp; &nbsp;$was_in_supplier, 1, &nbsp;&quot;forty_two_supplier() was actually executed (1)&quot;, :todo&lt;feature&gt;;

# The same, but using 'is build {...}'
# XXX: Currently hard parsefail!
#ok eval('class Foo11 { has $.attr is build { forty_two_supplier() } }'),
# &nbsp;&quot;class definition using 'is build {...}' worked&quot;;
flunk &quot;hard parsefail&quot;, :todo&lt;feature&gt;;
is eval('Foo11.new.attr'), 42, &quot;default attribute value (5)&quot;, :todo&lt;feature&gt;;
is &nbsp; &nbsp; &nbsp;$was_in_supplier, 2, &nbsp;&quot;forty_two_supplier() was actually executed (2)&quot;, :todo&lt;feature&gt;;

# The same, but using 'will build {...}'
# XXX: Currently hard parsefail!
#ok eval('class Foo12 { has $.attr will build { forty_two_supplier() } }'),
# &nbsp;&quot;class definition using 'will build {...}' worked&quot;;
flunk &quot;hard parsefail&quot;, :todo&lt;feature&gt;;
is eval('Foo11.new.attr'), 42, &quot;default attribute value (6)&quot;, :todo&lt;feature&gt;;
is &nbsp; &nbsp; &nbsp;$was_in_supplier, 3, &nbsp;&quot;forty_two_supplier() was actually executed (3)&quot;, :todo&lt;feature&gt;;

# check that doing something in submethod BUILD works
class Foo7 {
&nbsp; has $.bar;
&nbsp; has $.baz;

&nbsp; submethod BUILD ($.bar = 5, $baz = 10 ) {
&nbsp; &nbsp; $.baz = 2 * $baz;
&nbsp; }
}

my $foo7 = Foo7.new();
is( $foo7.bar, 5,
&nbsp; &nbsp; 'optional attribute should take default value without passed-in value' );
is( $foo7.baz, 20,
&nbsp; &nbsp; '... optional non-attribute should too' );
$foo7 &nbsp; &nbsp;= Foo7.new( :bar(4), :baz(5) );
is( $foo7.bar, 4,
&nbsp; &nbsp; 'optional attribute should take passed-in value over default' );
is( $foo7.baz, 10,
&nbsp; &nbsp; '... optional non-attribute should too' );


# check that args are passed to BUILD
class Foo8 {
&nbsp; has $.a;
&nbsp; has $.b;
&nbsp; 
&nbsp; submethod BUILD(:$foo, :$bar) {
&nbsp; &nbsp; $.a = $foo;
&nbsp; &nbsp; $.b = $bar;
&nbsp; }
}

{
&nbsp; &nbsp; my $foo = Foo8.new(foo =&gt; 'c', bar =&gt; 'd');
&nbsp; &nbsp; ok($foo.isa(Foo8), '... our Foo8 instance was created');
&nbsp; &nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; is($foo.a, 'c', 'BUILD received $foo');
&nbsp; &nbsp; is($foo.b, 'd', 'BUILD received $bar');
}

# check mixture of positional/named args to BUILD

class Foo9 {
&nbsp; has $.a;
&nbsp; has $.b;
&nbsp; 
&nbsp; submethod BUILD($foo, :$bar) {
&nbsp; &nbsp; $.a = $foo;
&nbsp; &nbsp; $.b = $bar;
&nbsp; }
}

dies_ok({ Foo9.new('pos', bar =&gt; 'd') }, 'cannot pass positional to .new');

# check $self is passed to BUILD
class Foo10 {
&nbsp; has $.a;
&nbsp; has $.b;
&nbsp; has $.c;
&nbsp; 
&nbsp; submethod BUILD(Class $self: :$foo, :$bar) {
&nbsp; &nbsp; $.a = $foo;
&nbsp; &nbsp; $.b = $bar;
&nbsp; &nbsp; $.c = 'y' if $self.isa(Foo10);
&nbsp; }
}

{
&nbsp; &nbsp; my $foo = Foo10.new(foo =&gt; 'c', bar =&gt; 'd');
&nbsp; &nbsp; ok($foo.isa(Foo10), '... our Foo10 instance was created');
&nbsp; &nbsp; 
&nbsp; &nbsp; is($foo.a, 'c', 'BUILD received $foo');
&nbsp; &nbsp; is($foo.b, 'd', 'BUILD received $bar');
&nbsp; &nbsp; is($foo.c, 'y', 'BUILD received $self');
}</pre>
</div>


<pre>    submethod BUILD ($.tail, $!legs) {}</pre>

<p>is equivalent to</p>

<pre>    submethod BUILD ($tail, $legs) {
        $.tail = $tail;
        $!legs = $legs;
    }</pre>

<p>Whether you write your own <code>BUILD</code> or not, at the end of the <code>BUILD</code>, any default attribute values are implicitly copied into any attributes that haven&#39;t otherwise been initialized.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Mutating_methods"
>Mutating methods</a></h1>

<a href="#" onclick="return tog_quote(19);">
<div ID="header_shown_19" style="display: none;">
- Hide the snippet from t/syntax/inplace.t (line 42 ~ line 45) -
</div>
<div ID="header_hidden_19" style="display: block;">
- Show the snippet from t/syntax/inplace.t (line 42 ~ line 45) -
</div>
</a>
<div ID="hide_19" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S12/&quot;Mutating methods&quot;&gt;
my @b = &lt;z a b d e&gt;;
@b .= sort;
is ~@b, &quot;a b d e z&quot;, &quot;inplace sort&quot;;</pre>
</div>


<p>You can call an in-place mutator method like this:</p>

<pre>    @array .= sort;</pre>

<p>If there is a <code>self:sort</code> operator defined, that will be used. Otherwise one will be autogenerated from the ordinary <code>sort</code> operator, on the order of:</p>

<pre>    @array = @array.sort;</pre>

<p>One handy place for an in-place mutator is to call a constructor on a variable of a known type:</p>

<pre>    my Dog $spot .= new(:tail&#60;LONG&#62; :legs&#60;SHORT&#62;);</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Calling_sets_of_methods"
>Calling sets of methods</a></h1>

<p>For any method name, there may be some number of candidate methods that could handle the request: typically, inherited methods or multi variants. The ordinary &#34;dot&#34; operator dispatches to a method in the standard fashion. There are also &#34;dot&#34; variants that call some number of methods with the same name:</p>

<pre>    $object.meth(@args)   # calls one method or dies
    $object.?meth(@args)  # calls method if there is one, otherwise undef
    $object.*meth(@args)  # calls all methods (0 or more)
    $object.+meth(@args)  # calls all methods (1 or more)</pre>

<p>The method name may be quoted when disambiguation is needed:</p>

<pre>    $object.&#34;+meth&#34;(@args)
    $object.&#39;VAR&#39;(@args)</pre>

<p>Any method can defer to the next candidate method in the list by saying <code>next METHOD</code>. Any method can stop the progression by saying <code>last METHOD</code>. The order and selection of the candidates may be specified by arguments to a pseudo-class known as <code>WALK</code>:</p>

<pre>    $object.*WALK[:breadth:omit($?CLASS)]::meth(@args);</pre>

<p>The <code>WALK</code> pseudo-class takes these arguments:</p>

<pre>    :canonical      # canonical dispatch order
    :ascendant      # most-derived first, like destruction order
    :descendant     # least-derived first, like construction order
    :preorder       # like Perl 5 dispatch
    :breadth        # like multi dispatch

    :super              # only immediate parent classes
    :method&#60;name&#62;       # only classes containing method declaration
    :omit(Selector)     # only classes that don&#39;t match selector
    :include(Selector)  # only classes that match selector</pre>

<p>In addition to <code>next METHOD</code>, the special function <code>call</code> dispatches to the next candidate, possibly with a new argument list:</p>

<pre>    call;           # calls with the original arguments
    call();         # calls with no arguments
    call(1,2,3);    # calls with a different set of arguments</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Parallel_dispatch"
>Parallel dispatch</a></h1>

<p>Any of the method call forms may be turned into a hyperoperator by treating the method call as a postfix:</p>

<pre>    @object&#187;.meth(@args)   # calls one method on each
    @object&#187;.?meth(@args)  # calls method if there is one on each
    @object&#187;.*meth(@args)  # calls all methods (0 or more) on each
    @object&#187;.+meth(@args)  # calls all methods (1 or more) on each
    @object&#187;.=meth(@args)  # calls mutator method on each
    @object&#187;!meth(@args)   # calls private method on each</pre>

<p>Hyperoperators treat a junction as a scalar value, so saying:</p>

<pre>    $junction&#187;.meth(@args);</pre>

<p>is just like:</p>

<pre>    $junction.meth(@args);</pre>

<p>To hyperoperate over the values of a junction you have to explicitly pull out the values:</p>

<pre>    $junction.values&#187;.meth(@args);</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Multisubs_and_Multimethods"
>Multisubs and Multimethods</a></h1>

<a href="#" onclick="return tog_quote(26);">
<div ID="header_shown_26" style="display: none;">
- Hide the snippet from t/blocks/multi_named_vs_pos.t (line 8 ~ line 64) -
</div>
<div ID="header_hidden_26" style="display: block;">
- Show the snippet from t/blocks/multi_named_vs_pos.t (line 8 ~ line 64) -
</div>
</a>
<div ID="hide_26" style="display:none; border:1px solid">
<pre style="margin-left: 6px">#L&lt;S12/&quot;Multisubs and Multimethods&quot;&gt;

multi earth (:$me) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {&quot;me $me&quot;};
multi earth (:$him) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{&quot;him $him&quot;};
multi earth (:$me, :$him) &nbsp; &nbsp; &nbsp; &nbsp;{&quot;me $me him $him&quot;};
multi earth (:$me, :$him, :$her) {&quot;me $me him $him her $her&quot;};
multi earth ($me) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{&quot;pos $me&quot;};
multi earth ($me, :$you) &nbsp; &nbsp; &nbsp; &nbsp; {&quot;pos $me you $you&quot;};
multi earth ($me, :$her) &nbsp; &nbsp; &nbsp; &nbsp; {&quot;pos $me her $her&quot;};
multi earth ($me, $you) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{&quot;pos $me pos $you&quot;};
multi earth ($me, $you, :$her) &nbsp; {&quot;pos $me pos $you her $her&quot;};

is( try { earth(me =&gt; 1) }, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'me 1', &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'named me', :todo&lt;feature&gt;);
is( try { earth(him =&gt; 2) }, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;'him 2', &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;'named you', :todo&lt;feature&gt;);
is( try { earth(me =&gt; 1, him =&gt; 2) }, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'me 1 him 2', &nbsp; &nbsp; &nbsp; 'named me, named him', :todo&lt;feature&gt;);
is( try { earth(him =&gt; 2, me =&gt; 1) }, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'me 1 him 2', &nbsp; &nbsp; &nbsp; 'named him, named me', :todo&lt;feature&gt;);
is( try { earth(me =&gt; 1, him =&gt; 2, her =&gt; 3) }, 'me 1 him 2 her 3', 'named me named him named her', :todo&lt;feature&gt;);
is( try { earth(him =&gt; 2, me =&gt; 1, her =&gt; 3) }, 'me 1 him 2 her 3', 'named him named me named her', :todo&lt;feature&gt;);
is( try { earth(her =&gt; 3, me =&gt; 1, him =&gt; 2) }, 'me 1 him 2 her 3', 'named her named me named him', :todo&lt;feature&gt;);
is( try { earth(her =&gt; 3, him =&gt; 2, me =&gt; 1) }, 'me 1 him 2 her 3', 'named her named him named me', :todo&lt;feature&gt;);

is( try { earth('a') }, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;'pos a', &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'pos');
is( try { earth('b', you =&gt; 4) }, &nbsp; &nbsp; &nbsp;'pos b you 4', &nbsp; &nbsp; &nbsp; 'pos, named you', :todo&lt;feature&gt;);
is( try { earth('c', her =&gt; 3) }, &nbsp; &nbsp; &nbsp;'pos c her 3', &nbsp; &nbsp; &nbsp; 'pos, named her', :todo&lt;feature&gt;);
is( try { earth('d', 'e') }, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'pos d pos e', &nbsp; &nbsp; &nbsp; 'pos, pos');
is( try { earth('f', 'g', her =&gt; 3) }, 'pos f pos g her 3', 'pos, pos, named');


# ensure we get the same results when the subroutines are 
# defined in reverse order
#

multi wind ($me, $you, :$her) &nbsp; {&quot;pos $me pos $you her $her&quot;};
multi wind ($me, $you) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{&quot;pos $me pos $you&quot;};
multi wind ($me, :$her) &nbsp; &nbsp; &nbsp; &nbsp; {&quot;pos $me her $her&quot;};
multi wind ($me, :$you) &nbsp; &nbsp; &nbsp; &nbsp; {&quot;pos $me you $you&quot;};
multi wind ($me) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{&quot;pos $me&quot;};
multi wind (:$me, :$him, :$her) {&quot;me $me him $him her $her&quot;};
multi wind (:$me, :$him) &nbsp; &nbsp; &nbsp; &nbsp;{&quot;me $me him $him&quot;};
multi wind (:$him) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{&quot;him $him&quot;};
multi wind (:$me) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {&quot;me $me&quot;};

is( try { wind(me =&gt; 1) }, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'me 1', &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'named me', :todo&lt;feature&gt;);
is( try { wind(him =&gt; 2) }, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;'him 2', &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;'named you', :todo&lt;feature&gt;);
is( try { wind(me =&gt; 1, him =&gt; 2) }, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'me 1 him 2', &nbsp; &nbsp; &nbsp; 'named me, named him', :todo&lt;feature&gt;);
is( try { wind(him =&gt; 2, me =&gt; 1) }, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'me 1 him 2', &nbsp; &nbsp; &nbsp; 'named him, named me', :todo&lt;feature&gt;);
is( try { wind(me =&gt; 1, him =&gt; 2, her =&gt; 3) }, 'me 1 him 2 her 3', 'named me named him named her', :todo&lt;feature&gt;);
is( try { wind(him =&gt; 2, me =&gt; 1, her =&gt; 3) }, 'me 1 him 2 her 3', 'named him named me named her', :todo&lt;feature&gt;);
is( try { wind(her =&gt; 3, me =&gt; 1, him =&gt; 2) }, 'me 1 him 2 her 3', 'named her named me named him', :todo&lt;feature&gt;);
is( try { wind(her =&gt; 3, him =&gt; 2, me =&gt; 1) }, 'me 1 him 2 her 3', 'named her named him named me', :todo&lt;feature&gt;);

is( try { wind('a') }, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;'pos a', &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'pos');
is( try { wind('b', you =&gt; 4) }, &nbsp; &nbsp; &nbsp;'pos b you 4', &nbsp; &nbsp; &nbsp; 'pos, named you', :todo&lt;feature&gt;);
is( try { wind('c', her =&gt; 3) }, &nbsp; &nbsp; &nbsp;'pos c her 3', &nbsp; &nbsp; &nbsp; 'pos, named her', :todo&lt;feature&gt;);
is( try { wind('d', 'e') }, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'pos d pos e', &nbsp; &nbsp; &nbsp; 'pos, pos');
is( try { wind('f', 'g', her =&gt; 3) }, 'pos f pos g her 3', 'pos, pos, named');</pre>
</div>


<a href="#" onclick="return tog_quote(25);">
<div ID="header_shown_25" style="display: none;">
- Hide the snippet from t/blocks/multi_sub.t (line 8 ~ line 50) -
</div>
<div ID="header_hidden_25" style="display: block;">
- Show the snippet from t/blocks/multi_sub.t (line 8 ~ line 50) -
</div>
</a>
<div ID="hide_25" style="display:none; border:1px solid">
<pre style="margin-left: 6px">#L&lt;S12/&quot;Multisubs and Multimethods&quot;&gt;

multi foo (Int $bar) &nbsp; { &quot;Int &quot; &nbsp;~ $bar &nbsp;}
multi foo (Str $bar) &nbsp; { &quot;Str &quot; &nbsp;~ $bar &nbsp;}
multi foo (Num $bar) &nbsp; { &quot;Num &quot; &nbsp;~ $bar &nbsp;}
multi foo (Rat $bar) &nbsp; { &quot;Rat &quot; &nbsp;~ $bar &nbsp;}
multi foo (Bool $bar) &nbsp;{ &quot;Bool &quot; ~ $bar &nbsp;}
multi foo (Rule $bar) &nbsp;{ &quot;Rule &quot; ~ WHAT( $bar ) } # since Rule's don't stringify
multi foo (Sub $bar) &nbsp; { &quot;Sub &quot; ~ $bar() }
multi foo (Array @bar) { &quot;Array &quot; ~ join(', ', @bar) }
multi foo (Hash %bar) &nbsp;{ &quot;Hash &quot; ~ join(', ', %bar.keys) }
multi foo (IO $fh) &nbsp; &nbsp; { &quot;IO&quot; }

is(foo('test'), 'Str test', 'dispatched to the Str sub');
is(foo(2), 'Int 2', 'dispatched to the Int sub');

my $num = '4';
is(foo(+$num), 'Num 4', 'dispatched to the Num sub');
is(foo(1.5), 'Rat 1.5', 'dispatched to the Rat sub');
is(foo(1 == 1), 'Bool 1', 'dispatched to the Bool sub');
is(foo(rx:P5/a/),'Rule Rule','dispatched to the Rule sub', :todo&lt;bug&gt;);
is(foo(sub { 'baz' }), 'Sub baz', 'dispatched to the Sub sub');

my @array = ('foo', 'bar', 'baz');
is(foo(@array), 'Array foo, bar, baz', 'dispatched to the Array sub');

my %hash = ('foo' =&gt; 1, 'bar' =&gt; 2, 'baz' =&gt; 3);
is(foo(%hash), 'Hash foo, bar, baz', 'dispatched to the Hash sub', :todo&lt;bug&gt;);

is(foo($*ERR), 'IO', 'dispatched to the IO sub');

ok(eval('multi sub foo( (Int, Str) $tuple: ) '
&nbsp; &nbsp; ~ '{ &quot;Tuple(2) &quot; ~ $tuple.join(&quot;,&quot;) }'),
&nbsp; &nbsp; &quot;declare sub with tuple argument&quot;, :todo&lt;feature&gt;);

ok(eval('multi sub foo( (Int, Str, Str) $tuple: ) '
&nbsp; &nbsp; ~ '{ &quot;Tuple(3) &quot; ~ $tuple.join(&quot;,&quot;) }'),
&nbsp; &nbsp; &quot;declare multi sub with tuple argument&quot;, :todo&lt;feature&gt;);

is(foo([3, &quot;Four&quot;]), &quot;Tuple(2) 3,Four&quot;, &quot;call tuple multi sub&quot;, :todo&lt;feature&gt;);
is(foo([3, &quot;Four&quot;, &quot;Five&quot;]), &quot;Tuple(3) 3,Four,Five&quot;, &quot;call tuple multi sub&quot;, :todo&lt;feature&gt;);

# You're allowed to omit the &quot;sub&quot; when declaring a multi sub.</pre>
</div>


<a href="#" onclick="return tog_quote(24);">
<div ID="header_shown_24" style="display: none;">
- Hide the snippet from t/oo/methods/multi.t (line 7 ~ line 144) -
</div>
<div ID="header_hidden_24" style="display: block;">
- Show the snippet from t/oo/methods/multi.t (line 7 ~ line 144) -
</div>
</a>
<div ID="hide_24" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S12/&quot;Multisubs and Multimethods&quot;&gt;
# L&lt;S12/&quot;Multi dispatch&quot;&gt;

class Foo {

&nbsp; &nbsp; multi method bar() {
&nbsp; &nbsp; &nbsp; &nbsp; return &quot;Foo.bar() called with no args&quot;;
&nbsp; &nbsp; }

&nbsp; &nbsp; multi method bar(Int $int) {
&nbsp; &nbsp; &nbsp; &nbsp; return &quot;Foo.bar() called with Int : $int&quot;;
&nbsp; &nbsp; }
&nbsp; &nbsp; 
&nbsp; &nbsp; multi method bar(Num $num) {
&nbsp; &nbsp; &nbsp; &nbsp; return &quot;Foo.bar() called with Num : $num&quot;;
&nbsp; &nbsp; } &nbsp; &nbsp;
&nbsp; &nbsp; 
&nbsp; &nbsp; multi method bar(Rat $rat) {
&nbsp; &nbsp; &nbsp; &nbsp; return &quot;Foo.bar() called with Rat : $rat&quot;;
&nbsp; &nbsp; } &nbsp; &nbsp;
&nbsp; &nbsp; 
&nbsp; &nbsp; multi method bar(Str $str) {
&nbsp; &nbsp; &nbsp; &nbsp; return &quot;Foo.bar() called with Str : $str&quot;;
&nbsp; &nbsp; } 
&nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; multi method bar(Bool $bool) {
&nbsp; &nbsp; &nbsp; &nbsp; return &quot;Foo.bar() called with Bool : {$bool.perl}&quot;;
&nbsp; &nbsp; } 

&nbsp; &nbsp; multi method bar(Sub $sub) {
&nbsp; &nbsp; &nbsp; &nbsp; return &quot;Foo.bar() called with Sub : {$sub()}&quot;;
&nbsp; &nbsp; } 

&nbsp; &nbsp; multi method bar(Array @array) {
&nbsp; &nbsp; &nbsp; &nbsp; return &quot;Foo.bar() called with Array : { join(', ', @array) }&quot;;
&nbsp; &nbsp; } 

&nbsp; &nbsp; multi method bar(Hash %hash) {
&nbsp; &nbsp; &nbsp; &nbsp; return &quot;Foo.bar() called with Hash : { join(', ', %hash.keys) }&quot;;
&nbsp; &nbsp; } 
&nbsp; &nbsp; 
&nbsp; &nbsp; multi method bar(IO $fh) {
&nbsp; &nbsp; &nbsp; &nbsp; return &quot;Foo.bar() called with IO&quot;;
&nbsp; &nbsp; } &nbsp; &nbsp; 

}


my $foo = Foo.new();
is($foo.bar(), 'Foo.bar() called with no args', '... multi-method dispatched on no args');

is($foo.bar(5), 'Foo.bar() called with Int : 5', '... multi-method dispatched on Int');
my $num = '4';
is($foo.bar(+$num), 'Foo.bar() called with Num : 4', '... multi-method dispatched on Num');
is($foo.bar(1.5), 'Foo.bar() called with Rat : 1.5', '... multi-method dispatched on Rat');

is($foo.bar(&quot;Hello&quot;), 'Foo.bar() called with Str : Hello', '... multi-method dispatched on Str');
is($foo.bar(1 == 1), 'Foo.bar() called with Bool : \\Bool::True', '... multi-method dispatched on Bool');

is($foo.bar(sub { &quot;my sub&quot; }), 'Foo.bar() called with Sub : my sub', '... multi-method dispatched on Sub');

my @array = ('foo', 'bar', 'baz');
is($foo.bar(@array), 'Foo.bar() called with Array : foo, bar, baz', '... multi-method dispatched on Array');

my %hash = ('foo' =&gt; 1, 'bar' =&gt; 2, 'baz' =&gt; 3);
is($foo.bar(%hash), 'Foo.bar() called with Hash : foo, bar, baz', '... multi-method dispatched on Hash', :todo&lt;bug&gt;);

is($foo.bar($*ERR), 'Foo.bar() called with IO', '... multi-method dispatched on IO');

my $yaml_tests = eval(q{
- 
&nbsp; &nbsp; m2: %h
&nbsp; &nbsp; call: &quot;{a =&gt; 'b'}&quot;
&nbsp; &nbsp; expect: 2
-
&nbsp; &nbsp; m1: %h
&nbsp; &nbsp; m2: @a?
&nbsp; &nbsp; call: &quot;[1,2,3]&quot;
&nbsp; &nbsp; expect: 2
-
&nbsp; &nbsp; m1: @a?
&nbsp; &nbsp; expect: 2 
-
&nbsp; &nbsp; m1: %h
&nbsp; &nbsp; m2: @a
&nbsp; &nbsp; call: &quot;[1,2,3]&quot;
&nbsp; &nbsp; expect: 2
- &nbsp; 
&nbsp; &nbsp; m1: 
&nbsp; &nbsp; m2: @a?
&nbsp; &nbsp; call: &quot;[1,2,3]&quot;
&nbsp; &nbsp; expect: 2

}, :lang&lt;yaml&gt;);

for each($yaml_tests) -&gt; %h {
&nbsp; &nbsp; # I think Perl6 is supposed to offer us a way to just
&nbsp; &nbsp; # pass %h on through...
&nbsp; &nbsp; test_dispatch( 
&nbsp; &nbsp; &nbsp; &nbsp; m1 &nbsp; &nbsp; =&gt; %h&lt;m1&gt;,
&nbsp; &nbsp; &nbsp; &nbsp; m2 &nbsp; &nbsp; =&gt; %h&lt;m2&gt;,
&nbsp; &nbsp; &nbsp; &nbsp; call &nbsp; =&gt; %h&lt;call&gt;,
&nbsp; &nbsp; &nbsp; &nbsp; expect =&gt; %h&lt;expect&gt;,
&nbsp; &nbsp; );
}

sub test_dispatch (
&nbsp; &nbsp; Str $m1, &nbsp;
&nbsp; &nbsp; Str $m2,
&nbsp; &nbsp; Str $call,
&nbsp; &nbsp; Int $expect,
&nbsp; &nbsp; ) {

&nbsp; &nbsp; state $cls = 'Foo000';
&nbsp; &nbsp; $cls++;

&nbsp; &nbsp; my $got = eval qq/
&nbsp; &nbsp; &nbsp; &nbsp; class $cls \{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; multi method a ($m1) \{1\}
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; multi method a ($m2) \{2\}
&nbsp; &nbsp; &nbsp; &nbsp; \};
&nbsp; &nbsp; &nbsp; &nbsp; {$cls}.a($call);
&nbsp; &nbsp; /;

&nbsp; &nbsp; if defined $got {
&nbsp; &nbsp; &nbsp; &nbsp; is($got , $expect, &quot;Arguments ($call) to signatures 1. ($m1) and 2. ($m2) calls $expect&quot;);
&nbsp; &nbsp; }
&nbsp; &nbsp; else {
&nbsp; &nbsp; &nbsp; &nbsp; ok(0, &quot;Failed to compile test! error was was: $!&quot; )
&nbsp; &nbsp; }


}</pre>
</div>


<p>The &#34;long name&#34; of a subroutine or method includes the type signature of its invocant arguments. The &#34;short name&#34; doesn&#39;t. If you put <code>multi</code> in front of any sub (or method) declaration, it allows multiple long names to share a short name, provided all of them are declared <code>multi</code>. A sub (or method) without a <code>multi</code> doesn&#39;t share with anything outside of it or declared prior to it. Only one such sub (or method) can inhabit a given namespace, and it hides any outer subs (or less-derived methods) of the same short name. It may share with multis declared after it in the same scope if declared with the keyword <code>proto</code>, but in that case it functions only as the final tie-breaker if the inner multies can&#39;t decide among themselves what to do. (It may then, of course, decide to redispatch outside of the current scope.) The signature of such a proto-multi also nails down the presumed order and naming of positional parameters, so that any multi call with named arguments in that scope can presume to rearrange those arguments into positional parameters based on that information. (Unrecognized names remain named arguments.)</p>

<p>For subs or methods declared <code>multi</code>, only one instance of the long name can be in any namespace, and it hides any outer (or less-derived) routines with the same long name. It does not hide any routines with the same short name but a different long name. In other words, multis with the same short name can come from several different namespaces provided their long names differ and their short names aren&#39;t hidden by a non-multi declaration in some intermediate scope.</p>

<p>When you call a routine with a particular short name, if there are multiple visible long names, they are all considered candidates. They are sorted into an order according to how close the run-time types of the arguments match up with the declared types of the parameters of each candidate. The best candidate is called, unless there&#39;s a tie, in which case the tied candidates are redispatched using any additional tiebreaker long names (see below).</p>

<p>If a tie still results, only candidates marked with the <code>default</code> trait are considered, and the best matching default routine is used. If there are no default routines, or if the available defaults are also tied, a final tie-breaking proto sub is called, if there is one (see above). Otherwise an exception is thrown.</p>

<p>Ordinarily all the parameters of a multi sub are considered for dispatch. Here&#39;s a declaration for an integer range operator with two parameters in its long name:</p>

<pre>    multi sub infix:&#60;..&#62;(Int $min, Int $max) {...}</pre>

<p>Sometimes you want to have parameters that aren&#39;t counted as part of the long name. For instance, if you want to allow an optional &#34;step&#34; parameter to your range operator, but not consider it for multi dispatch, then put a semicolon instead of a comma before it:</p>

<pre>    multi sub infix:&#60;..&#62;(Int $min, Int $max; Int $by = 1) {...}</pre>

<p>The final semicolon, if any, determines the complete long name of a multi. However, a given multi may advertise multiple long names, some of which are shorter than the complete long name. This is done by putting a semicolon after each advertised long name (replacing the comma, if present). The initial dispatch starts by pretending that the shortest advertised long name is the complete long name (and likewise across the entire set of candidates). Since the shorter long name does not guarantee uniqueness, if that shorter long name is chosen for dispatch, and a tie would be declared for that dispatch, the next longer set of long names may be used to break ties, for those candidates that supply longer names. (As a limiting case, putting a semicolon after every parameter produces dispatch semantics like Common Lisp.)</p>

<p>Within a class, <code>multi submethod</code> is visible to both method-dispatch and subroutine-dispatch. A <code>multi method</code> never participates in the subroutine-dispatch process. It is dispatched just like a normal method, then the tie-breaking rules of the previous paragraph are applied. That is, the shortest long name of a multi method includes <i>only</i> the single invocant, and any additional semicolons may only indicate long names to be used as tiebreakers.</p>

<p>Conjecture: In order to specify dispatch that includes the return type context, it is necessary to place a semicolon after the return type:</p>

<pre>    multi infix:&#60;..&#62;(Int $min, Int $max; Int $by = 1 --&#62; Iterator;) {...}
    multi infix:&#60;..&#62;(Int $min, Int $max; Int $by = 1 --&#62; Selector;) {...}</pre>

<p>Note that such a declaration might have to delay dispatch until the actual desired type is known! (Generally, you might just consider returning a flexible <code>Range</code> object instead of an anonymous partial dispatch that may or may not be resolved at compile time via type inferencing. Therefore return-type tiebreaking need not be supported in 6.0.0 unless some enterprising soul decides to make it work.)</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Method_call_vs._Subroutine_call"
>Method call vs. Subroutine call</a></h2>

<p>The caller indicates whether to make a method call or subroutine call by the call syntax. The &#34;dot&#34; form and the indirect object form default to method calls. Calls with multiple arguments and operators with multiple operands default to subroutine calls.</p>

<p>A function call with a single argument defaults to method calls:</p>

<pre>    close($handle)
    close $handle</pre>

<p>Use a trailing comma if you want to make a subroutine call instead:</p>

<pre>    close($handle,)</pre>

<p>This applies to prefix unary operators as well:</p>

<pre>    !$obj;  # same as $obj.prefix:&#60;!&#62;</pre>

<p>A method call first considers methods (including multi-methods and submethods) from the class hierarchy of <code>$handle</code>, and fails over to the subroutine dispatcher as a last resort only if no method can be found in the class hierarchy.</p>

<p>A subroutine call considers only visible subroutines (including submethods) of that name. There is no fail-over from subroutine to method dispatch.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Multi_dispatch"
>Multi dispatch</a></h1>

<a href="#" onclick="return tog_quote(1);">
<div ID="header_shown_1" style="display: none;">
- Hide the snippet from t/oo/methods/multi.t (line 8 ~ line 144) -
</div>
<div ID="header_hidden_1" style="display: block;">
- Show the snippet from t/oo/methods/multi.t (line 8 ~ line 144) -
</div>
</a>
<div ID="hide_1" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S12/&quot;Multi dispatch&quot;&gt;

class Foo {

&nbsp; &nbsp; multi method bar() {
&nbsp; &nbsp; &nbsp; &nbsp; return &quot;Foo.bar() called with no args&quot;;
&nbsp; &nbsp; }

&nbsp; &nbsp; multi method bar(Int $int) {
&nbsp; &nbsp; &nbsp; &nbsp; return &quot;Foo.bar() called with Int : $int&quot;;
&nbsp; &nbsp; }
&nbsp; &nbsp; 
&nbsp; &nbsp; multi method bar(Num $num) {
&nbsp; &nbsp; &nbsp; &nbsp; return &quot;Foo.bar() called with Num : $num&quot;;
&nbsp; &nbsp; } &nbsp; &nbsp;
&nbsp; &nbsp; 
&nbsp; &nbsp; multi method bar(Rat $rat) {
&nbsp; &nbsp; &nbsp; &nbsp; return &quot;Foo.bar() called with Rat : $rat&quot;;
&nbsp; &nbsp; } &nbsp; &nbsp;
&nbsp; &nbsp; 
&nbsp; &nbsp; multi method bar(Str $str) {
&nbsp; &nbsp; &nbsp; &nbsp; return &quot;Foo.bar() called with Str : $str&quot;;
&nbsp; &nbsp; } 
&nbsp; &nbsp; &nbsp; 
&nbsp; &nbsp; multi method bar(Bool $bool) {
&nbsp; &nbsp; &nbsp; &nbsp; return &quot;Foo.bar() called with Bool : {$bool.perl}&quot;;
&nbsp; &nbsp; } 

&nbsp; &nbsp; multi method bar(Sub $sub) {
&nbsp; &nbsp; &nbsp; &nbsp; return &quot;Foo.bar() called with Sub : {$sub()}&quot;;
&nbsp; &nbsp; } 

&nbsp; &nbsp; multi method bar(Array @array) {
&nbsp; &nbsp; &nbsp; &nbsp; return &quot;Foo.bar() called with Array : { join(', ', @array) }&quot;;
&nbsp; &nbsp; } 

&nbsp; &nbsp; multi method bar(Hash %hash) {
&nbsp; &nbsp; &nbsp; &nbsp; return &quot;Foo.bar() called with Hash : { join(', ', %hash.keys) }&quot;;
&nbsp; &nbsp; } 
&nbsp; &nbsp; 
&nbsp; &nbsp; multi method bar(IO $fh) {
&nbsp; &nbsp; &nbsp; &nbsp; return &quot;Foo.bar() called with IO&quot;;
&nbsp; &nbsp; } &nbsp; &nbsp; 

}


my $foo = Foo.new();
is($foo.bar(), 'Foo.bar() called with no args', '... multi-method dispatched on no args');

is($foo.bar(5), 'Foo.bar() called with Int : 5', '... multi-method dispatched on Int');
my $num = '4';
is($foo.bar(+$num), 'Foo.bar() called with Num : 4', '... multi-method dispatched on Num');
is($foo.bar(1.5), 'Foo.bar() called with Rat : 1.5', '... multi-method dispatched on Rat');

is($foo.bar(&quot;Hello&quot;), 'Foo.bar() called with Str : Hello', '... multi-method dispatched on Str');
is($foo.bar(1 == 1), 'Foo.bar() called with Bool : \\Bool::True', '... multi-method dispatched on Bool');

is($foo.bar(sub { &quot;my sub&quot; }), 'Foo.bar() called with Sub : my sub', '... multi-method dispatched on Sub');

my @array = ('foo', 'bar', 'baz');
is($foo.bar(@array), 'Foo.bar() called with Array : foo, bar, baz', '... multi-method dispatched on Array');

my %hash = ('foo' =&gt; 1, 'bar' =&gt; 2, 'baz' =&gt; 3);
is($foo.bar(%hash), 'Foo.bar() called with Hash : foo, bar, baz', '... multi-method dispatched on Hash', :todo&lt;bug&gt;);

is($foo.bar($*ERR), 'Foo.bar() called with IO', '... multi-method dispatched on IO');

my $yaml_tests = eval(q{
- 
&nbsp; &nbsp; m2: %h
&nbsp; &nbsp; call: &quot;{a =&gt; 'b'}&quot;
&nbsp; &nbsp; expect: 2
-
&nbsp; &nbsp; m1: %h
&nbsp; &nbsp; m2: @a?
&nbsp; &nbsp; call: &quot;[1,2,3]&quot;
&nbsp; &nbsp; expect: 2
-
&nbsp; &nbsp; m1: @a?
&nbsp; &nbsp; expect: 2 
-
&nbsp; &nbsp; m1: %h
&nbsp; &nbsp; m2: @a
&nbsp; &nbsp; call: &quot;[1,2,3]&quot;
&nbsp; &nbsp; expect: 2
- &nbsp; 
&nbsp; &nbsp; m1: 
&nbsp; &nbsp; m2: @a?
&nbsp; &nbsp; call: &quot;[1,2,3]&quot;
&nbsp; &nbsp; expect: 2

}, :lang&lt;yaml&gt;);

for each($yaml_tests) -&gt; %h {
&nbsp; &nbsp; # I think Perl6 is supposed to offer us a way to just
&nbsp; &nbsp; # pass %h on through...
&nbsp; &nbsp; test_dispatch( 
&nbsp; &nbsp; &nbsp; &nbsp; m1 &nbsp; &nbsp; =&gt; %h&lt;m1&gt;,
&nbsp; &nbsp; &nbsp; &nbsp; m2 &nbsp; &nbsp; =&gt; %h&lt;m2&gt;,
&nbsp; &nbsp; &nbsp; &nbsp; call &nbsp; =&gt; %h&lt;call&gt;,
&nbsp; &nbsp; &nbsp; &nbsp; expect =&gt; %h&lt;expect&gt;,
&nbsp; &nbsp; );
}

sub test_dispatch (
&nbsp; &nbsp; Str $m1, &nbsp;
&nbsp; &nbsp; Str $m2,
&nbsp; &nbsp; Str $call,
&nbsp; &nbsp; Int $expect,
&nbsp; &nbsp; ) {

&nbsp; &nbsp; state $cls = 'Foo000';
&nbsp; &nbsp; $cls++;

&nbsp; &nbsp; my $got = eval qq/
&nbsp; &nbsp; &nbsp; &nbsp; class $cls \{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; multi method a ($m1) \{1\}
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; multi method a ($m2) \{2\}
&nbsp; &nbsp; &nbsp; &nbsp; \};
&nbsp; &nbsp; &nbsp; &nbsp; {$cls}.a($call);
&nbsp; &nbsp; /;

&nbsp; &nbsp; if defined $got {
&nbsp; &nbsp; &nbsp; &nbsp; is($got , $expect, &quot;Arguments ($call) to signatures 1. ($m1) and 2. ($m2) calls $expect&quot;);
&nbsp; &nbsp; }
&nbsp; &nbsp; else {
&nbsp; &nbsp; &nbsp; &nbsp; ok(0, &quot;Failed to compile test! error was was: $!&quot; )
&nbsp; &nbsp; }


}</pre>
</div>


<p>Multi submethods work just like multi subs except they are constrained to an exact type match on the invocant.</p>

<p>Perl 6.0.0 is not required to support multiple dispatch on named parameters, only on positional parameters. Note that most builtins will map known named parameters to positional via a <code>proto</code> declaration.</p>

<p>Within a multiple dispatch, <code>next METHOD</code> means to try the next best match, or next best default in case of tie, or the proto sub if there is one.</p>

<p>Attributes are tied to a particular class definition, so a multi method can only directly access the attributes of a class it&#39;s defined within when the invocant is the &#34;self&#34; of that attribute. However, it may call the private attribute accessors from a different class if that other class has indicated that it trusts the class the multi method is defined in:</p>

<pre>    class MyClass {
        trusts Yourclass;
        ...
    }</pre>

<p>The syntax for calling back to <code>MyClass</code> is <code>$obj!MyClass::meth()</code>.</p>

<p>The <code>sub</code> keyword is optional after either <code>multi</code> or <code>proto</code>.</p>

<p>A <code>proto</code> declaration must come before any matching multis, if at all.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Roles"
>Roles</a></h1>

<a href="#" onclick="return tog_quote(17);">
<div ID="header_shown_17" style="display: none;">
- Hide the snippet from t/oo/methods/calling_sets.t (line 4 ~ line 94) -
</div>
<div ID="header_hidden_17" style="display: block;">
- Show the snippet from t/oo/methods/calling_sets.t (line 4 ~ line 94) -
</div>
</a>
<div ID="hide_17" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S12/&quot;Roles&quot;&gt;

# Spec:
# For any method name, there may be some number of candidate methods that could
# handle the request: typically, inherited methods or multi variants. The
# ordinary &quot;dot&quot; operator dispatches to a method in the standard fashion. There
# are also &quot;dot&quot; variants that call some number of methods with the same name:

# &nbsp; &nbsp; &nbsp;$object.?meth &nbsp;# calls method if there is one, otherwise undef
class Parent {
&nbsp; &nbsp; has Int $.cnt is rw;
&nbsp; &nbsp; does plugin_1;
&nbsp; &nbsp; does plugin_2;
&nbsp; &nbsp; method meth {++$.cnt}
}
class Child is Parent {
&nbsp; &nbsp; method meth {++$.cnt}
&nbsp; &nbsp; method child_only {'child_only'}
}

role plugin_1 { multi method init_hook { $.cnt += 2 } }
role plugin_2 { multi method init_hook { $.cnt += 3 } }


{
&nbsp; &nbsp; my $test = q&quot;$object.?meth calls method if there is one&quot;;
&nbsp; &nbsp; my $object = Child.new;
&nbsp; &nbsp; my $result = 1; # default to one to see if value changes to undef
&nbsp; &nbsp; try { $result = $object.?nope };
&nbsp; &nbsp; ok($object.?meth, $test);
&nbsp; &nbsp; is($result,undef, q&quot; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ..undef otherwise &quot;);
&nbsp; &nbsp; # TODO: add test for $object.?$meth (dynamic method) as well
}

{
&nbsp; &nbsp; my $test = q&quot;$object.*meth(@args) &nbsp;# calls all methods (0 or more)&quot;;
&nbsp; &nbsp; my $object = Child.new;
&nbsp; &nbsp; my $result = 1; # default to one to see if value changes to undef
&nbsp; &nbsp; try { $result = $object.*nope };
&nbsp; &nbsp; is($result,undef, q&quot;$test: Case 0 returns undef&quot;);

&nbsp; &nbsp; try { $result = $object.*child_only };
&nbsp; &nbsp; is($result, 'child_only', &quot;$test: Case 1 finds one result&quot;); 

&nbsp; &nbsp; try { $result = $object.*meth };
&nbsp; &nbsp; is($object.cnt, 2, &quot;$test: Case 2 visits both Child and Parent&quot;);

&nbsp; &nbsp; my $meth = 'meth';
&nbsp; &nbsp; $object = Child.new;
&nbsp; &nbsp; try { $result = $object.*$meth };
&nbsp; &nbsp; is($object.cnt, 2, &quot;$test: Case 2 visits both Child and Parent (as dynamic method call)&quot;);

&nbsp; &nbsp; my $meth = 'sqrt'; 
&nbsp; &nbsp; my $ans = 0;
&nbsp; &nbsp; try { $ans = 4.*$meth };
&nbsp; &nbsp; is($ans, 2, q&quot;$obj.*$meth works built-in methods like 'sqrt'&quot;);

}

{
&nbsp; &nbsp; # We should not only look in parent classes, but for matching 
&nbsp; &nbsp; # multi methods in parent classes!
&nbsp; &nbsp; my $test = q&quot;$object.*meth(@args) &nbsp;# calls all methods (0 or more) works on multi axis, too&quot;;
&nbsp; &nbsp; my $object = Child.new;
&nbsp; &nbsp; my $got = 0;
&nbsp; &nbsp; my $meth = 'init_hook';
&nbsp; &nbsp; try { $got = $object.*$meth };
&nbsp; &nbsp; is($got, 5, $test, :todo&lt;feature&gt;);
}

{
&nbsp; &nbsp; my $test = q&quot;$object.+meth(@args) &nbsp;# calls all methods (1 or more)&quot;;
&nbsp; &nbsp; my $object = Child.new;
&nbsp; &nbsp; my $result = 1; # default to one to see if value changes to undef
&nbsp; &nbsp; try { $result = $object.+nope };
&nbsp; &nbsp; ok($!, q&quot;$test: Case 0 dies&quot;);

&nbsp; &nbsp; try { $result = $object.+child_only };
&nbsp; &nbsp; is($result, 'child_only', &quot;$test: Case 1 fines one result&quot;); 

&nbsp; &nbsp; try { $result = $object.+meth };
&nbsp; &nbsp; is($object.cnt, 2, &quot;$test: Case 2 visits both Child and Parent&quot;);

&nbsp; &nbsp; # TODO: add test for $object.+$meth (dynamic method) as well

}

ok(0,q'STUB: $object.*WALK[:breadth:omit($?CLASS)]::meth(@args);', :todo&lt;feature&gt; );

ok(0, &quot;STUB: there is more Calling Sets functionality which needs tests&quot;, :todo&lt;feature&gt;);
# vim: ft=perl6</pre>
</div>


<a href="#" onclick="return tog_quote(16);">
<div ID="header_shown_16" style="display: none;">
- Hide the snippet from t/oo/roles/anonymous.t (line 7 ~ line 42) -
</div>
<div ID="header_hidden_16" style="display: block;">
- Show the snippet from t/oo/roles/anonymous.t (line 7 ~ line 42) -
</div>
</a>
<div ID="hide_16" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S12/&quot;Roles&quot;&gt;
{
&nbsp; my $a = 3;
&nbsp; is $a, 3, &quot;basic sanity&quot;;
&nbsp; ok eval('$a does role { has $.cool = &quot;yeah&quot; }'), &quot;anonymous role mixin&quot;, :todo&lt;feature&gt;;
&nbsp; is $a, 3, &quot;still basic sanity&quot;;
&nbsp; is eval('$a.cool'), &quot;yeah&quot;, &quot;anonymous role gave us an attribute&quot;, :todo&lt;feature&gt;;
}

# The same, but we story the anonymous role in a variable
{
&nbsp; my $a = 3;
&nbsp; is $a, 3, &quot;basic sanity&quot;;
&nbsp; my $role;
&nbsp; ok eval('$role = role { has $.cool = &quot;yeah&quot; }'), &quot;anonymous role definition&quot;, :todo&lt;feature&gt;;
&nbsp; ok eval('$a does $role'), &quot;anonymous role variable mixin&quot;;
&nbsp; is $a, 3, &quot;still basic sanity&quot;;
&nbsp; is eval('$a.cool'), &quot;yeah&quot;, &quot;anonymous role variable gave us an attribute&quot;, :todo&lt;feature&gt;;
}

# Guarantee roles are really first-class-entities:
{
&nbsp; ok eval('
&nbsp; &nbsp; sub role_generator(Str $val) {
&nbsp; &nbsp; &nbsp; return role {
&nbsp; &nbsp; &nbsp; &nbsp; has $.cool = $val;
&nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; '), &quot;role generating functions defined&quot;, :todo&lt;feature&gt;;

&nbsp; my $a = 3;
&nbsp; is $a, 3, &quot;basic sanity&quot;;
&nbsp; ok eval('$a does role_generator(&quot;hi&quot;)'), &quot;role generating function mixin&quot;;
&nbsp; is $a, 3, &quot;still basic sanity&quot;;
&nbsp; is eval('$a.cool'), &quot;hi&quot;, &quot;role generating function gave us an attribute&quot;, :todo&lt;feature&gt;;
}</pre>
</div>


<a href="#" onclick="return tog_quote(15);">
<div ID="header_shown_15" style="display: none;">
- Hide the snippet from t/oo/roles/basic.t (line 13 ~ line 32) -
</div>
<div ID="header_hidden_15" style="display: block;">
- Show the snippet from t/oo/roles/basic.t (line 13 ~ line 32) -
</div>
</a>
<div ID="hide_15" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S12/&quot;Roles&quot;&gt;
# Basic definition
role Foo {}
class Bar does Foo;

ok Foo.HOW, &quot;definition of a role worked&quot;;
ok Bar.HOW, &quot;definition of a class which does a role worked&quot;;

# Smartmatch and .HOW.does
my $bar = Bar.new();
ok ($bar ~~ Bar), &nbsp; &nbsp; &nbsp; &nbsp; '... smartmatch our $bar to the Bar class';
ok ($bar.HOW.does(Foo)), '.HOW.does said our $bar does Foo';
ok ($bar ~~ Foo), &nbsp; &nbsp; &nbsp; &nbsp; 'smartmatch said our $bar does Foo';

# Mixing a Role into an Object using imperative C&lt;does&gt;
my $baz = 3;
ok eval('$baz does Foo'), &nbsp; &nbsp; &nbsp; 'mixing in our Foo role into $baz worked';
ok eval('$baz.HOW.does(Foo)'), '.HOW.does said our $baz now does Foo', :todo&lt;feature&gt;;
ok eval('$baz ~~ Baz'), &nbsp; &nbsp; &nbsp; &nbsp; 'smartmatch said our $baz now does Foo', :todo&lt;feature&gt;;</pre>
</div>


<a href="#" onclick="return tog_quote(11);">
<div ID="header_shown_11" style="display: none;">
- Hide the snippet from t/oo/roles/conflicts.t (line 13 ~ line 42) -
</div>
<div ID="header_hidden_11" style="display: block;">
- Show the snippet from t/oo/roles/conflicts.t (line 13 ~ line 42) -
</div>
</a>
<div ID="hide_11" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S12/&quot;Roles&quot;&gt;
my ($was_in_sentry_shake, $was_in_pet_shake, $was_in_general_shake) = (0) xx 3;
role Sentry { method shake() { $was_in_sentry_shake++; &quot;A&quot; } }
role Pet &nbsp; &nbsp;{ method shake() { $was_in_pet_shake++; &nbsp; &nbsp;&quot;B&quot; } }

class General {
does Sentry;
does Pet;

method shake(Str $what) {
&nbsp; &nbsp; $was_in_general_shake++;
&nbsp; &nbsp; given $what {
&nbsp; &nbsp; &nbsp; &nbsp; when &quot;sentry&quot; { return self.Sentry::shake() }
&nbsp; &nbsp; &nbsp; &nbsp; when &quot;pet&quot; &nbsp; &nbsp;{ return self.Pet::shake() &nbsp; &nbsp;}
&nbsp; &nbsp; }
}
}
ok(Pet.new, &quot;role and class definition worked&quot;);

my $a;
ok(($a = General.new()), &nbsp; &nbsp; &nbsp;&quot;basic class instantiation works&quot;);
is $a.shake(&quot;sentry&quot;), &quot;A&quot;, &quot;conflict resolution works (1-1)&quot;;
is &nbsp; &nbsp; &nbsp;$was_in_general_shake, &nbsp;1, &quot;conflict resolution works (1-2)&quot;;
is &nbsp; &nbsp; &nbsp;$was_in_sentry_shake, &nbsp; 1, &quot;conflict resolution works (1-3)&quot;;
# As usual, is instead of todo_is to avoid unexpected suceedings.
is &nbsp; &nbsp; &nbsp;$was_in_pet_shake, &nbsp; &nbsp; &nbsp;0, &quot;conflict resolution works (1-4)&quot;;
is $a.shake(&quot;pet&quot;), &nbsp; &nbsp;&quot;B&quot;, &quot;conflict resolution works (2-1)&quot;;
is &nbsp; &nbsp; &nbsp;$was_in_general_shake, &nbsp;2, &quot;conflict resolution works (2-2)&quot;;
is &nbsp; &nbsp; &nbsp;$was_in_sentry_shake, &nbsp; 1, &quot;conflict resolution works (2-3)&quot;;
is &nbsp; &nbsp; &nbsp;$was_in_pet_shake, &nbsp; &nbsp; &nbsp;1, &quot;conflict resolution works (2-4)&quot;;</pre>
</div>


<p>Classes are primarily in charge of object management, and only secondarily in charge of software reuse. In Perl 6, roles take over the job of managing software reuse. Depending on how you care to look at it, a role is like a partial class, or an interface with default implementation, or a set of generic methods and their associated data, or a class closed at compile time.</p>

<p>Roles may be composed into a class at compile time, in which case you get automatic detection of conflicting methods. A role may also be mixed into a class or object at run time to produce an anonymous derived class with extra capabilities, but in this case conflicting methods are overridden by the new role silently. In either case, a class is necessary for instantiation--a role may not be directly instantiated.</p>

<p>A role is declared like a class, but with a <code>role</code> keyword:</p>

<a href="#" onclick="return tog_quote(14);">
<div ID="header_shown_14" style="display: none;">
- Hide the snippet from t/oo/roles/basic.t (line 33 ~ line 40) -
</div>
<div ID="header_hidden_14" style="display: block;">
- Show the snippet from t/oo/roles/basic.t (line 33 ~ line 40) -
</div>
</a>
<div ID="hide_14" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S12/&quot;Roles&quot; /but with a role keyword:/&gt;
# Roles may have methods
ok eval('role A { method say_hello(Str $to) { &quot;Hello, $to&quot; } }'),
&nbsp; &quot;definition of a role with a method worked&quot;, :todo&lt;feature&gt;;
ok eval('(my Foo $a does A) .= new()'), 'mixing A into $a worked';
is eval('$a.say_hello(&quot;Ingo&quot;)'), &quot;Ingo&quot;,
&nbsp; 'our $a &quot;inherited&quot; the .say_hello method of A', :todo&lt;feature&gt;;</pre>
</div>


<pre>    role Pet {
        method feed ($food) {
            $food.open_can;
            $food.put_in_bowl;
            self.some_other_method;
        }
    }</pre>

<p>A role may not inherit from a class, but may be composed of other roles. However, this &#34;crony&#34; composition is not evaluated until class composition time. This means that if two roles bring in the same crony, there&#39;s no conflict--it&#39;s just as if the class pulled in the crony role itself and the respective roles didn&#39;t. A role may never conflict with itself regardless of its method of incorporation. A role that brings in two conflicting crony roles *may* resolve them as if it were a class. This solution is accepted by the class unless the class supplies its own solution. If two different roles resolve the same crony conflict two different ways, those roles are themselves in conflict and must be resolved by a &#34;more derived&#34; role or the class.</p>

<p>A role doesn&#39;t know its own type until it is composed into a class. Any mention of its main type (such as <code>::?CLASS</code>) is generic, as is any reference to <code>self</code> or the type of the invocant. You can use a role name as a type, but only for constraints, not for declaring actual objects. (However, if you use a role as if it were a class, an anonymous class is generated that composes the role, which provides a way to force a role to test its crony composition for infelicities.)</p>

<p>A role&#39;s main type is generic by default, but you can also parameterize other types explicitly using type parameters:</p>

<a href="#" onclick="return tog_quote(9);">
<div ID="header_shown_9" style="display: none;">
- Hide the snippet from t/oo/roles/parameterized.t (line 49 ~ line 101) -
</div>
<div ID="header_hidden_9" style="display: block;">
- Show the snippet from t/oo/roles/parameterized.t (line 49 ~ line 101) -
</div>
</a>
<div ID="hide_9" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S12/&quot;Roles&quot; /A role's main type is generic by default/&gt;
ok eval('
&nbsp; role InitialAttribType[^vartype:] {
&nbsp; &nbsp; method hi(vartype $foo) { 42 }
&nbsp; }
'), &quot;parameterized role definition (2)&quot;, :todo&lt;feature&gt;;
my $c;
ok eval('$c does InitialAttribType[Code]'),
&nbsp; &quot;imperative does to apply a parametrized role (3)&quot;, :todo&lt;feature&gt;;
ok eval('$c.HOW.does(InitialAttribType)'),
&nbsp; &quot;.HOW.does gives correct information (3-1)&quot;, :todo&lt;feature&gt;;
ok eval('$c.HOW.does(InitialAttribType[Code])'),
&nbsp; &quot;.HOW.does gives correct information (3-2)&quot;, :todo&lt;feature&gt;;
is try { $c.hi(sub {}) }, 42,
&nbsp; &quot;type information was processed correctly (1)&quot;, :todo&lt;feature&gt;;
dies_ok { $c.hi(&quot;not a code object&quot;) },
&nbsp; &quot;type information was processed correctly (2)&quot;;




# Parameterized role using both a parameter which will add to the &quot;long name&quot;
# of the role and one which doesn't.
# (Explanation: This one is easier. The two attributes $.type and $.name will
# be predefined (using the role parameterization). The $type adds to the long
# name of the role, $name does not. Such:
# &nbsp; my $a does InitialAttribBoth[&quot;foo&quot;, &quot;bar&quot;];
# &nbsp; my $b does InitialAttribBoth[&quot;foo&quot;, &quot;grtz&quot;];
# &nbsp; $a ~~ InitialAttribBoth &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;==&gt; true
# &nbsp; $b ~~ InitialAttribBoth &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;==&gt; true
# &nbsp; $a ~~ InitialAttribBoth[&quot;foo&quot;] &nbsp; &nbsp; &nbsp; &nbsp; ==&gt; true
# &nbsp; $b ~~ InitialAttribBoth[&quot;foo&quot;] &nbsp; &nbsp; &nbsp; &nbsp; ==&gt; true
# &nbsp; $a ~~ InitialAttribBoth[&quot;foo&quot;, &quot;bar&quot;] &nbsp;==&gt; false
# &nbsp; $b ~~ InitialAttribBoth[&quot;foo&quot;, &quot;grtz&quot;] ==&gt; false
# Heavy stuff, eh?)
ok eval('
&nbsp; role InitialAttribBoth[Str $type: Str $name] {
&nbsp; &nbsp; has $.type = $type;
&nbsp; &nbsp; has $.name = $name;
&nbsp; }
&nbsp; 1
'), &quot;parameterized role definition (3)&quot;, :todo&lt;feature&gt;;
my $d;
ok eval('$d does InitialAttribBoth[&quot;type1&quot;, &quot;name1&quot;]'),
&nbsp; &quot;imperative does to apply a parametrized role (4)&quot;, :todo&lt;feature&gt;;
ok eval('$c.HOW.does(InitialAttribType)'),
&nbsp; &quot;.HOW.does gives correct information (4-1)&quot;, :todo&lt;feature&gt;;
ok eval('$d.HOW.does(InitialAttribType[&quot;type1&quot;])'),
&nbsp; &quot;.HOW.does gives correct information (4-2)&quot;, :todo&lt;feature&gt;;
ok eval('!$d.HOW.does(InitialAttribType[&quot;type1&quot;, &quot;name1&quot;])'),
&nbsp; &quot;.HOW.does gives correct information (4-3)&quot;;
is try { $d.type }, &quot;type1&quot;, &quot;.type works correctly&quot;, :todo&lt;feature&gt;;
is try { $d.name }, &quot;name1&quot;, &quot;.name works correctly&quot;, :todo&lt;feature&gt;;</pre>
</div>


<pre>    role Pet[::Petfood = TableScraps] {
        method feed (Petfood $food) {...}
    }</pre>

<p>(Note that in this case you must not use ::Petfood in the inner declaration, or it would rebind the type to type of the actual food parameter.)</p>

<p>If a role merely declares methods without defining them, it degenerates to an interface:</p>

<pre>    role Pet {
        method feed ($food) {...}
        method groom () {...}
        method scratch (:$where) {...}
    }</pre>

<p>Note that, while these methods must become available at class composition time, they might be supplied by any of: another role, the class itself, or some superclass. We know the methods that are coming from the other roles or the class, but we don&#39;t necessarily know the complete set of methods supplied by our super classes if they are open or rely on wildcard delegation. However, the class composer is allowed to assume that only currently declared superclass methods or non-wildcard methods are going to be available. A stub can always be installed somewhere to &#34;supply&#34; a missing method&#39;s declaration.</p>

<p>Roles may have attributes:</p>

<a href="#" onclick="return tog_quote(13);">
<div ID="header_shown_13" style="display: none;">
- Hide the snippet from t/oo/roles/basic.t (line 41 ~ line 47) -
</div>
<div ID="header_hidden_13" style="display: block;">
- Show the snippet from t/oo/roles/basic.t (line 41 ~ line 47) -
</div>
</a>
<div ID="hide_13" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S12/&quot;Roles&quot; /Roles may have attributes:/&gt;
ok eval('role B { has $.attr = 42 is rw }'),
&nbsp; &quot;definition of a role with an attribute worked&quot;, :todo&lt;feature&gt;;
ok eval('my Foo $b does B .= new()'), 'mixing B into $b worked';
is eval('$b.attr'), 42, &nbsp; &nbsp; &nbsp;'our $b &quot;inherited&quot; the $.attr attribute of B (1)', :todo&lt;feature&gt;;
is eval('$b.attr = 23'), 23, 'our $b &quot;inherited&quot; the $.attr attribute of B (2)', :todo&lt;feature&gt;;</pre>
</div>


<pre>    role Pet {
        has $.collar = { Collar.new(Tag.new) };
        method id () { return $.collar.tag }
        method lose_collar () { undefine $.collar }
    }</pre>

<p>If you want to parameterize the initial value of a role attribute, be sure to put a semicolon if you don&#39;t want the parameter to be considered part of the long name:</p>

<a href="#" onclick="return tog_quote(10);">
<div ID="header_shown_10" style="display: none;">
- Hide the snippet from t/oo/roles/parameterized.t (line 13 ~ line 48) -
</div>
<div ID="header_hidden_10" style="display: block;">
- Show the snippet from t/oo/roles/parameterized.t (line 13 ~ line 48) -
</div>
</a>
<div ID="hide_10" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S12/&quot;Roles&quot; /to be considered part of the long name:/&gt;
# L&lt;A12/&quot;Encapsulated Attributes&quot; /to be considered part of the long name:/&gt;
ok eval('
&nbsp; role InitialAttribVal[: $val] {
&nbsp; &nbsp; has $.attr = $val;
&nbsp; }
&nbsp; 1
'), &quot;parameterized role definition (1)&quot;, :todo&lt;feature&gt;;

my $a;
ok eval('$a does InitialAttribVal[42]'),
&nbsp; &quot;imperative does to apply a parametrized role (1)&quot;, :todo&lt;feature&gt;;
is try { $a.attr }, 42,
&nbsp; &quot;attribute was initialized correctly (1)&quot;, :todo&lt;feature&gt;;
# L&lt;A12/&quot;Encapsulated Attributes&quot; /In which case all of these are true:/&gt;
ok eval('$a.HOW.does(InitialAttribVal)'),
&nbsp; &quot;.HOW.does gives correct information (1-1)&quot;, :todo&lt;feature&gt;;
# L&lt;A12/&quot;Encapsulated Attributes&quot; /but this is false:/&gt;
ok eval('!$a.HOW.does(InitialAttribVal[42])'),
&nbsp; &quot;.HOW.does gives correct information (1-2)&quot;, :todo&lt;feature&gt;;

my $b;
ok eval('$a does InitialAttribVal[23]'),
&nbsp; &quot;imperative does to apply a parametrized role (2)&quot;, :todo&lt;feature&gt;;
is try { $a.attr }, 23,
&nbsp; &quot;attribute was initialized correctly (2)&quot;, :todo&lt;feature&gt;;
# L&lt;A12/&quot;Encapsulated Attributes&quot; /In which case all of these are true:/&gt;
ok eval('$a.HOW.does(InitialAttribVal)'),
&nbsp; &quot;.HOW.does gives correct information (2-1)&quot;, :todo&lt;feature&gt;;
# L&lt;A12/&quot;Encapsulated Attributes&quot; /but this is false:/&gt;
ok eval('!$a.HOW.does(InitialAttribVal[23])'),
&nbsp; &quot;.HOW.does gives correct information (2-2)&quot;, :todo&lt;feature&gt;;



# L&lt;A12/&quot;Parametric types&quot; /but you can also parameterize other types explicitly:/&gt;</pre>
</div>


<pre>    role Pet[::ID; $tag] {
        has ID $.collar .= new($tag);
    }</pre>

<p>Unlike in a class, within a role the <code>has</code> declarator distinguishes private attribute declared with exclamation from those without. To declare a private attribute that is shared by the class, use the exclamationless notation in the declaration:</p>

<pre>    has Nose $sniffer .= new();</pre>

<p>A completely private role attribute may be declared like this:</p>

<pre>    has $!spleen;</pre>

<p>The name of such a private attribute is always considered lexically scoped. If a role declares private lexical items, those items are private to the role due to the nature of lexical scoping. Accessors to such items may be exported to the class, but this is not the default. In particular, a role may say</p>

<pre>    trusts ::?Class;</pre>

<p>to allow <code>self!attr()</code> access to the role&#39;s <code>$!attr</code> variables with the class or from other roles composed into the class. Conflicts between private accessor are also caught at composition time, but of course need not consider super classes, since no-one outside the current class (or a trusted class) can call a private accessor at all. (Private accessors are never virtual, and must be package qualified if called from a trusted scope other than our own. That is, it&#39;s either <code>self!attr()</code> or <code>$obj!TrustsMe::attr().</code>)</p>

<p>Outside of the <code>has</code> declaration, the exclamation mark is again optional, as with an ordinary private attribute in the class.</p>

<p>A role may also distinguish a shared method</p>

<pre>    method foo ...</pre>

<p>from a nonshared private method:</p>

<pre>    my method !foo ...</pre>

<p>Generally you&#39;d just use a lexically scoped sub, though.</p>

<pre>    my sub foo ...</pre>

<p>[Conjectural: To put a private sub into the class, say</p>

<pre>    our sub !foo ...</pre>

<p>]</p>

<p>A role can abstract the decision to delegate:</p>

<pre>    role Pet {
        has $groomer handles &#60;bathe groom trim&#62; = hire_groomer();
    }</pre>

<p>Note that this puts the three methods into the class as well as <code>$groomer</code>. In contrast, &#34;<code>has $!groomer</code>&#34; would only put the three methods.</p>

<p>A role is allowed to declare an additional inheritance for its class when that is considered an implementation detail:</p>

<pre>    role Pet {
        is Friend;
    }</pre>

<p>A class incorporates a role with the verb &#34;does&#34;, like this:</p>

<pre>    class Dog is Mammal does Pet does Sentry {...}</pre>

<p>or equivalently, within the body of the class closure:</p>

<pre>    class Dog {
        is Mammal;
        does Pet;
        does Sentry;
        ...
    }</pre>

<p>There is no ordering dependency among the roles.</p>

<p>A class&#39;s explicit method definition hides any role definition of the same name. A role method in turn hides any methods inherited from other classes.</p>

<p>If there are no method name conflicts between roles (or with the class), then each role&#39;s methods can be installed in the class. If, however, two roles try to introduce a method of the same name the composition of the class fails.</p>

<p>There are several ways to solve method conflicts. The first is simply to write a class method that overrides the conflicting role methods, perhaps figuring out which role method to call.</p>

<p>Alternately, if the role&#39;s methods are declared <code>multi</code>, they can be disambiguated based on their long name. If the roles forget to declare them as multi, you can force a multi on the roles&#39; methods by installing a multi stub in the class being constructed:</p>

<pre>    multi method shake {...}</pre>

<p>A proto method also works, and will be called if the multi fails:</p>

<pre>    proto method shake { warn &#34;They couldn&#39;t decide&#34; }</pre>

<p>Conjectural: If the original invocant is in a variable that is constrained to be of one role or another, then that type could be used to dispatch to the correct role&#39;s method in cases where they can&#39;t be distinguished by differences in the actual argument types:</p>

<pre>    class DogTree {
        does DogBark;
        does TreeBark;
        multi method bark {...}
        ...
    }

    my DogBark $dog = new DogTree;
    my TreeBark $tree = new DogTree;

    $dog.bark();        # picks Dog role&#39;s bark method
    $tree.bark();       # picks Tree role&#39;s bark method</pre>

<p>Run-time mixins are done with <code>does</code> and <code>but</code>. The <code>does</code> binary operator is a mutator that derives a new anonymous class (if necessary) and binds the object to it:</p>

<pre>    $fido does Sentry</pre>

<p>The <code>does</code> operator returns the object so you can nest mixins:</p>

<pre>    $fido does Sentry does Tricks does TailChasing does Scratch;</pre>

<p>Unlike the compile-time role composition, each of these layers on a new mixin with a new level of inheritance, creating a new anonymous class for dear old Fido, so that a <code>.chase</code> method from <code>TailChasing</code> hides a <code>.chase</code> method from <code>Sentry</code>.</p>

<p>You can also mixin a precomposed set of roles:</p>

<pre>    $fido does Sentry | Tricks | TailChasing | Scratch;</pre>

<p>This will level the playing field for collisions among the new set of roles, and guarantees the creation of no more than one more anonymous class.</p>

<p>A role still can&#39;t conflict with itself, but it can hide its previous methods in the parent class, and the calculation of what conflicts is done again for the set of roles being mixed in.</p>

<p>A role applied with <code>does</code> may be parameterized with an initializer in parentheses, but only if the role supplies exactly one attribute to the mixin class:</p>

<pre>    $fido does Wag($tail);
    $line does taint($istainted);</pre>

<p>The <code>but</code> operator creates a copy and works on that. It also knows how to generalize a particular enumerated value to its role. So</p>

<a href="#" onclick="return tog_quote(18);">
<div ID="header_shown_18" style="display: none;">
- Hide the snippet from t/oo/syntax-but.t (line 65 ~ line 76) -
</div>
<div ID="header_hidden_18" style="display: block;">
- Show the snippet from t/oo/syntax-but.t (line 65 ~ line 76) -
</div>
</a>
<div ID="hide_18" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S12/Roles/generalize a particular enumerated value to its role.&gt;
{
&nbsp; my $true_zero is context;
&nbsp; ok eval_elsewhere('$+true_zero = 0 but True; 1'), &quot;0 but True syntax evaluates&quot;, :todo&lt;bug&gt;;
&nbsp; ok ($true_zero == 0), &quot;0 but True is numerically equal to 0&quot;;
&nbsp; ok ?($true_zero), &quot;0 but True is true&quot;, :todo&lt;bug&gt;;
&nbsp; # TimToady++ says I can test False as well
&nbsp; my $false_positive is context;
&nbsp; ok eval_elsewhere('$+false_positive = 3 but False; 1'), &quot;3 but False syntax evaluates&quot;, :todo&lt;bug&gt;;
&nbsp; ok ($false_positive == 3), &quot;3 but False is numerically equal to 3&quot;, :todo&lt;bug&gt;;
&nbsp; ok !($false_positive), &quot;3 but False is false&quot;;
}</pre>
</div>


<a href="#" onclick="return tog_quote(12);">
<div ID="header_shown_12" style="display: none;">
- Hide the snippet from t/oo/roles/basic.t (line 48 ~ line 54) -
</div>
<div ID="header_hidden_12" style="display: block;">
- Show the snippet from t/oo/roles/basic.t (line 48 ~ line 54) -
</div>
</a>
<div ID="hide_12" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S12/&quot;Roles&quot; /operator creates a copy and works on that./&gt;
# As usual, ok instead of todo_ok to avoid unexpected succeedings.
ok eval('my Foo $c .= new()'), &nbsp; &nbsp; &nbsp; &nbsp;'creating a Foo worked';
ok &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !eval('$c ~~ B'), &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;'$c does not B';
ok eval('my $d = $c but B'), &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;'mixing in a Role via but worked', :todo&lt;feature&gt;;
ok &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; !eval('$c ~~ B'), &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;'$c still does not B...';
ok eval('$d ~~ B'), &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; '...but $d does B', :todo&lt;feature&gt;;</pre>
</div>


<pre>    0 but True</pre>

<p>is short for something like:</p>

<pre>    0 but bool::True</pre>

<p>A property is defined by a role like this:</p>

<pre>    role SomeRole {
        has SomeType $.prop is rw = 1;
    }</pre>

<p>You can declare a property with</p>

<pre>    my int property answer;</pre>

<p>and that declares a role whose name is the same as the accessor:</p>

<pre>    my role answer {
        has int $.answer is rw;
    }</pre>

<p>Then you can say</p>

<pre>    $a = 0 but answer(42)</pre>

<p>Note that the parenthesized form is <i>not</i> a subroutine or method call. It&#39;s just special initializing syntax for roles that contain a single property. The above really means something like:</p>

<pre>    $a = ($anonymous = 0) does answer(42);</pre>

<p>which really means:</p>

<pre>    (($anonymous = 0) does answer).answer = 42;
    $a = $anonymous;</pre>

<p>Which is why there&#39;s a <code>but</code> operator.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Traits"
>Traits</a></h1>

<a href="#" onclick="return tog_quote(22);">
<div ID="header_shown_22" style="display: none;">
- Hide the snippet from t/oo/traits/basic.t (line 13 ~ line 45) -
</div>
<div ID="header_hidden_22" style="display: block;">
- Show the snippet from t/oo/traits/basic.t (line 13 ~ line 45) -
</div>
</a>
<div ID="hide_22" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S12/Traits&gt;
# Basic definition
my $was_in_any_sub &nbsp; = 0;
my $was_in_class_sub = 0;
role cool {
&nbsp; has $.is_cool = 42;

&nbsp; multi sub trait_auxiliary:&lt;is&gt;(cool $trait, Any $container:) {
&nbsp; &nbsp; $was_in_any_sub++;
&nbsp; &nbsp; $container does cool;
&nbsp; }

&nbsp; multi sub trait_auxiliary:&lt;is&gt;(cool $trait, Class $container:) {
&nbsp; &nbsp; $was_in_class_sub++;
&nbsp; &nbsp; $container does cool;
&nbsp; }
}
ok(::cool.HOW, &quot;role definition worked&quot;);

ok eval('my $a is cool; 1'), 'mixing in our role into a scalar via &quot;is&quot; worked';
is $was_in_any_sub, 1, 'trait_auxiliary:is was called on container', :todo&lt;feature&gt;;
is eval('$a.is_cool'), 'our var &quot;inherited&quot; an attribute', :todo&lt;feature&gt;;

my $b;
class B is cool;
ok(::B.HOW, 'mixing in our role into a class via &quot;is&quot; worked');
is $was_in_class_sub, 1, 'trait_auxiliary:is was called on class', :todo&lt;feature&gt;;
$b = B.new;
ok($b, 'creating an instance worked');
is($b.is_cool, &nbsp; &nbsp;42, &nbsp;'our class &quot;inherited&quot; an attribute', :todo&lt;feature&gt;);

is(!eval(' %!P = 1; 1'),
&nbsp; undef, 'calling a trait outside of a class should be a syntax error', :todo&lt;bug&gt;);</pre>
</div>


<a href="#" onclick="return tog_quote(21);">
<div ID="header_shown_21" style="display: none;">
- Hide the snippet from t/oo/traits/parameterized.t (line 13 ~ line 38) -
</div>
<div ID="header_hidden_21" style="display: block;">
- Show the snippet from t/oo/traits/parameterized.t (line 13 ~ line 38) -
</div>
</a>
<div ID="hide_21" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S12/&quot;Traits&quot;&gt;
# Basic definition
my $role_works;
ok eval('role cool {
&nbsp; has $.cool;

&nbsp; multi sub trait_auxiliary:&lt;is&gt;(cool $trait, Any $container; $val) {
&nbsp; &nbsp; $.cool = $val;
&nbsp; &nbsp; $container does cool($val);
&nbsp; }
&nbsp; $role_works = 1;
'), &quot;role definition works&quot;, :todo&lt;feature&gt;;

unless ($role_works) {
&nbsp; &nbsp; skip_rest 'role definition is broken'; exit;
}

my $a = 42;
is &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $a, 42, &quot;basic sanity (1)&quot;;
ok eval('$a does cool(23)'), &nbsp; &quot;imperative does worked (1)&quot;, :todo&lt;feature&gt;;
is eval('$a.cool'), &nbsp; &nbsp; &nbsp;23, &nbsp; &quot;attribute was set correctly (1)&quot;, :todo&lt;feature&gt;;

my $b = 23;
is &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; $b, 23, &quot;basic sanity (2)&quot;;
ok eval('$b does cool(&quot;hi&quot;)'), &quot;imperative does worked (2)&quot;, :todo&lt;feature&gt;;
is eval('$b.cool'), &nbsp; &nbsp; &nbsp;&quot;hi&quot;, &quot;attribute was set correctly (2)&quot;, :todo&lt;feature&gt;;</pre>
</div>


<p>Traits are just properties (roles) applied to declared items like containers or classes. It&#39;s the declaration of the item itself that makes traits seem more permanent than ordinary properties. In addition to adding the property, a trait can also have side effects.</p>

<p>Traits are generally applied with the &#34;is&#34; keyword, though not always. To define a trait handler for an &#34;is xxx&#34; trait, define one or more multisubs into a property role like this:</p>

<pre>    role xxx {
        has Int $.xxx;
        multi trait_auxiliary:is(xxx $trait, Class $container; $arg?) {...}
        multi trait_auxiliary:is(xxx $trait, Any $container; $arg?) {...}
    }</pre>

<p>Then it can function as a trait. A well-behaved trait handler will say</p>

<pre>    $container does xxx($arg);</pre>

<p>somewhere inside to set the metadata on the container correctly. Since a class can function as a role when it comes to parameter type matching, you can also say:</p>

<pre>    class MyBase {
        multi trait_auxiliary:is(MyBase $base, Class $class; $arg?) {...}
        multi trait_auxiliary:is(MyBase $tied, Any $container; $arg?) {...}
    }</pre>

<p>These capture control if <code>MyBase</code> wants to capture control of how it gets used by any class or container. But usually you can just let it call the generic defaults:</p>

<pre>    multi *trait_auxiliary:is(Class $base, Class $class; $arg?) {...}</pre>

<p>which adds <code>$base</code> to the &#34;isa&#34; list of <code>$class</code>, or</p>

<pre>    multi *trait_auxiliary:is(Class $tied, Any $container; $arg?) {...}</pre>

<p>which sets the &#34;tie&#34; type of the container to the implementation type in <code>$tied</code>.</p>

<p>Most traits are introduced by use of a &#34;helping verb&#34;, which could be something like &#34;<code>is</code>&#34;, or &#34;<code>will</code>&#34;, or &#34;<code>can</code>&#34;, or &#34;<code>might</code>&#34;, or &#34;<code>should</code>&#34;, or &#34;<code>does</code>&#34;. We call these helping verbs &#34;trait auxiliaries&#34;. Here&#39;s &#34;<code>will</code>&#34;, which (being syntactic sugar) merely delegates to back to &#34;is&#34;:</p>

<pre>    multi sub *trait_auxiliary:will($trait, $container; &#38;arg) {
        trait_auxiliary:is($trait, $container, &#38;arg);
    }</pre>

<p>Other traits are applied with a single word, and we call one of those a &#34;trait verb&#34;. For instance, the &#34;<code>returns</code>&#34; trait is defined something like this:</p>

<pre>    role returns {
        has ReturnType $.returns;
        multi sub trait_verb:returns($container; ReturnType $arg) {
            $container does returns($arg);
        }
        ...
    }</pre>

<p>Unlike compile-time roles, which all flatten out in the same class, compile-time traits are applied one at a time, like mixin roles. You can, in fact, apply a trait to a container at run time, but if you do, it&#39;s just an ordinary mixin role. You have to call the appropriate <code>trait_auxiliary:is()</code> routine yourself if you want it to do any extra shenanigans. The compiler won&#39;t call it for you at run time like it would at compile time.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Delegation"
>Delegation</a></h1>

<a href="#" onclick="return tog_quote(6);">
<div ID="header_shown_6" style="display: none;">
- Hide the snippet from t/oo/delegation.t (line 13 ~ line 41) -
</div>
<div ID="header_hidden_6" style="display: block;">
- Show the snippet from t/oo/delegation.t (line 13 ~ line 41) -
</div>
</a>
<div ID="hide_6" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S12/&quot;Delegation&quot;&gt;

class Backend1 { method hi() { 42 } method cool() { 1337 } }
class Backend2 { method hi() { 23 } method cool() { &nbsp;539 } }
class Frontend { has $.backend is rw handles &quot;hi&quot; }
ok Backend1.new, &quot;class definition worked&quot;;

is eval('Backend1.new.hi'), 42, &quot;basic sanity (1)&quot;;
is eval('Backend2.new.hi'), 23, &quot;basic sanity (2)&quot;;

{
&nbsp; my $a;
&nbsp; ok ($a = Frontend.new), &quot;basic instantiation worked (1)&quot;;
&nbsp; ok (!try { $a.hi }), &quot;calling a method on no object didn't succeed (1)&quot;;
&nbsp; ok $a.backend = Backend1.new(), &quot;setting a handler object (1)&quot;;
&nbsp; ok (!($a ~~ Backend1)), &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;object wasn't isa()ed (1)&quot;;
&nbsp; is try{ $a.hi }, 42, &quot;method was successfully handled by backend object (1)&quot;, :todo&lt;feature&gt;;
}

{
&nbsp; my $a;
&nbsp; ok ($a = Frontend.new), &quot;basic instantiation worked (2)&quot;;
&nbsp; ok (!try { $a.hi }), &quot;calling a method on no object didn't succeed (2)&quot;;
&nbsp; ok ($a.backend = Backend2.new()), &quot;setting a handler object (2)&quot;;
&nbsp; ok (!($a ~~ Backend2)), &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;object wasn't isa()ed (2)&quot;;
&nbsp; is try{ $a.hi }, 23, &quot;method was successfully handled by backend object (2)&quot;, :todo&lt;feature&gt;;
}</pre>
</div>


<p>Delegation lets you pretend that some other object&#39;s methods are your own. Delegation is specified by a <code>handles</code> trait verb with an argument specifying one or more method names that the current object and the delegated object will have in common:</p>

<pre>    has $tail handles &#39;wag&#39;;</pre>

<p>Since the method name (but nothing else) is known at class construction time, the following <code>.wag</code> method is autogenerated for you:</p>

<pre>    method wag (*@args is context(Lazy)) { $!tail.wag(|@args) }</pre>

<p>You can specify multiple method names:</p>

<a href="#" onclick="return tog_quote(3);">
<div ID="header_shown_3" style="display: none;">
- Hide the snippet from t/oo/delegation.t (line 70 ~ line 100) -
</div>
<div ID="header_hidden_3" style="display: block;">
- Show the snippet from t/oo/delegation.t (line 70 ~ line 100) -
</div>
</a>
<div ID="hide_3" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S12/&quot;Delegation&quot; /You can specify multiple method names:/&gt;
class MultiFrontend { has $.backend is rw handles &lt;hi cool&gt; }
ok MultiFrontend.new, &quot;class definition using multiple method names worked&quot;;
{
&nbsp; my $a;
&nbsp; ok ($a = MultiFrontend.new), &quot;basic instantiation worked (5)&quot;;
&nbsp; ok (!try { $a.hi &nbsp; }), &quot;calling a method on no object didn't succeed (5-1)&quot;;
&nbsp; ok (!try { $a.cool }), &quot;calling a method on no object didn't succeed (5-2)&quot;;
&nbsp; ok ($a.backend = Backend1.new()), &quot;setting a handler object (5)&quot;;
&nbsp; ok (!($a ~~ Backend1)), &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;object wasn't isa()ed (5)&quot;;
&nbsp; is (try { $a.hi }), &nbsp; &nbsp; 42, &quot;method was successfully handled by backend object (5-1)&quot;, :todo&lt;feature&gt;;
&nbsp; is (try { $a.cool }), 1337, &quot;method was successfully handled by backend object (5-2)&quot;, :todo&lt;feature&gt;;
}

#

class MyArray {
&nbsp; &nbsp; has @.elems handles &quot;join&quot;;
&nbsp; &nbsp; method concat handles &lt;chars bytes graphs codes&gt; { .join(&quot;&quot;) }
}

ok MyArray.new, &quot;class with attribute and return value delegation&quot;;
{
&nbsp; my $a;
&nbsp; ok ($a = MyArray.new(elems =&gt; [1..5])), &quot;basic instantiation worked&quot;;
&nbsp; is try{ $a.concat }, &quot;12345&quot;, &quot;attribute delegation worked&quot;, :todo&lt;feature&gt;;
&nbsp; is try{ $a.bytes &nbsp;}, 5, &quot;return delegation worked&quot;, :todo&lt;feature&gt;;
&nbsp; is try{ $a.chars &nbsp;}, 5, &quot;return delegation worked&quot;, :todo&lt;feature&gt;;
&nbsp; is try{ $a.codes &nbsp;}, 5, &quot;return delegation worked&quot;, :todo&lt;feature&gt;;
&nbsp; is try{ $a.graphs }, 5, &quot;return delegation worked&quot;, :todo&lt;feature&gt;;
}</pre>
</div>


<pre>    has $.legs handles &#60;walk run lope shake pee&#62;;</pre>

<p>It&#39;s illegal to call the outer method unless the attribute has been initialized to an object of a type supporting the method, such as by:</p>

<pre>    has Tail $.tail handles &#39;wag&#39; = { .new(|%_) };</pre>

<p>Note that putting a <code>Tail</code> type on the attribute does not necessarily mean that the method is always delegated to the <code>Tail</code> class. The dispatch is still based on the <i>run-time</i> type of the object, not the declared type.</p>

<p>Any other kind of argument to <code>handles</code> is considered to be a smartmatch selector for methods. So you can say:</p>

<a href="#" onclick="return tog_quote(5);">
<div ID="header_shown_5" style="display: none;">
- Hide the snippet from t/oo/delegation.t (line 42 ~ line 55) -
</div>
<div ID="header_hidden_5" style="display: block;">
- Show the snippet from t/oo/delegation.t (line 42 ~ line 55) -
</div>
</a>
<div ID="hide_5" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S12/&quot;Delegation&quot; /Any other kind of argument to handles is considered to be a smartmatch selector for methods/&gt;
class ReFrontend { has $.backend is rw handles /^hi/ };
ok ReFrontend.new, &quot;class definition using a smartmatch handle worked&quot;;

{
&nbsp; my $a;
&nbsp; ok ($a = ReFrontend.new), &quot;basic instantiation worked (3)&quot;;
&nbsp; ok (!try { $a.hi }), &quot;calling a method on no object didn't succeed (3)&quot;;
&nbsp; ok ($a.backend = Backend1.new()), &quot;setting a handler object (3)&quot;;
&nbsp; ok (!($a ~~ Backend1)), &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;object wasn't isa()ed (3)&quot;;
&nbsp; is try{ $a.hi }, 42, &quot;method was successfully handled by backend object (3)&quot;, :todo&lt;feature&gt;;
}</pre>
</div>


<pre>    has $.fur is rw handles /^get_/;</pre>

<p>If you say</p>

<a href="#" onclick="return tog_quote(4);">
<div ID="header_shown_4" style="display: none;">
- Hide the snippet from t/oo/delegation.t (line 56 ~ line 69) -
</div>
<div ID="header_hidden_4" style="display: block;">
- Show the snippet from t/oo/delegation.t (line 56 ~ line 69) -
</div>
</a>
<div ID="hide_4" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S12/&quot;Delegation&quot; /If you say/&gt;
class ClassFrontend { has $.backend is rw handles Backend2 };
ok ClassFrontend.new, &quot;class definition using a Class handle worked&quot;;
{
&nbsp; my $a;
&nbsp; ok ($a = ClassFrontend.new), &quot;basic instantiation worked (4)&quot;;
&nbsp; ok (!try { $a.hi }), &quot;calling a method on no object didn't succeed (4)&quot;;
&nbsp; ok ($a.backend = Backend1.new()), &quot;setting a handler object (4)&quot;;
&nbsp; ok (!($a ~~ Backend1)), &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;object wasn't isa()ed (4-1)&quot;;
&nbsp; ok (!($a ~~ Backend2)), &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;object wasn't isa()ed (4-2)&quot;;
&nbsp; is (try{ $a.hi }), 42, &quot;method was successfully handled by backend object (4)&quot;, :todo&lt;feature&gt;;
}</pre>
</div>


<pre>    has $.fur is rw handles Groomable;</pre>

<p>then you get only those methods available via the <code>Groomable</code> role or class.</p>

<p>Wildcard matches are evaluated only after it has been determined that there&#39;s no exact match to the method name anywhere. When you have multiple wildcard delegations to different objects, it&#39;s possible to have a conflict of method names. Wildcard method matches are evaluated in order, so the earliest one wins. (Non-wildcard method conflicts can be caught at class composition time.)</p>

<p>If, where you would ordinarily specify a string, you put a pair, then the pair maps the method name in this class to the method name in the other class. If you put a hash, each key/value pair is treated as such a mapping. Such mappings are not considered wildcards.</p>

<pre>    has $.fur handles { :shakefur&#60;shake&#62; :scratch&#60;get_fleas&#62; };</pre>

<p>You <i>can</i> do a wildcard renaming, but not with pairs. Instead do smartmatch with a substitution:</p>

<pre>    has $.fur handles (s/^furget_/get_/);</pre>

<p>Ordinarily delegation is based on an attribute holding an object, but it can also be based on the return value of a method:</p>

<pre>    method select_tail handles &#60;wag hang&#62; {...}</pre>

<p>If your delegation object happens to be an array:</p>

<pre>    has @handlers handles &#39;foo&#39;;</pre>

<p>then Perl 6 assumes that your array contains a list of potential handlers, and you just want to call the <i>first</i> one that succeeds. This is not considered a wildcard match unless the &#34;handles&#34; argument forces it to be.</p>

<p>If your delegation object happens to be a hash:</p>

<pre>    has %objects handles &#39;foo&#39;;</pre>

<p>then the hash provides a mapping from the string value of &#34;self&#34; to the object that should be delegated to:</p>

<pre>    has %barkers handles &#34;bark&#34; =
                (Chihauhau =&#62; $yip,
                    Beagle =&#62; $yap,
                   Terrier =&#62; $arf,
                 StBernard =&#62; $woof,
                );
    method prefix:&#60;~&#62;( return &#34;$.breed&#34; )</pre>

<p>If the string is not found in the hash, a &#34;<code>next METHOD</code>&#34; is automatically performed.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Types_and_Subtypes"
>Types and Subtypes</a></h1>

<a href="#" onclick="return tog_quote(23);">
<div ID="header_shown_23" style="display: none;">
- Hide the snippet from t/data_types/subtypes.t (line 15 ~ line 83) -
</div>
<div ID="header_hidden_23" style="display: block;">
- Show the snippet from t/data_types/subtypes.t (line 15 ~ line 83) -
</div>
</a>
<div ID="hide_23" style="display:none; border:1px solid">
<pre style="margin-left: 6px">L&lt;S12/&quot;Types and Subtypes&quot;&gt;

=cut

my $abs = '
multi sub my_abs (Num where { $^n &gt;= 0 } $n){ $n }
multi sub my_abs (Num where { $^n &lt; &nbsp;0 } $n){ -$n }
';

ok(eval(&quot;$abs; 1&quot;), &quot;we can compile subtype declarations&quot;, :todo&lt;feature&gt;);

is(eval(&quot;$abs; my_abs(3)&quot;), 3, &quot;and we can use them, too&quot;, :todo&lt;feature&gt;);
is(eval(&quot;$abs; my_abs(-5)&quot;), 5, &quot;and they actually work&quot;, :todo&lt;feature&gt;);


# Basic subtype creation
ok eval('subtype Num::Odd of Num where { $^num % 2 == 1 }'),
&nbsp; &quot;subtype is correctly parsed&quot;, :todo&lt;feature&gt;;
is eval('my Num::Odd $a = 3'), 3, &quot;3 is an odd num&quot;;
# The eval inside the eval is/will be necessary to hider our smarty
# compiler's compile-time from bailing.
# (Actually, if the compiler is *really* smarty, it will notice our eval trick,
# too :))
is eval('my Num::Odd $b = 3; try { $a = eval 4 }; $a'), 3,
&nbsp; &quot;objects of Num::Odd don't get even&quot;, :todo&lt;feature&gt;;

# The same, but lexically
my $eval1 = '{
&nbsp; my subtype Num::Even of Num where { $^num % 2 == 0 }
&nbsp; ok my Num::Even $c = 6, :todo&lt;feature&gt;;
&nbsp; ok $c ~~ Num::Even, &quot;our var is a Num::Even&quot;, :todo&lt;feature&gt;;
&nbsp; try { $c = eval 7 }
&nbsp; is $c, 6, &quot;setting a Num::Even to an odd value dies&quot;, :todo&lt;feature&gt;;
}';
eval $eval1;
ok eval('!try { my Num::Even $d }'),
&nbsp; &quot;lexically declared subtype went out of scope&quot;;

# Subs with arguments of a subtype
ok eval('sub only_accepts_odds(Num::Odd $odd) { $odd + 1 }'),
&nbsp; &quot;sub requiring a Num::Odd as argument defined (1)&quot;, :todo&lt;feature&gt;;
is eval('only_accepts_odds(3)'), 4,
&nbsp; &quot;calling sub worked&quot;;
ok eval('!try { only_accepts_odds(4) }'),
&nbsp; &quot;calling sub did not work&quot;, :todo&lt;feature&gt;;

# Normal Ints automatically morphed to Num::Odd
ok eval('sub is_num_odd(Num::Odd $odd) { $odd ~~ Num::Odd }'),
&nbsp; &quot;sub requiring a Num::Odd as argument defined (2)&quot;, :todo&lt;feature&gt;;
ok eval('is_num_odd(3)'), &quot;Int automatically morphed to Num::Odd&quot;, :todo&lt;feature&gt;;
is eval('only_accepts_odds(&quot;3&quot;)'), 4, &quot;Str automatically morphed to Num::Odd&quot;;

# Following code is evil, but should work:
my $eval2 = '
&nbsp; my Int $multiple_of;
&nbsp; subtype Num::Multiple of Num where { $^num % $multiple_of == 0 }

&nbsp; $multiple_of = 5;
&nbsp; ok $multiple_of ~~ Isa, &quot;basic sanity (1)&quot;, :todo&lt;feature&gt;;
&nbsp; is $multiple_of, &nbsp; &nbsp; 5, &quot;basic sanity (2)&quot;, :todo&lt;feature&gt;;

&nbsp; ok my Num::Multiple $d = 10, &quot;creating a new Num::Multiple&quot;, :todo&lt;feature&gt;;
&nbsp; is $d, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 10, &quot;creating a new Num::Multiple actually worked&quot;, :todo&lt;feature&gt;;
&nbsp; 
&nbsp; $multiple_of = 6;
&nbsp; ok !try { my Num::Multiple $e = eval 10 },
&nbsp; &nbsp; &quot;changed subtype definition worked&quot;;
';
eval $eval2;</pre>
</div>


<p>The type system of Perl consists of roles, classes, and subtypes. You can declare a subtype like this:</p>

<pre>    my subset Str_not2b of Str where /^[isnt|arent|amnot|aint]$/;</pre>

<p>or this:</p>

<pre>    my Str subset Str_not2b where /^[isnt|arent|amnot|aint]$/;</pre>

<p>An anonymous subtype looks like this:</p>

<pre>    Str where /^[isnt|arent|amnot|aint]$/;</pre>

<p>A <code>where</code> clause implies future smartmatching of some kind: the as-yet unspecified object of the type on the left must match the selector on the right. Our example is roughly equivalent to this closure:</p>

<pre>    { $_.does(Str) and $_ ~~ /^[isnt|arent|amnot|aint]$/; }</pre>

<p>except that a subtype knows when to call itself.</p>

<p>A subtype is not a subclass. Subclasses add capabilities, whereas a subtype adds constraints (takes away capabilites). A subtype is primarily a handy way of sneaking smartmatching into multiple dispatch. Just as a role allows you to specify something more general than a class, a subtype allows you to specify something more specific than a class. A subtype specifies a subset of the values that the original type specified, which is why we use the <code>subset</code> keyword for it.</p>

<p>While subtypes are primarily intended for restricting parameter types for multiple dispatch, they also let you impose preconditions on assignment. If you declare any container with a subtype, Perl will check the constraint against any value you might try to bind or assign to the container.</p>

<pre>    subset Str_not2b of Str where /^[isnt|arent|amnot|aint]$/;
    subset EvenNum   of Num where { $^n % 2 == 0 }

    my Str_not2b $hamlet;
    $hamlet = &#39;isnt&#39;;   # Okay because &#39;isnt&#39; ~~ /^[isnt|arent|amnot|aint]$/
    $hamlet = &#39;amnt&#39;;   # Bzzzzzzzt!   &#39;amnt&#39; !~~ /^[isnt|arent|amnot|aint]$/

    my EvenNum $n;
    $n = 2;             # Okay
    $n = -2;            # Okay
    $n = 0;             # Okay
    $n = 3;             # Bzzzzzzzt</pre>

<p>It&#39;s legal to base one subtype on another; it just adds an additional constraint. That is, it&#39;s a subset of a subset.</p>

<p>You can use an anonymous subtype in a signature:</p>

<pre>    sub check_even (Num where { $^n % 2 == 0 } $even) {...}</pre>

<p>That&#39;s a bit unwieldy, but by the normal type declaration rules you can turn it around to get the variable out front:</p>

<pre>    sub check_even ($even of Num where { $^n % 2 == 0 }) {...}</pre>

<p>and just for convenience we also let you write it:</p>

<pre>    sub check_even (Num $even where { $^n % 2 == 0 }) {...}</pre>

<p>since all the type constraints in a signature parameter are just anded together anyway.</p>

<p>Subtype constraints are used as tiebreakers in multiple dispatch:</p>

<pre>    use Rules::Common :profanity;

    multi sub mesg ($mesg of Str where /&#60;profanity&#62;/ is copy) {
        $mesg ~~ s:g/&#60;profanity&#62;/[expletive deleted]/;
        print $MESG_LOG: $mesg;
    }

    multi sub mesg ($mesg of Str) {
        print $MESG_LOG: $mesg;
    }</pre>

<p>For multi dispatch, a long name with a matching constraint is preferred over an equivalent one with no constraint. So the first <code>mesg</code> above is preferred if the constraint matches, and otherwise the second is preferred.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Enums"
>Enums</a></h1>

<a href="#" onclick="return tog_quote(36);">
<div ID="header_shown_36" style="display: none;">
- Hide the snippet from t/data_types/enum.t (line 6 ~ line 92) -
</div>
<div ID="header_hidden_36" style="display: block;">
- Show the snippet from t/data_types/enum.t (line 6 ~ line 92) -
</div>
</a>
<div ID="hide_36" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S12/Enums&gt;
{
&nbsp; &nbsp; my %hash; eval '%hash = enum :Mon(1) Tue Wed Thu Fri Sat Sun';

&nbsp; &nbsp; #is((%hash&lt;Mon Tue Wed Thu Fri Sat Sun&gt;) eq (1 .. 7)), &quot;enum generated correct sequence&quot;);
&nbsp; &nbsp; is(%hash&lt;Mon&gt;, 1, &quot;first value ok&quot;, :todo);
&nbsp; &nbsp; is(%hash&lt;Thu&gt;, 4, &quot;fourth value ok&quot;, :todo);
&nbsp; &nbsp; is(%hash&lt;Sun&gt;, 7, &quot;last value ok&quot;, :todo);
};

{
&nbsp; &nbsp; my %hash; eval '%hash = enum :Two(2) Three Four';

&nbsp; &nbsp; #is((%hash&lt;Two Three Four&gt;) eq (2 .. 4)), &quot;enum generated correct sequence&quot;);
&nbsp; &nbsp; is(%hash&lt;Two&gt;, 2, &quot;first value ok&quot;, :todo);
&nbsp; &nbsp; is(%hash&lt;Three&gt;, 3, &quot;second value ok&quot;, :todo);
&nbsp; &nbsp; is(%hash&lt;Four&gt;, 4, &quot;last value ok&quot;, :todo);
};

my %hash;

lives_ok { %hash = enum &lt;&lt;:Sun(1) :Mon(2) :Tue(3) :Wed(4) :Thu(5) :Fri(6) :Sat(7)&gt;&gt;; }, 'specifying keys and values works...', :todo&lt;feature&gt;;

is %hash.keys, &lt;Sun Mon Tue Wed Thu Fri Sat&gt;, '...and the right keys are assigned', :todo&lt;feature&gt;;

is %hash.values, 1..7, '...and the right values are assigned', :todo&lt;feature&gt;;

%hash = ();

lives_ok { %hash = enum &lt;&lt;:Sun(1) Mon Tue Wed Thu Fri Sat&gt;&gt;; }, 'specifying a value for only the first key works...', :todo&lt;feature&gt;;

is %hash.keys, &lt;Sun Mon Tue Wed Thu Fri Sat&gt;, '...and the right keys are assigned', :todo&lt;feature&gt;;

is %hash.values, 1..7, '...and the right values are assigned', :todo&lt;feature&gt;;

%hash = ();

lives_ok { %hash = enum :Sun(1) Mon Tue Wed Thu Fri Sat; }, 'french quotes work...', :todo&lt;feature&gt;;

is %hash.keys, &lt;Sun Mon Tue Wed Thu Fri Sat&gt;, '...and the right keys are assigned', :todo&lt;feature&gt;;

is %hash.values, 1..7, '...and the right values are assigned', :todo&lt;feature&gt;;

%hash = ();

lives_ok { %hash = enum &lt;&lt;:Sun(1) Mon Tue :Wed(4) Thu Fri Sat&gt;&gt;; }, 'specifying continuous values in the middle works...', :todo&lt;feature&gt;;

is %hash.keys, &lt;Sun Mon Tue Wed Thu Fri Sat&gt;, '...and the right keys are assigned', :todo&lt;feature&gt;;

is %hash.values, 1..7, '...and the right values are assigned', :todo&lt;feature&gt;;

%hash = ();

lives_ok { %hash = enum &lt;&lt;:Sun(1) Mon Tue :Wed(5) Thu Fri Sat&gt;&gt;; }, 'specifying different values in the middle works...', :todo&lt;feature&gt;;

is %hash.keys, &lt;Sun Mon Tue Wed Thu Fri Sat&gt;, '...and the right keys are assigned', :todo&lt;feature&gt;;

is %hash.values, (1, 2, 3, 5, 6, 7, 8), '...and the right values are assigned', :todo&lt;feature&gt;;

%hash = ();

lives_ok { %hash = enum :Alpha&lt;A&gt; Bravo Charlie Delta Echo; }, 'specifying a string up front works', :todo&lt;feature&gt;;

is %hash.keys, &lt;Alpha Bravo Charlie Delta Echo&gt;, '...and the right keys are assigned', :todo&lt;feature&gt;;

is %hash.values, &lt;A B C D E&gt;, '...and the right values are assigned', :todo&lt;feature&gt;;

%hash = ();

eval q[
lives_ok { %hash = enum &lt;&lt;:Alpha&lt;A&gt; Bravo Charlie Delta Echo&gt;&gt;; }, 'specifying a string up front works (Texas quotes)', :todo&lt;feature&gt;;
];

is %hash.keys, &lt;Alpha Bravo Charlie Delta Echo&gt;, '...and the right keys are assigned', :todo&lt;feature&gt;;

is %hash.values, &lt;A B C D E&gt;, '...and the right values are assigned', :todo&lt;feature&gt;;

%hash = ();

lives_ok { %hash = enum :zero(0) one two three four five six seven eight nine :ten&lt;a&gt; eleven twelve thirteen fourteen fifteen; }, 'mixing strings and integers works', :todo&lt;feature&gt;;

is %hash.keys, &lt;zero one two three four five six seven eight nine ten eleven twelve thirteen fourteen fifteen&gt;, '...and the right keys are assigned', :todo&lt;feature&gt;;

is %hash.values, (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 'A', 'B', 'C', 'D', 'E', 'F'), '...and the right values are assigned', :todo&lt;feature&gt;;

%hash = ();</pre>
</div>


<p>An enum is a low-level class that can function as a role or property. A given enum value can function as a subtype, a method, or as an ordinary value (an argumentless sub). The names of the values are specified as a list:</p>

<pre>    my enum Day [&#39;Sun&#39;,&#39;Mon&#39;,&#39;Tue&#39;,&#39;Wed&#39;,&#39;Thu&#39;,&#39;Fri&#39;,&#39;Sat&#39;];
    my enum Day &#60;Sun Mon Tue Wed Thu Fri Sat&#62;;</pre>

<p>If the first value is unspecified, it defaults to 0. To specify the first value, use pair notation (see below).</p>

<p>If the declared type name begins with an uppercase letter, the default type is <code>Int</code> or <code>Str</code>, depending on the type of the first value. If the declared type is lowercase, the default return type is <code>int</code> or <code>buf</code>.</p>

<p>The type can be specified:</p>

<pre>    my bit enum maybe &#60;no yes&#62;;
    my Int enum day [&#39;Sun&#39;,&#39;Mon&#39;,&#39;Tue&#39;,&#39;Wed&#39;,&#39;Thu&#39;,&#39;Fri&#39;,&#39;Sat&#39;];
    my enum day of uint4 &#60;Sun Mon Tue Wed Thu Fri Sat&#62;;</pre>

<p>An anonymous enum just makes sure each string turns into a pair with sequentially increasing values, so:</p>

<pre>    %e = enum &#60; ook! ook. ook? &#62;;</pre>

<p>is equivalent to:</p>

<pre>    %e = ();
    %e&#60;ook!&#62; = 0;
    %e&#60;ook.&#62; = 1;
    %e&#60;ook?&#62; = 2;</pre>

<p>The enum installer inspects list values for pairs, where the value of the pair sets the next value explicitly. Non-pairs <code>++</code> the previous value. (Str and buf types increment like Perl 5 strings.) Since the <code>&#171;...&#187;</code> quoter automatically recognizes pair syntax along with interpolations, we can simply say:</p>

<pre>    my enum DayOfWeek &#171;:Sun(1) Mon Tue Wed Thu Fri Sat&#187;;

    our Str enum Phonetic &#171;:Alpha&#60;A&#62; Bravo Charlie Delta
                            Echo Foxtrot Golf Hotel India Juliet
                            Kilo Lima Mike November Oscar Papa
                            Quebec Romeo Sierra Tango Uniform
                            Victor Whiskey X-ray Yankee Zulu&#187;;

    enum roman [i =&#62; 1,   v =&#62; 5,
                x =&#62; 10,  l =&#62; 50,
                c =&#62; 100, d =&#62; 500,
                m =&#62; 1000];

    my Item enum hex &#171;:zero(0) one two three four five six seven eight nine
                      :ten&#60;a&#62; eleven twelve thirteen fourteen fifteen&#187;;</pre>

<p>You may import enum types; only non-colliding values are imported. Colliding enum values are hidden and must be disambiguated with the type name. Any attempt to use the ambiguous name will result in a fatal compilation error. (All colliding values are hidden, not just the new one, or the old one.) Any explicit sub or type definition hides all imported enum values of the same name but will produce a warning unless <code>is redefined</code> is included. Note that true() is a built-in function, while True is short for <code>bool::True</code>.</p>

<p>Enum values may be used as a property on the right side of a <code>but</code>, and the enum type will be intuited from the value to make sure the object in question has the right semantics mixed in:</p>

<a href="#" onclick="return tog_quote(35);">
<div ID="header_shown_35" style="display: none;">
- Hide the snippet from t/oo/enums.t (line 34 ~ line 41) -
</div>
<div ID="header_hidden_35" style="display: block;">
- Show the snippet from t/oo/enums.t (line 34 ~ line 41) -
</div>
</a>
<div ID="hide_35" style="display:none; border:1px solid">
<pre style="margin-left: 6px">&nbsp; # L&lt;S12/&quot;Enums&quot; /has the right semantics mixed in:/&gt;
&nbsp; ok eval('$x does Tue'), &quot;basic enum mixing worked (1-1)&quot;;
&nbsp; test_stuff($x);
}

{
&nbsp; my $x = 2;
&nbsp; is $x, 2, &quot;basic sanity (2)&quot;;</pre>
</div>


<pre>    $x = &#34;Today&#34; but Tue;</pre>

<p>is the same as</p>

<a href="#" onclick="return tog_quote(33);">
<div ID="header_shown_33" style="display: none;">
- Hide the snippet from t/oo/enums.t (line 50 ~ line 57) -
</div>
<div ID="header_hidden_33" style="display: block;">
- Show the snippet from t/oo/enums.t (line 50 ~ line 57) -
</div>
</a>
<div ID="hide_33" style="display:none; border:1px solid">
<pre style="margin-left: 6px">&nbsp; # L&lt;S12/&quot;Enums&quot; /is the same as/&gt;
&nbsp; ok eval('$x does day::Tue'), &quot;basic enum mixing worked (3-1)&quot;;
&nbsp; test_stuff($x);
}

{
&nbsp; my $x = 4;
&nbsp; is $x, 4, &quot;basic sanity (4)&quot;;</pre>
</div>


<pre>    $x = &#34;Today&#34; but day::Tue;</pre>

<p>or pseudo-hash form:</p>

<a href="#" onclick="return tog_quote(34);">
<div ID="header_shown_34" style="display: none;">
- Hide the snippet from t/oo/enums.t (line 42 ~ line 49) -
</div>
<div ID="header_hidden_34" style="display: block;">
- Show the snippet from t/oo/enums.t (line 42 ~ line 49) -
</div>
</a>
<div ID="hide_34" style="display:none; border:1px solid">
<pre style="margin-left: 6px">&nbsp; # L&lt;S12/&quot;Enums&quot; /or pseudo-hash form:/&gt;
&nbsp; ok eval('$x does day&lt;Tue&gt;'), &quot;basic enum mixing worked (2-1)&quot;;
&nbsp; test_stuff($x);
}

{
&nbsp; my $x = 3;
&nbsp; is $x, 3, &quot;basic sanity (3)&quot;;</pre>
</div>


<pre>    $x = &#34;Today&#34; but day&#60;Tue&#62;;</pre>

<p>which is short for something like:</p>

<a href="#" onclick="return tog_quote(32);">
<div ID="header_shown_32" style="display: none;">
- Hide the snippet from t/oo/enums.t (line 58 ~ line 62) -
</div>
<div ID="header_hidden_32" style="display: block;">
- Show the snippet from t/oo/enums.t (line 58 ~ line 62) -
</div>
</a>
<div ID="hide_32" style="display:none; border:1px solid">
<pre style="margin-left: 6px">&nbsp; # L&lt;S12/&quot;Enums&quot; /which is short for something like:/&gt;
&nbsp; ok eval('$x does day'), &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&quot;basic enum mixing worked (4-0)&quot;;
&nbsp; ok eval('$x.day = &amp;day::(&quot;Tue&quot;)'), &quot;basic enum mixing worked (4-1)&quot;, :todo&lt;feature&gt;;
&nbsp; test_stuff($x);
}</pre>
</div>


<pre>    $x = &#34;Today&#34;;
    $x does day;
    $x.day = &#38;day::(&#39;Tue&#39;);</pre>

<p>There&#39;s also a pseudo-functional form:</p>

<pre>    $x = &#34;Today&#34; but day(Tue);</pre>

<p>which lets you cheat:</p>

<pre>    $x = &#34;Today&#34; but day(3);</pre>

<p>After any of those</p>

<pre>    $x.day</pre>

<p>returns <code>day::Tue</code> (that is, 3), and</p>

<pre>    $x ~~ day
    $x ~~ Tue
    $x.does(Tue)
    $x.does(day)
    $x.day == Tue
    day($x) == Tue
    Tue($x)
    $x.Tue</pre>

<p>all return true, and</p>

<pre>    $x.does(Wed)
    $x.Wed
    $x.day == Wed
    8.does(day)
    8 ~~ day</pre>

<p>all return false.</p>

<p>Two built-in enums are:</p>

<pre>    our bit enum *bool &#60;False True&#62;;
    our bit enum *taint &#60;Untainted Tainted&#62;;</pre>

<p>Note that <code>bool</code> and <code>taint</code> are really role names. You can call <code>.bool</code> on any built-in type, but the value returned is of type <code>bit</code>. Never compare a value to &#34;<code>true</code>&#34;, or even &#34;<code>True</code>&#34;. Just use it in a boolean context.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Open_vs_Closed_Classes"
>Open vs Closed Classes</a></h1>

<p>By default, all classes in Perl are non-final, which means you can derive from them. They are also open, which means you can add more methods to them, though you have to be explicit that that is what you&#39;re doing:</p>

<a href="#" onclick="return tog_quote(27);">
<div ID="header_shown_27" style="display: none;">
- Hide the snippet from t/oo/methods/chaining.t (line 60 ~ line 78) -
</div>
<div ID="header_hidden_27" style="display: block;">
- Show the snippet from t/oo/methods/chaining.t (line 60 ~ line 78) -
</div>
</a>
<div ID="hide_27" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S12/&quot;Open vs Closed Classes&quot;/&quot;though you have to be explicit&quot;&gt;
{
class Pair is also {
&nbsp; &nbsp; our &nbsp; &nbsp; &nbsp;method car () { self.key; }
&nbsp; &nbsp; our Pair method cdr () { self.value; }
}

# (A =&gt; (B =&gt; undef)) =&gt; (C =&gt; undef))
# ((A B) C)

my $cons = [=&gt;] ( [=&gt;] &lt;A B&gt;, undef ), &lt;C&gt;, undef;

## Hmm. &nbsp;Works with the latest release of Pugs (6.2.12 (r13256))
## Leaving this in as something that once didn't work (6.2.12 CPAN)

my $p = $cons.car;
ok( $cons.key.key =:= $p.car, 'chaining through temp variable' );
ok( $cons.key.key =:= $cons.car.car, 'chaining through Any return');
}</pre>
</div>


<pre>    class Object is also {
        method wow () { say &#34;Wow, I&#39;m an object.&#34; }
    }</pre>

<p>Otherwise you&#39;ll get a class redefinition error. (Also, to completely replace a definition, use &#34;<code>is instead</code>&#34; instead of &#34;<code>is also</code>&#34;...but don&#39;t do that.)</p>

<p>For optimization purposes, Perl 6 gives the top-level application the right to close and finalize classes.</p>

<pre>    use optimize :classes&#60;close finalize&#62;;</pre>

<p>This merely changes the application&#39;s default to closed and final, which means that at the end of the main compilation (<code>CHECK</code> time) the optimizer is allowed to look for candidate classes to close or finalize. But anyone (including the main application) can request that any class stay open or basal, and the class closer/finalizer must honor that.</p>

<pre>    use class :open&#60;Mammal Insect&#62; :basal&#60;Str&#62;</pre>

<p>These properties may also be specified on the class definition:</p>

<pre>    class Mammal is open {...}
    class Insect is open {...}
    class Str is basal {...}</pre>

<p>or by lexically scoped pragma around the class definition:</p>

<pre>    {
        use class :open;
        class Mammal {...}
        class Insect {...}
    }
    {
        use class :basal;
        class Str {...}
    }</pre>

<p>There is <i>no</i> syntax for declaring individual classes closed or final. The application may only request that the optimizer close and finalize unmarked classes.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Interface_Consistency"
>Interface Consistency</a></h1>

<p>By default, all methods and submethods that do not declare an explicit <code>*%</code> parameter will get an implicit <code>*%_</code> parameter declared for them whether they like it or not. In other words, all methods allow unexpected named arguments, so that <code>next METHOD</code> semantics work consistently.</p>

<p>If you mark a class &#34;<code>is hidden</code>&#34;, it hides the current class from &#34;<code>next METHOD</code>&#34; semantics, and incidentally suppresses the autogeneration of <code>*%_</code> parameters. Hidden classes may be visited as <code>SUPER::</code>, but not via &#34;<code>next</code>&#34;.</p>

<p>A similar effect can be achieved from the derived class by saying <code>hides Base</code> instead of <code>is Base</code>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Introspection"
>Introspection</a></h1>

<p>Metamethods for objects are named with interrogative pronouns in uppercase:</p>

<pre>    WHAT        the prototype object of the type, stringifies to short name</pre>

<a href="#" onclick="return tog_quote(28);">
<div ID="header_shown_28" style="display: none;">
- Hide the snippet from t/oo/what.t (line 11 ~ line 35) -
</div>
<div ID="header_hidden_28" style="display: block;">
- Show the snippet from t/oo/what.t (line 11 ~ line 35) -
</div>
</a>
<div ID="hide_28" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S12/Introspection/&quot;WHAT&quot;&gt;

plan 7;

# Basic subroutine/method form tests for C&lt;WHAT&gt;.
{
&nbsp; my $a = 3;
&nbsp; ok((WHAT $a) === Int, &quot;subroutine form of WHAT&quot;);
&nbsp; ok(($a.WHAT) === Int, &quot;method form of WHAT&quot;);
}

# Now testing basic correct inheritance.
{
&nbsp; my $a = 3;
&nbsp; ok($a.WHAT ~~ Num, &nbsp; &nbsp;&quot;an Int isa Num&quot;);
&nbsp; ok($a.WHAT ~~ Object, &quot;an Int isa Object&quot;);
}

# And a quick test for Code:
{
&nbsp; my $a = sub ($x) { 100 + $x };
&nbsp; ok($a.WHAT === Sub, &nbsp; &nbsp;&quot;a sub's type is Sub&quot;);
&nbsp; ok($a.WHAT ~~ Routine, &quot;a sub isa Routine&quot;);
&nbsp; ok($a.WHAT ~~ Code, &nbsp; &nbsp;&quot;a sub isa Code&quot;);
}</pre>
</div>


<pre>    WHICH       the object&#39;s identity value
    WHO         the package supporting the object, stringifies to long name
    WHERE       the memory address of the object
    HOW         the metaclass object: &#34;Higher Order Workings&#34;
    WHEN        (reserved for events?)
    WHY         (reserved for documentation?)</pre>

<p>None of these methods takes arguments, so they may also be used as named unary operators:</p>

<pre>    $obj.WHAT   # method form of P5&#39;s ref
    WHAT $obj   # unary form of P5&#39;s ref</pre>

<p>These are all actually macros, not true operators or methods. If you get a foreign object from another language and need to call its <code>.WHERE</code> method, you can say:</p>

<pre>    $obj.&#34;WHERE&#34;</pre>

<p>And if you don&#39;t know the method name in advance, you&#39;d be using the variable form anyway:</p>

<pre>    $obj.$somemeth</pre>

<p>which also bypasses the macros.</p>

<p>For now Perl 6 reserves the right to change how all these macros and the corresponding <code>^</code> forms are defined in terms of each other.</p>

<p>In general, use of these in ordinary code should be a red flag that Something Very Strange is going on. (Hence the allcaps.) Most code should use Perl 6&#39;s operators that make use of this information implicitly. For instance, instead of</p>

<pre>    $obj.WHAT eq &#39;Dog&#39;
    $x.WHICH === $y.WHICH
    $obj.WHAT.bless(%args)</pre>

<p>you usually just want:</p>

<pre>    $obj ~~ Dog
    $x === $y
    $obj.bless(%args)</pre>

<p>Every class has a <code>HOW</code> function/method that lets you get at the class&#39;s metaobject, which lets you get at all the metadata properties for the class (or other metaobject protocol) implementing the objects of the class:</p>

<pre>    MyClass.methods()           # call MyClass&#39;s .methods method (error?)
    MyClass.HOW.methods()       # get the method list of MyClass</pre>

<p>The <code>^</code> metasyntax is equivalent to <code>.HOW</code>:</p>

<pre>    MyClass.HOW.methods()       # get the method list of MyClass
    ^MyClass.methods()  # get the method list of MyClass
    MyClass.^methods()  # get the method list of MyClass</pre>

<p>Each object of the class also has a <code>.HOW</code> or <code>.^</code> method:</p>

<pre>    $obj.HOW.methods();
    $obj.^methods();</pre>

<p>Class traits may include:</p>

<a href="#" onclick="return tog_quote(29);">
<div ID="header_shown_29" style="display: none;">
- Hide the snippet from t/oo/meta_class.t (line 20 ~ line 25) -
</div>
<div ID="header_hidden_29" style="display: block;">
- Show the snippet from t/oo/meta_class.t (line 20 ~ line 25) -
</div>
</a>
<div ID="hide_29" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S12/&quot;Introspection&quot; /Class traits may include\:/&gt;

ok(eval(&quot;Foo.HOW.name() eq 'Foo'&quot;), '... the name() property is Foo');
ok(eval(&quot;Foo.HOW.version() == 0.0.1&quot;), '... the version() property is 0.0.1', :todo&lt;feature&gt;);
ok(eval(&quot;(Foo.HOW.isa())[0] ~~ Foo&quot;), '... the isa() property returns Foo as the first parent class', :todo&lt;feature&gt;);</pre>
</div>


<pre>    identifier    Dog-1.2.1-http://www.some.com/~jrandom
        name      Dog
        version   1.2.1
        authority http://www.some.com/~jrandom
    author        Joe Random
    description   This class implements camera obscura.
    subject       optics, boxes
    language      ja_JP
    licensed      Artistic|GPL
    isa           list of parent classes
    roles         list of roles
    disambig      how to deal with ambiguous method names from roles
    layout        P6opaque, P6hash, P5hash, P5array, PyDict, Cstruct, etc.</pre>

<p>These are for the standard Perl 6 Meta-Object Protocol, but other MOPs may define other traits. The identifier should probably be accessed through the <code>.WHO</code> object in any case, which may have its own object methods depending on how type namespaces evolve over time. Which of these items are actually part of the <code>.HOW</code> object and which are delegated back to the package and prototype objects is up to the MOP. (Note also that anonymous classes may have anonymous packages and prototype objects, in which case stringification is not likely to produce something of interest to non-gurus.)</p>

<p>The <code>.HOW.methods</code> method returns method-descriptors containing:</p>

<pre>    name                the name of the method
    signature           the parameters of the method
    returns             the return type of the method
    multi               whether duplicate names are allowed
    do                  the method body</pre>

<p>The <code>.methods</code> method has a selector parameter that lets you specify whether you want to see a flattened or hierarchical view, whether you&#39;re interested in private methods, and so forth.</p>

<p>The <code>.attributes</code> method returns a list of attribute descriptors that have traits like these:</p>

<pre>    name
    type
    scope
    rw
    private
    accessor
    build
    readonly</pre>

<p>Strictly speaking, metamethods like <code>.isa()</code>, <code>.does()</code>, and <code>.can()</code> should be called through the meta object:</p>

<a href="#" onclick="return tog_quote(30);">
<div ID="header_shown_30" style="display: none;">
- Hide the snippet from t/oo/meta_class.t (line 15 ~ line 19) -
</div>
<div ID="header_hidden_30" style="display: block;">
- Show the snippet from t/oo/meta_class.t (line 15 ~ line 19) -
</div>
</a>
<div ID="hide_30" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S12/&quot;Introspection&quot; /should be called through the meta object\:/&gt;

ok(eval(&quot;Foo.HOW.can('bar')&quot;), '... Foo can bar', :todo&lt;feature&gt;);
ok(eval(&quot;Foo.HOW.isa(Foo)&quot;), '... Foo is-a Foo (of course)', :todo&lt;bug&gt;);</pre>
</div>


<pre>    $obj.HOW.can(&#34;bark&#34;)
    $obj.HOW.does(Dog)
    $obj.HOW.isa(Mammal)</pre>

<p>or</p>

<pre>    $obj.^can(&#34;bark&#34;)
    $obj.^does(Dog)
    $obj.^isa(Mammal)</pre>

<p>But <code>Any</code> gives you shortcuts to those:</p>

<a href="#" onclick="return tog_quote(31);">
<div ID="header_shown_31" style="display: none;">
- Hide the snippet from t/oo/can.t (line 13 ~ line 26) -
</div>
<div ID="header_hidden_31" style="display: block;">
- Show the snippet from t/oo/can.t (line 13 ~ line 26) -
</div>
</a>
<div ID="hide_31" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S12/&quot;Introspection&quot;/&quot;But Any gives you shortcuts to those:&quot;&gt;

class Dog {
&nbsp; &nbsp; &nbsp; &nbsp; method bark {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;bow&quot;;
&nbsp; &nbsp; &nbsp; &nbsp; }
}

lives_ok {
&nbsp; &nbsp; &nbsp; &nbsp; my $dog = Dog.new;
&nbsp; &nbsp; &nbsp; &nbsp; $dog.can(&quot;bark&quot;);
}, &quot;method can on custom class fails&quot;, :todo&lt;bug&gt;;

lives_ok { Str.can(&quot;split&quot;) }, &quot;method can on built-in Str fails&quot;, :todo&lt;bug&gt;;</pre>
</div>


<pre>    $obj.can(&#34;bark&#34;)
    $obj.does(Dog)
    $obj.isa(Mammal)</pre>

<p>These, may, of course, be overridden in a subclass, so don&#39;t use the short form unless you wish to allow for overrides. In general, <code>Any</code> will delegate only those metamethods that read well when reasoning about an individual object. Infrastructural methods like <code>.methods</code> and <code>.attributes</code> are not delegated, so <code>$obj.methods</code> fails.</p>

<p>The smartmatch:</p>

<pre>    $obj ~~ Dog</pre>

<p>actually calls:</p>

<pre>    $obj.HOW.does(Dog)</pre>

<p>which is true if <code>$obj</code> either &#34;does&#34; or &#34;isa&#34; <code>Dog</code> (or &#34;isa&#34; something that &#34;does&#34; <code>Dog</code>).</p>

<p>Unlike in Perl 5 where <code>.can</code> returns a single <code>Code</code> object, Perl 6&#39;s version of <code>.HOW.can</code> returns a &#34;WALK&#34; iterator for a set of routines that match the name, including all autoloaded and wildcarded possibilities. In particular, <code>.can</code> interrogates any class package&#39;s <code>CANDO</code> method for names that are to be considered autoloadable methods in the class, even if they haven&#39;t been declared yet. Role composition sometimes relies on this ability to determine whether a superclass supplies a method of a particular name if it&#39;s required and hasn&#39;t been supplied by the class or one of its roles.</p>

<!-- end doc -->

</body></html>
