<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
           "http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>S29</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" >
<link rel="stylesheet" type="text/css" title="pod_stylesheet" href="http://dev.perl.org/css/perl.css">

<script type="text/javascript">
var agt = navigator.userAgent.toLowerCase();

var is_opera = (agt.indexOf("opera") != -1);
var is_ie = (agt.indexOf("msie") != -1) && document.all && !is_opera;
var is_ie5 = (agt.indexOf("msie 5") != -1) && document.all;

function tog() {
  // tog: toggle the visibility of html elements (arguments[1..]) from none to
  // arguments[0].  Return what should be returned in a javascript onevent().
  display = arguments[0];
  for( var i=1; i<arguments.length; i++ ) {
    var x = document.getElementById(arguments[i]);
    if (!x) continue;
    if (x.style.display == "none" || x.style.display == "") {
      x.style.display = display;
    } else {
      x.style.display = "none";
    }
  }

  var e = is_ie ? window.event : this;
  if (e) {
    if (is_ie) {
      e.cancelBubble = true;
      e.returnValue = false;
      return false;
    } else {
      return false;
    }
  }
}

function tog_quote( idnum ) {
  return tog( 'block', 'header_shown_' + idnum, 'header_hidden_' + idnum,
       'hide_' + idnum );
}

</script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.03,
  using Pod::Simple::PullParser v2.02,
  under Perl v5.008008 at Mon Sep 11 11:27:23 2006 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
            <I>This page was generated at 2006-09-11 11:27:23 GMT.
            (syn <strong>r11817</strong>, pugs <strong>r13179</strong>)</I>
        
<a name='___top' class='dummyTopAnchor' ></a>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#Title'>Title</a>
  <li class='indexItem indexItem1'><a href='#Version'>Version</a>
  <li class='indexItem indexItem1'><a href='#Notes'>Notes</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Operators_vs._Functions'>Operators vs. Functions</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#Type_Declarations'>Type Declarations</a>
  <li class='indexItem indexItem1'><a href='#Function_Packages'>Function Packages</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Math%3A%3ABasic'>Math::Basic</a>
    <li class='indexItem indexItem2'><a href='#Math%3A%3ATrig'>Math::Trig</a>
    <li class='indexItem indexItem2'><a href='#Scalar'>Scalar</a>
    <li class='indexItem indexItem2'><a href='#Container'>Container</a>
    <li class='indexItem indexItem2'><a href='#Array'>Array</a>
    <li class='indexItem indexItem2'><a href='#List'>List</a>
    <li class='indexItem indexItem2'><a href='#Hash'>Hash</a>
    <li class='indexItem indexItem2'><a href='#Str'>Str</a>
    <li class='indexItem indexItem2'><a href='#Control%3A%3ABasic'>Control::Basic</a>
    <li class='indexItem indexItem2'><a href='#Conversions'>Conversions</a>
    <li class='indexItem indexItem2'><a href='#Time'>Time</a>
    <li class='indexItem indexItem2'><a href='#OS'>OS</a>
    <li class='indexItem indexItem2'><a href='#Concurrency'>Concurrency</a>
    <li class='indexItem indexItem2'><a href='#Obsolete'>Obsolete</a>
    <li class='indexItem indexItem2'><a href='#Pending_Apocalypse'>Pending Apocalypse</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#Unfiled'>Unfiled</a>
  <li class='indexItem indexItem1'><a href='#Additions'>Additions</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Title"
>Title</a></h1>

<p>Synopsis 29: Builtin Functions</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Version"
>Version</a></h1>

<pre> Author:        Rod Adams &#60;rod@rodadams.net&#62;
 Maintainer:    Larry Wall &#60;larry@wall.org&#62;
 Contributions: Aaron Sherman &#60;ajs@ajs.com&#62;
 Date:          12 Mar 2005
 Last Modified: 08 Jul 2006
 Version:       4</pre>

<p>This document attempts to document the list of builtin functions in Perl 6. It assumes familiarity with Perl 5 and prior synopses.</p>

<p>The document is now the official S29. It&#39;s still here in the pugs repository temporarily to allow easy access to pugs implementors, but eventually it will be copied over to svn.perl.org. Despite its being &#34;official&#34;, feel free to hack on it as long as it&#39;s in the pugs space. -law</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Notes"
>Notes</a></h1>

<p>In Perl 6, all builtin functions belong to a named package. Not all functions are guaranteed to be imported into the global package <code>::*</code>. In addition, the list of functions imported into <code>::*</code> will be subject to change with each release of Perl. Authors wishing to &#34;Future Proof&#34; their code should either specifically import the functions they will be using, or always refer to the functions by their full name.</p>

<p>After 6.0.0 comes out, global aliases will not be removed lightly, and will never be removed at all without having gone through a deprecation cycle of at least a year. In any event, you can specify that you want the interface for a particular version of Perl, and that can be emulated by later versions of Perl to the extent that security updates allow.</p>

<p>Where code is given here, it is intended to define semantics, not to dictate implementation.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Operators_vs._Functions"
>Operators vs. Functions</a></h2>

<p>There is no particular difference between an operator and a function, but for the sake of documentation, only functions declared without specifying a grammatical category or with a category of <code>term:</code> (see <a href="http://search.cpan.org/perldoc?S02#Bits_and_Pieces" class="podlinkpod"
>&#34;Bits and Pieces&#34; in S02</a>) will be described as &#34;functions&#34;, and everything else as &#34;operators&#34; which are outside of the scope of this document.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Type_Declarations"
>Type Declarations</a></h1>

<p>The following type declarations are assumed:</p>

<dl>
<dt><a name="AnyChar"
>AnyChar</a></dt>

<dd>
<p>The root class of all &#34;character&#34; types, regardless of level.</p>

<p>This is a subtype of <code>Str</code>, limited to a length of 1 at it&#39;s highest supported Unicode level.</p>

<p>The type name <code>Char</code> is aliased to the maximum supported Unicode level in the current lexical scope (where &#34;current&#34; is taken to mean the eventual lexical scope for generic code (roles and macros), not the scope in which the generic code is defined). In other words, use <code>Char</code> when you don&#39;t care which level you&#39;re writing for.</p>

<p>Subclasses (things that are <code>isa AnyChar</code>):</p>

<dl>
<dt><a name="LinguaChar_or_Ling_(language-defined_characters)"
>LinguaChar or Ling (language-defined characters)
<dt><a name="GraphemeChar_or_Graf_(language-independent_graphemes)"
>GraphemeChar or Graf (language-independent graphemes)
<dt><a name="CodePoint_or_Uni_(Unicode_codepoints)"
>CodePoint or Uni (Unicode codepoints)
<dt><a name="Byte"
>Byte</a></dt>

<dd>
<p>Yes, Byte is both a string and a number.</p>
</dd>
</dl>

<dt><a name="MatchTest"
>MatchTest</a></dt>

<dd>
<pre> subset MatchTest of Item | Junction;</pre>

<p>Used to supply a test to match against. Assume <code>~~</code> will be used against it.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Function_Packages"
>Function Packages</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Math::Basic"
>Math::Basic</a></h2>

<p><b>API document</b>: <a href="http://search.cpan.org/perldoc?Math%3A%3ABasic" class="podlinkpod"
>Math::Basic</a></p>

<p><code>Math::Basic</code> provides a number of constants in addition to the basic mathematical functions. To get these constants, you must request them:</p>

<pre> use Math::Basic :constants;</pre>

<p>or use the full name, e.g. <code>Math::Basic::pi</code>.</p>

<dl>
<dt><a name="abs"
>abs</a></dt>

<dd>
<a href="#" onclick="return tog_quote(37);">
<div ID="header_shown_37" style="display: none;">
- Hide the snippet from t/builtins/math/abs.t (line 5 ~ line 29) -
</div>
<div ID="header_hidden_37" style="display: block;">
- Show the snippet from t/builtins/math/abs.t (line 5 ~ line 29) -
</div>
</a>
<div ID="hide_37" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Math::Basic&quot;/&quot;=item abs&quot;&gt;

=pod

Basic tests for the abs() builtin

=cut

for(0, 0.0, 1, 50, 60.0, 99.99) {
&nbsp; &nbsp; is(abs($_), $_, &quot;got the right absolute value for $_&quot;);
&nbsp; &nbsp; is(ref abs($_), ref $_, &quot;got the right data type(&quot;~ref($_)~&quot;) of absolute value for $_&quot;);
}
for(-1, -50, -60.0, -99.99) {
&nbsp; &nbsp; is(abs($_), -$_, &quot;got the right absolute value for $_&quot;);
&nbsp; &nbsp; is(ref abs($_), ref $_, &quot;got the right data type(&quot;~ref($_)~&quot;) of absolute value for $_&quot;);
}

for (0, 0.0, 1, 50, 60.0, 99.99) {
&nbsp; &nbsp; is(.abs, $_, 'got the right absolute value for $_='~$_);
&nbsp; &nbsp; is(ref .abs, ref $_, 'got the right data type('~ref($_)~') of absolute value for $_='~$_);
}
for (-1, -50, -60.0, -99.99) {
&nbsp; &nbsp; is(.abs, -$_, 'got the right absolute value for $_='~$_);
&nbsp; &nbsp; is(ref .abs, ref $_, 'got the right data type('~ref($_)~') of absolute value for $_='~$_);
}</pre>
</div>


<pre> our Num multi Math::Basic::abs ( Num $x )</pre>

<p>Absolute Value.</p>

<dt><a name="floor"
>floor</a></dt>

<dd>
<a href="#" onclick="return tog_quote(28);">
<div ID="header_shown_28" style="display: none;">
- Hide the snippet from t/builtins/math/rounders.t (line 6 ~ line 48) -
</div>
<div ID="header_hidden_28" style="display: block;">
- Show the snippet from t/builtins/math/rounders.t (line 6 ~ line 48) -
</div>
</a>
<div ID="hide_28" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Math::Basic&quot;/&quot;=item floor&quot;&gt;
# L&lt;S29/&quot;Math::Basic&quot;/&quot;=item truncate&quot;&gt;
# L&lt;S29/&quot;Math::Basic&quot;/&quot;=item ceiling&quot;&gt;

=pod

Basic tests for the round(), floor(), truncate() and ceil() built-ins

=cut

my %tests =
&nbsp; &nbsp; ( ceiling =&gt; [ [ 1.5, 2 ], [ 2, 2 ], [ 1.4999, 2 ],
&nbsp; &nbsp; &nbsp; &nbsp; [ -0.1, 0 ], [ -1, -1 ], [ -5.9, -5 ],
&nbsp; &nbsp; &nbsp; &nbsp; [ -0.5, 0 ], [ -0.499, 0 ], [ -5.499, -5 ] ],
&nbsp; &nbsp; &nbsp; floor =&gt; [ [ 1.5, 1 ], [ 2, 2 ], [ 1.4999, 1 ],
&nbsp; &nbsp; &nbsp; &nbsp; [ -0.1, -1 ], [ -1, -1 ], [ -5.9, -6 ],
&nbsp; &nbsp; &nbsp; &nbsp; [ -0.5, -1 ], [ -0.499, -1 ], [ -5.499, -6 ] &nbsp;],
&nbsp; &nbsp; &nbsp; round =&gt; [ [ 1.5, 2 ], [ 2, 2 ], [ 1.4999, 1 ],
&nbsp; &nbsp; &nbsp; &nbsp; [ -0.1, 0 ], [ -1, -1 ], [ -5.9, -6 ],
&nbsp; &nbsp; &nbsp; &nbsp; [ -0.5, -1 ], [ -0.499, 0 ], [ -5.499, -5 ] &nbsp;],
&nbsp; &nbsp; &nbsp; truncate =&gt; [ [ 1.5, 1 ], [ 2, 2 ], [ 1.4999, 1 ],
&nbsp; &nbsp; &nbsp; &nbsp; [ -0.1, 0 ], [ -1, -1 ], [ -5.9, -5 ],
&nbsp; &nbsp; &nbsp; &nbsp; [ -0.5, 0 ], [ -0.499, 0 ], [ -5.499, -5 ] &nbsp;],
&nbsp; &nbsp; );

if $?PUGS_BACKEND ne &quot;BACKEND_PUGS&quot; {
&nbsp; &nbsp; skip_rest &quot;PIL2JS and PIL-Run do not support eval() yet.&quot;;
&nbsp; &nbsp; exit;
}

for %tests.keys.sort -&gt; $type {
&nbsp; &nbsp; my @subtests = *%tests{$type};
&nbsp; &nbsp; for @subtests -&gt; $test {
&nbsp; &nbsp; &nbsp; &nbsp; my $code = &quot;{$type}($test[0])&quot;;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; my $res = eval($code);
&nbsp; &nbsp; &nbsp; &nbsp; if ($!) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flunk(&quot;failed to parse $code ($!)&quot;, :todo&lt;feature&gt;);
&nbsp; &nbsp; &nbsp; &nbsp; } else {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is($res, $test[1], &quot;$code == $test[1]&quot;);
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
}</pre>
</div>


<pre> our Int multi Math::Basic::floor ( Num $x )</pre>

<p>Returns the highest integer not greater than $x.</p>

<dt><a name="ceiling"
>ceiling</a></dt>

<dd>
<a href="#" onclick="return tog_quote(30);">
<div ID="header_shown_30" style="display: none;">
- Hide the snippet from t/builtins/math/rounders.t (line 8 ~ line 48) -
</div>
<div ID="header_hidden_30" style="display: block;">
- Show the snippet from t/builtins/math/rounders.t (line 8 ~ line 48) -
</div>
</a>
<div ID="hide_30" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Math::Basic&quot;/&quot;=item ceiling&quot;&gt;

=pod

Basic tests for the round(), floor(), truncate() and ceil() built-ins

=cut

my %tests =
&nbsp; &nbsp; ( ceiling =&gt; [ [ 1.5, 2 ], [ 2, 2 ], [ 1.4999, 2 ],
&nbsp; &nbsp; &nbsp; &nbsp; [ -0.1, 0 ], [ -1, -1 ], [ -5.9, -5 ],
&nbsp; &nbsp; &nbsp; &nbsp; [ -0.5, 0 ], [ -0.499, 0 ], [ -5.499, -5 ] ],
&nbsp; &nbsp; &nbsp; floor =&gt; [ [ 1.5, 1 ], [ 2, 2 ], [ 1.4999, 1 ],
&nbsp; &nbsp; &nbsp; &nbsp; [ -0.1, -1 ], [ -1, -1 ], [ -5.9, -6 ],
&nbsp; &nbsp; &nbsp; &nbsp; [ -0.5, -1 ], [ -0.499, -1 ], [ -5.499, -6 ] &nbsp;],
&nbsp; &nbsp; &nbsp; round =&gt; [ [ 1.5, 2 ], [ 2, 2 ], [ 1.4999, 1 ],
&nbsp; &nbsp; &nbsp; &nbsp; [ -0.1, 0 ], [ -1, -1 ], [ -5.9, -6 ],
&nbsp; &nbsp; &nbsp; &nbsp; [ -0.5, -1 ], [ -0.499, 0 ], [ -5.499, -5 ] &nbsp;],
&nbsp; &nbsp; &nbsp; truncate =&gt; [ [ 1.5, 1 ], [ 2, 2 ], [ 1.4999, 1 ],
&nbsp; &nbsp; &nbsp; &nbsp; [ -0.1, 0 ], [ -1, -1 ], [ -5.9, -5 ],
&nbsp; &nbsp; &nbsp; &nbsp; [ -0.5, 0 ], [ -0.499, 0 ], [ -5.499, -5 ] &nbsp;],
&nbsp; &nbsp; );

if $?PUGS_BACKEND ne &quot;BACKEND_PUGS&quot; {
&nbsp; &nbsp; skip_rest &quot;PIL2JS and PIL-Run do not support eval() yet.&quot;;
&nbsp; &nbsp; exit;
}

for %tests.keys.sort -&gt; $type {
&nbsp; &nbsp; my @subtests = *%tests{$type};
&nbsp; &nbsp; for @subtests -&gt; $test {
&nbsp; &nbsp; &nbsp; &nbsp; my $code = &quot;{$type}($test[0])&quot;;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; my $res = eval($code);
&nbsp; &nbsp; &nbsp; &nbsp; if ($!) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flunk(&quot;failed to parse $code ($!)&quot;, :todo&lt;feature&gt;);
&nbsp; &nbsp; &nbsp; &nbsp; } else {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is($res, $test[1], &quot;$code == $test[1]&quot;);
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
}</pre>
</div>


<pre> our Int multi Math::Basic::ceiling ( Num $x )
 our Int multi Math::Basic::ceil ( Num $x )</pre>

<p>Returns the lowest integer not less than $x.</p>

<dt><a name="round"
>round</a></dt>

<dd>
<a href="#" onclick="return tog_quote(27);">
<div ID="header_shown_27" style="display: none;">
- Hide the snippet from t/builtins/math/rounders.t (line 5 ~ line 48) -
</div>
<div ID="header_hidden_27" style="display: block;">
- Show the snippet from t/builtins/math/rounders.t (line 5 ~ line 48) -
</div>
</a>
<div ID="hide_27" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Math::Basic&quot;/&quot;=item round&quot;&gt;
# L&lt;S29/&quot;Math::Basic&quot;/&quot;=item floor&quot;&gt;
# L&lt;S29/&quot;Math::Basic&quot;/&quot;=item truncate&quot;&gt;
# L&lt;S29/&quot;Math::Basic&quot;/&quot;=item ceiling&quot;&gt;

=pod

Basic tests for the round(), floor(), truncate() and ceil() built-ins

=cut

my %tests =
&nbsp; &nbsp; ( ceiling =&gt; [ [ 1.5, 2 ], [ 2, 2 ], [ 1.4999, 2 ],
&nbsp; &nbsp; &nbsp; &nbsp; [ -0.1, 0 ], [ -1, -1 ], [ -5.9, -5 ],
&nbsp; &nbsp; &nbsp; &nbsp; [ -0.5, 0 ], [ -0.499, 0 ], [ -5.499, -5 ] ],
&nbsp; &nbsp; &nbsp; floor =&gt; [ [ 1.5, 1 ], [ 2, 2 ], [ 1.4999, 1 ],
&nbsp; &nbsp; &nbsp; &nbsp; [ -0.1, -1 ], [ -1, -1 ], [ -5.9, -6 ],
&nbsp; &nbsp; &nbsp; &nbsp; [ -0.5, -1 ], [ -0.499, -1 ], [ -5.499, -6 ] &nbsp;],
&nbsp; &nbsp; &nbsp; round =&gt; [ [ 1.5, 2 ], [ 2, 2 ], [ 1.4999, 1 ],
&nbsp; &nbsp; &nbsp; &nbsp; [ -0.1, 0 ], [ -1, -1 ], [ -5.9, -6 ],
&nbsp; &nbsp; &nbsp; &nbsp; [ -0.5, -1 ], [ -0.499, 0 ], [ -5.499, -5 ] &nbsp;],
&nbsp; &nbsp; &nbsp; truncate =&gt; [ [ 1.5, 1 ], [ 2, 2 ], [ 1.4999, 1 ],
&nbsp; &nbsp; &nbsp; &nbsp; [ -0.1, 0 ], [ -1, -1 ], [ -5.9, -5 ],
&nbsp; &nbsp; &nbsp; &nbsp; [ -0.5, 0 ], [ -0.499, 0 ], [ -5.499, -5 ] &nbsp;],
&nbsp; &nbsp; );

if $?PUGS_BACKEND ne &quot;BACKEND_PUGS&quot; {
&nbsp; &nbsp; skip_rest &quot;PIL2JS and PIL-Run do not support eval() yet.&quot;;
&nbsp; &nbsp; exit;
}

for %tests.keys.sort -&gt; $type {
&nbsp; &nbsp; my @subtests = *%tests{$type};
&nbsp; &nbsp; for @subtests -&gt; $test {
&nbsp; &nbsp; &nbsp; &nbsp; my $code = &quot;{$type}($test[0])&quot;;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; my $res = eval($code);
&nbsp; &nbsp; &nbsp; &nbsp; if ($!) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flunk(&quot;failed to parse $code ($!)&quot;, :todo&lt;feature&gt;);
&nbsp; &nbsp; &nbsp; &nbsp; } else {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is($res, $test[1], &quot;$code == $test[1]&quot;);
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
}</pre>
</div>


<pre> our Int multi Math::Basic::round ( Num $x )</pre>

<p>Returns the nearest integer to $x. The algorithm is floor($x + 0.5). (Other rounding algorithms will be given extended names beginning with &#34;round&#34;.)</p>

<dt><a name="truncate"
>truncate</a></dt>

<dd>
<a href="#" onclick="return tog_quote(35);">
<div ID="header_shown_35" style="display: none;">
- Hide the snippet from t/builtins/math/int.t (line 5 ~ line 68) -
</div>
<div ID="header_hidden_35" style="display: block;">
- Show the snippet from t/builtins/math/int.t (line 5 ~ line 68) -
</div>
</a>
<div ID="hide_35" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Math::Basic&quot;/&quot;=item truncate&quot;&gt;
# truncate and int() are synonynms. 
# Possibly more tests for truncate should be added here, too. 

=pod

Basic tests for the int() builtin

=cut

is(int(-1), -1, &quot;int(-1) is -1&quot;);
is(int(0), 0, &quot;int(0) is 0&quot;);
is(int(1), 1, &quot;int(1) is 1&quot;);
is(int(3.14159265), 3, &quot;int(3.14159265) is 3&quot;);
is(int(-3.14159265), -3, &quot;int(-3.14159265) is -3&quot;);

is(int(0.999), 0, &quot;int(0.999) is 0&quot;);
is(int(0.51), 0, &quot;int(0.51) is 0&quot;);
is(int(0.5), 0, &quot;int(0.5) is 0&quot;);
is(int(0.49), 0, &quot;int(0.49) is 0&quot;);
is(int(0.1), 0, &quot;int(0.1) is 0&quot;);

is(int(-0.999), -0, &quot;int(-0.999) is -0&quot;);
is(int(-0.51), -0, &quot;int(-0.51) is -0&quot;);
is(int(-0.5), -0, &quot;int(-0.5) is -0&quot;);
is(int(-0.49), -0, &quot;int(-0.49) is -0&quot;);
is(int(-0.1), -0, &quot;int(-0.1) is -0&quot;);

is(int(1.999), 1, &quot;int(1.999) is 1&quot;);
is(int(1.51), 1, &quot;int(1.51) is 1&quot;);
is(int(1.5), 1, &quot;int(1.5) is 1&quot;);
is(int(1.49), 1, &quot;int(1.49) is 1&quot;);
is(int(1.1), 1, &quot;int(1.1) is 1&quot;);

is(int(-1.999), -1, &quot;int(-1.999) is -1&quot;);
is(int(-1.51), -1, &quot;int(-1.51) is -1&quot;);
is(int(-1.5), -1, &quot;int(-1.5) is -1&quot;);
is(int(-1.49), -1, &quot;int(-1.49) is -1&quot;);
is(int(-1.1), -1, &quot;int(-1.1) is -1&quot;);

sub __int( Str $s ) {
&nbsp; if ($s ~~ rx:Perl5/^(-?\d+)$/) { return $0 };
&nbsp; if ($s ~~ rx:Perl5/^(-?\d+)\./) { return $0 };
&nbsp; if ($s ~~ rx:Perl5/^\./) { return 0 };
&nbsp; return undef;
};

# Check the defaulting to $_ 

for(0, 0.0, 1, 50, 60.0, 99.99, 0.4, 0.6,
&nbsp; &nbsp; -1, -50, -60.0, -99.99
&nbsp; &nbsp; ) {
&nbsp; &nbsp; my $int = __int($_);
&nbsp; &nbsp; is(.int, $int, &quot;integral value for $_ is $int&quot;);
&nbsp; &nbsp; isa_ok(.int, &quot;Int&quot;);
}

# Special values

is(int(1.9e3), 1900, &quot;int 1.9e3 is 1900&quot;);
is(int(Inf), &nbsp; &nbsp;Inf, &quot;int Inf is Inf&quot;, :todo&lt;bug&gt;);
is(int(-Inf), &nbsp;-Inf, &quot;int -Inf is -Inf&quot;, :todo&lt;bug&gt;);
is(int(NaN), &nbsp; &nbsp;NaN, &quot;int NaN is NaN&quot;, :todo&lt;bug&gt;);</pre>
</div>


<a href="#" onclick="return tog_quote(29);">
<div ID="header_shown_29" style="display: none;">
- Hide the snippet from t/builtins/math/rounders.t (line 7 ~ line 48) -
</div>
<div ID="header_hidden_29" style="display: block;">
- Show the snippet from t/builtins/math/rounders.t (line 7 ~ line 48) -
</div>
</a>
<div ID="hide_29" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Math::Basic&quot;/&quot;=item truncate&quot;&gt;
# L&lt;S29/&quot;Math::Basic&quot;/&quot;=item ceiling&quot;&gt;

=pod

Basic tests for the round(), floor(), truncate() and ceil() built-ins

=cut

my %tests =
&nbsp; &nbsp; ( ceiling =&gt; [ [ 1.5, 2 ], [ 2, 2 ], [ 1.4999, 2 ],
&nbsp; &nbsp; &nbsp; &nbsp; [ -0.1, 0 ], [ -1, -1 ], [ -5.9, -5 ],
&nbsp; &nbsp; &nbsp; &nbsp; [ -0.5, 0 ], [ -0.499, 0 ], [ -5.499, -5 ] ],
&nbsp; &nbsp; &nbsp; floor =&gt; [ [ 1.5, 1 ], [ 2, 2 ], [ 1.4999, 1 ],
&nbsp; &nbsp; &nbsp; &nbsp; [ -0.1, -1 ], [ -1, -1 ], [ -5.9, -6 ],
&nbsp; &nbsp; &nbsp; &nbsp; [ -0.5, -1 ], [ -0.499, -1 ], [ -5.499, -6 ] &nbsp;],
&nbsp; &nbsp; &nbsp; round =&gt; [ [ 1.5, 2 ], [ 2, 2 ], [ 1.4999, 1 ],
&nbsp; &nbsp; &nbsp; &nbsp; [ -0.1, 0 ], [ -1, -1 ], [ -5.9, -6 ],
&nbsp; &nbsp; &nbsp; &nbsp; [ -0.5, -1 ], [ -0.499, 0 ], [ -5.499, -5 ] &nbsp;],
&nbsp; &nbsp; &nbsp; truncate =&gt; [ [ 1.5, 1 ], [ 2, 2 ], [ 1.4999, 1 ],
&nbsp; &nbsp; &nbsp; &nbsp; [ -0.1, 0 ], [ -1, -1 ], [ -5.9, -5 ],
&nbsp; &nbsp; &nbsp; &nbsp; [ -0.5, 0 ], [ -0.499, 0 ], [ -5.499, -5 ] &nbsp;],
&nbsp; &nbsp; );

if $?PUGS_BACKEND ne &quot;BACKEND_PUGS&quot; {
&nbsp; &nbsp; skip_rest &quot;PIL2JS and PIL-Run do not support eval() yet.&quot;;
&nbsp; &nbsp; exit;
}

for %tests.keys.sort -&gt; $type {
&nbsp; &nbsp; my @subtests = *%tests{$type};
&nbsp; &nbsp; for @subtests -&gt; $test {
&nbsp; &nbsp; &nbsp; &nbsp; my $code = &quot;{$type}($test[0])&quot;;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; my $res = eval($code);
&nbsp; &nbsp; &nbsp; &nbsp; if ($!) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; flunk(&quot;failed to parse $code ($!)&quot;, :todo&lt;feature&gt;);
&nbsp; &nbsp; &nbsp; &nbsp; } else {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; is($res, $test[1], &quot;$code == $test[1]&quot;);
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
}</pre>
</div>


<pre> our Int multi Math::Basic::truncate ( Num $x )
 our Int multi Math::Basic::int ( Num $x )</pre>

<p>Returns the closest integer to $x whose absolute value is not greater than the absolute value of $x. (In other words, just chuck any fractional part.) This is the default rounding function used by an <code>int()</code> cast, for historic reasons. But see Int constructor above for a rounded version.</p>

<dt><a name="exp"
>exp</a></dt>

<dd>
<a href="#" onclick="return tog_quote(36);">
<div ID="header_shown_36" style="display: none;">
- Hide the snippet from t/builtins/math/exp.t (line 5 ~ line 17) -
</div>
<div ID="header_hidden_36" style="display: block;">
- Show the snippet from t/builtins/math/exp.t (line 5 ~ line 17) -
</div>
</a>
<div ID="hide_36" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Math::Basic&quot;/&quot;=item exp&quot;&gt;

=pod 

Basic tests for the exp() builtin

=cut

sub is_approx (Num $is, Num $expected, Str $descr) {
&nbsp; ok abs($is - $expected) &lt;= 0.00001, $descr;
}

is_approx(exp(5), 148.4131591025766, 'got the exponent of 5');</pre>
</div>


<pre> our Num multi Math::Basic::exp ( Num $exponent, Num :$base = Num::e )</pre>

<p>Performs similar to <code>$base ** $exponent</code>. <code>$base</code> defaults to the constant <i>e</i>.</p>

<dt><a name="log"
>log</a></dt>

<dd>
<a href="#" onclick="return tog_quote(34);">
<div ID="header_shown_34" style="display: none;">
- Hide the snippet from t/builtins/math/log.t (line 15 ~ line 19) -
</div>
<div ID="header_hidden_34" style="display: block;">
- Show the snippet from t/builtins/math/log.t (line 15 ~ line 19) -
</div>
</a>
<div ID="hide_34" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Math::Basic&quot;/&quot;=item log&quot;&gt;

is_approx(log(5), 1.6094379124341003, 'got the log of 5');
is_approx(log(0.1), -2.3025850929940455, 'got the log of 0.1');</pre>
</div>


<pre> our Num multi Math::Basic::log ( Num $x, Num :$base )</pre>

<p>Logarithm of base <code>$base</code>, default Natural. Calling with <code>$x == 0</code> is an error.</p>

<dt><a name="log10"
>log10</a></dt>

<dd>
<a href="#" onclick="return tog_quote(33);">
<div ID="header_shown_33" style="display: none;">
- Hide the snippet from t/builtins/math/log.t (line 20 ~ line 25) -
</div>
<div ID="header_hidden_33" style="display: block;">
- Show the snippet from t/builtins/math/log.t (line 20 ~ line 25) -
</div>
</a>
<div ID="hide_33" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Math::Basic&quot;/&quot;=item log10&quot;&gt;

is_approx(log10(5), 0.6989700043360187, 'got the log10 of 5');
is_approx(log10(0.1), -0.9999999999999998, 'got the log10 of 0.1');

# please add tests for complex numbers</pre>
</div>


<pre> our Num multi Math::Basic::log10 (Num $x);</pre>

<p>A base <code>10</code> logarithm, othewise identical to <code>log</code>.</p>

<dt><a name="rand"
>rand</a></dt>

<dd>
<a href="#" onclick="return tog_quote(32);">
<div ID="header_shown_32" style="display: none;">
- Hide the snippet from t/builtins/math/rand.t (line 13 ~ line 22) -
</div>
<div ID="header_hidden_32" style="display: block;">
- Show the snippet from t/builtins/math/rand.t (line 13 ~ line 22) -
</div>
</a>
<div ID="hide_32" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Math::Basic&quot; /rand/&gt;

ok(rand() &gt;= 0, 'rand() returns numbers greater than or equal to 0');
ok(rand() &lt; 1, 'rand() returns numbers less than 1');

for 1 .. 10 {
&nbsp; ok rand(10) &gt;= &nbsp;0, &quot;rand(10) always returns numbers greater than or equal to 0 ($_)&quot;;
&nbsp; ok rand(10) &nbsp;&lt; 10, &quot;rand(10) always returns numbers less than 10 ($_)&quot;;
}</pre>
</div>


<pre> our Num multi Math::Basic::rand ( Num $x = 1 )</pre>

<p>Pseudo random number in range <code>0 ..^ $x</code>. That is, <code>0</code> is theoretically possible, while <code>$x</code> is not.</p>

<dt><a name="sign"
>sign</a></dt>

<dd>
<a href="#" onclick="return tog_quote(26);">
<div ID="header_shown_26" style="display: none;">
- Hide the snippet from t/builtins/math/sign.t (line 5 ~ line 18) -
</div>
<div ID="header_hidden_26" style="display: block;">
- Show the snippet from t/builtins/math/sign.t (line 5 ~ line 18) -
</div>
</a>
<div ID="hide_26" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Math::Basic&quot;/&quot;=item sign&quot;&gt;

=pod 

Basic tests for the sign() builtin

=cut

is(sign(0), 0, 'got the right sign for 0');
is(sign(-100), -1, 'got the right sign for -100');
is(sign(100), 1, 'got the right sign for 100');
is(sign(1.5), 1, 'got the right sign for 1.5');
is(sign(-1.5), -1, 'got the right sign for -1.5');
dies_ok { sign(undef) }, 'sign on undefined value fails';</pre>
</div>


<pre> our Int multi Math::Basic::sign ( Num $x )</pre>

<p>Returns 1 when <code>$x</code> is greater than 0, -1 when it is less than 0, 0 when it is equal to 0, or undefined when the value passed is undefined.</p>

<dt><a name="srand"
>srand</a></dt>

<dd>
<a href="#" onclick="return tog_quote(31);">
<div ID="header_shown_31" style="display: none;">
- Hide the snippet from t/builtins/math/rand.t (line 23 ~ line 36) -
</div>
<div ID="header_hidden_31" style="display: block;">
- Show the snippet from t/builtins/math/rand.t (line 23 ~ line 36) -
</div>
</a>
<div ID="hide_31" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Math::Basic&quot; /srand/&gt;

eval_ok('srand(1)', 'srand(1) compiles', :todo);

sub repeat_rand ($seed) {
	srand($seed);
	for 1..99 { rand(); }
	return rand();
}

eval_ok( 'repeat_rand(314159) == repeat_rand(314159)',
&nbsp; &nbsp; 'srand() provides repeatability for rand()',
&nbsp; &nbsp; :todo, :depends('srand()')
);</pre>
</div>


<pre> multi Math::Basic::srand ( Num $seed = default_seed_algorithm())</pre>

<p>Seed the generator <code>rand</code> uses. <code>$seed</code> defaults to some combination of various platform dependent characteristics to yield a non-deterministic seed. Note that you get one <code>srand()</code> for free when you start a Perl program, so you <i>must</i> call <code>srand()</code> yourself if you wish to specify a deterministic seed (or if you wish to be differently nondeterministic).</p>

<dt><a name="sqrt"
>sqrt</a></dt>

<dd>
<a href="#" onclick="return tog_quote(25);">
<div ID="header_shown_25" style="display: none;">
- Hide the snippet from t/builtins/math/sqrt.t (line 5 ~ line 18) -
</div>
<div ID="header_hidden_25" style="display: block;">
- Show the snippet from t/builtins/math/sqrt.t (line 5 ~ line 18) -
</div>
</a>
<div ID="hide_25" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Math::Basic&quot;/&quot;=item sqrt&quot;&gt;

=pod 

Basic tests for the sqrt() builtin

=cut

sub is_approx (Num $is, Num $expected, Str $descr) {
&nbsp; ok abs($is - $expected) &lt;= 0.00001, $descr;
}

is_approx(sqrt(2), 1.4142135623730951, 'got the square root of 2');
is_approx(sqrt(5), 2.23606797749979, &nbsp; 'got the square root of 5');</pre>
</div>


<pre> our Num multi Math::Basic::sqrt ( Num $x )</pre>

<p>Returns the square root of the parameter.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Math::Trig"
>Math::Trig</a></h2>

<a href="#" onclick="return tog_quote(11);">
<div ID="header_shown_11" style="display: none;">
- Hide the snippet from t/builtins/math/trig.t (line 5 ~ line 99) -
</div>
<div ID="header_hidden_11" style="display: block;">
- Show the snippet from t/builtins/math/trig.t (line 5 ~ line 99) -
</div>
</a>
<div ID="hide_11" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Math::Trig&quot;&gt;

=head1 DESCRIPTION

Basic tests for trigonometric functions.

=cut

sub approx(Num $a, Num $b) {
&nbsp; my $EPSILON = 0.0001;
&nbsp; ($EPSILON &gt; abs($a - $b));
}

# See also: L&lt;<a href="http://theory.cs.iitm.ernet.in/~arvindn/pi/">&quot;http://theory.cs.iitm.ernet.in/~arvindn/pi/&quot;</a>&gt; :)
my $PI = 3.14159265358979323846264338327950288419716939937510;

# -- pi
ok(approx(pi, $PI), &quot;pi()&quot;);
ok(approx(pi + 3, $PI + 3), &quot;'pi() + 3' may drop its parentheses before +3&quot;);

# -- atan
# The basic form of atan (one argument) returns a value in ]-pi, pi[.
# Quadrants I, III
ok(approx(atan(1) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; / $PI * 180, 45));
ok(approx(atan(1/3*sqrt(3)) / $PI * 180, 30));
ok(approx(atan(sqrt(3)) &nbsp; &nbsp; / $PI * 180, 60));

# Quadrants II, IV
ok(approx(atan(-1) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; / $PI * 180, -45));
ok(approx(atan(-1/3*sqrt(3)) / $PI * 180, -30));
ok(approx(atan(-sqrt(3)) &nbsp; &nbsp; / $PI * 180, -60));

# S29: This second form of C&lt;atan&gt; computes the arctangent of $y/$x, and
# **takes the quadrant into account**.
# Quadrant I
ok(approx(atan(1, 1) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; / $PI * 180, 45));
ok(approx(atan(1, sqrt(3)) &nbsp; &nbsp; / $PI * 180, 30));
ok(approx(atan(1, 1/3*sqrt(3)) / $PI * 180, 60));

# Quadrant II
ok(approx(atan(1, -1) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; / $PI * 180, 135));
ok(approx(atan(1, -1/3*sqrt(3)) / $PI * 180, 120));
ok(approx(atan(1, -sqrt(3)) &nbsp; &nbsp; / $PI * 180, 150));

# Quadrant III
ok(approx(atan(-1, -1) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; / $PI * 180 + 360, 225));
ok(approx(atan(-1, -sqrt(3)) &nbsp; &nbsp; / $PI * 180 + 360, 210));
ok(approx(atan(-1, -1/3*sqrt(3)) / $PI * 180 + 360, 240));

# Quadrant IV
ok(approx(atan(-1, 1) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; / $PI * 180 + 360, 315));
ok(approx(atan(-1, sqrt(3)) &nbsp; &nbsp; / $PI * 180 + 360, 330));
ok(approx(atan(-1, 1/3*sqrt(3)) / $PI * 180 + 360, 300));

# -- sin, cos, tan
# sin
ok(approx(sin(0/4*$PI), 0));
ok(approx(sin(1/4*$PI), 1/2*sqrt(2)));
ok(approx(sin(2/4*$PI), 1));
ok(approx(sin(3/4*$PI), 1/2*sqrt(2)));
ok(approx(sin(4/4*$PI), 0));
ok(approx(sin(5/4*$PI), -1/2*sqrt(2)));
ok(approx(sin(6/4*$PI), -1));
ok(approx(sin(7/4*$PI), -1/2*sqrt(2)));
ok(approx(sin(8/4*$PI), 0));

# cos
ok(approx(cos(0/4*$PI), 1));
ok(approx(cos(1/4*$PI), 1/2*sqrt(2)));
ok(approx(cos(2/4*$PI), 0));
ok(approx(cos(3/4*$PI), -1/2*sqrt(2)));
ok(approx(cos(4/4*$PI), -1));
ok(approx(cos(5/4*$PI), -1/2*sqrt(2)));
ok(approx(cos(6/4*$PI), 0));
ok(approx(cos(7/4*$PI), 1/2*sqrt(2)));
ok(approx(cos(8/4*$PI), 1));

# tan
ok(approx(tan(0/4*$PI), 0));
ok(approx(tan(1/4*$PI), 1));
ok(approx(tan(3/4*$PI), -1));
ok(approx(tan(4/4*$PI), 0));
ok(approx(tan(5/4*$PI), 1));
ok(approx(tan(7/4*$PI), -1));
ok(approx(tan(8/4*$PI), 0));

# asin
ok(approx(try {asin(0)}, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0));
ok(approx(try {asin(1/2*sqrt(2))}, &nbsp;1/4*$PI), :todo&lt;feature&gt;);
ok(approx(try {asin(1)}, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2/4*$PI), :todo&lt;feature&gt;);

# acos
ok(approx(try {acos(0)}, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2/4*$PI), :todo&lt;feature&gt;);
ok(approx(try {acos(1/2*sqrt(2))}, &nbsp;1/4*$PI), :todo&lt;feature&gt;);
ok(approx(try {acos(1)}, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0/4*$PI));</pre>
</div>


<dl>
<dt><a name="Standard_Trig_Functions"
><i>Standard Trig Functions</i></a></dt>

<dd>
<pre> our Num multi Num::func ( Num  $x, $base = &#39;radians&#39; )
 our Num multi Math::Trig::func ( Num $x, $base = &#39;radians&#39; )</pre>

<p>where <i>func</i> is one of: sin, cos, tan, asin, acos, atan, sec, cosec, cotan, asec, acosec, acotan, sinh, cosh, tanh, asinh, acosh, atanh, sech, cosech, cotanh, asech, acosech, acotanh.</p>

<p>Performs the various trigonometric functions.</p>

<p>Option <code>$base</code> is used to declare how you measure your angles. Given the value of an arc representing a single full revolution.</p>

<pre> $base      Result
 ----       -------
 /:i ^r/    Radians  (2*pi)
 /:i ^d/    Degrees  (360)
 /:i ^g/    Gradians (400)
 Num        Units of 1 revolution.</pre>

<p>Note that module currying can be used within a lexical scope to specify a consistent base so you don&#39;t have to supply it with every call:</p>

<pre> my module Trig ::= Math::Trig.assuming(:base&#60;degrees&#62;);</pre>

<p>This overrides the default of &#34;radians&#34;.</p>

<dt><a name="atan2"
>atan2</a></dt>

<dd>
<pre> our Num multi Math::Trig::atan2 ( Num $y, Num $x = 1, Num $base )</pre>

<p>This second form of <code>atan</code> computes the arctangent of $y/$x, and takes the quadrant into account. Otherwise behaves as other trigonometric functions.</p>

<p>[Note: changed atan back to atan2, or the default $x = 1 will confuse MMD. The other alternative would be to remove the default. --law]</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Scalar"
>Scalar</a></h2>

<p><b>API document</b>: <a href="http://search.cpan.org/perldoc?Scalar" class="podlinkpod"
>Scalar</a></p>

<p><code>Scalar</code> provides the basic tools for operating on undifferentiated scalar variables. All of the following are exported by default.</p>

<dl>
<dt><a name="defined"
>defined</a></dt>

<dd>
<pre>  our Bool multi Scalar::defined ( Any $thing )
  our Bool multi Scalar::defined ( Any $thing, ::role )</pre>

<p><code>defined</code> returns true if the parameter has a value and that value is not the undefined value (per <code>undef</code>), otherwise false is returned.</p>

<p>Same as Perl 5, only takes extra optional argument to ask if value is defined with respect to a particular role:</p>

<pre>  defined($x, SomeRole);</pre>

<p>A value may be defined according to one role and undefined according to another. Without the extra argument, defaults to the definition of defined supplied by the type of the object.</p>

<dt><a name="undefine"
>undefine</a></dt>

<dd>
<pre>  our multi Any::undefine( Any $thing )</pre>

<p>Takes any variable as a parameter and attempts to &#34;remove&#34; its definition. For simple scalar variables this means assigning the undefined value to the variable. For objects, this is equivalent to invoking their undefine method. For arrays, hashes and other complex data, this might require emptying the structures associated with the object.</p>

<p>In all cases, calling <code>undefine</code> on a variable should place the object in the same state as if it was just declared.</p>

<dt><a name="undef"
>undef</a></dt>

<dd>
<pre>  constant Scalar Scalar::undef</pre>

<p>Returns the undefined scalar object. <code>undef</code> has no value at all, but for historical compatibility, it will numify to <code>0</code> and stringify to the empty string, potentially generating a warning in doing so. There are two ways to determine if a value equal to undef: the <code>defined</code> function (or method) can be called or the <code>//</code> (or <code>err</code>) operator can be used.</p>

<p><code>undef</code> is also considered to be false in a boolean context. Such a conversion does not generate a warning.</p>

<p>Perl 5&#39;s unary <code>undef</code> function is renamed <code>undefine</code> to avoid confusion with the value <code>undef</code> (which is always 0-ary now).</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Container"
>Container</a></h2>

<dl>
<dt><a name="cat"
>cat</a></dt>

<dd>
<pre> our Lazy multi Container::cat( *@@list );</pre>

<p><code>cat</code> reads arrays serially rather than in parallel as <code>each</code> does. It returns all of the elements of the containers that were passed to it like so:</p>

<pre> cat(@a;@b;@c);</pre>

<p>Typically, you could just write <code>(@a,@b,@c)</code>, but sometimes it&#39;s nice to be explicit about that:</p>

<pre> @foo := [[1,2,3],[4,5,6]]; say cat([;] @foo); # 1,2,3,4,5,6</pre>

<dt><a name="each"
>each</a></dt>

<dd>
<pre> our Lazy multi Container::each( Bool :$shortest, Bool :$finite, *@@list )</pre>

<p>Unlike Perl 5&#39;s each, <code>each</code> is a general method that traverses any composite container in a type-specific manner. <code>each</code> is like <a href="http://search.cpan.org/perldoc?S29#zip" class="podlinkpod"
>&#34;zip&#34; in S29</a>, but does not create tuples as return values. An example of its use is:</p>

<pre> for each(:parity, =&#60;&#62;; 1..*) -&#62; ($line, $lineno) {
   say &#34;$lineno: $line&#34;;
 }</pre>

<p>The optional <code>:shortest</code> named parameter causes <code>each</code> to stop processing its input lists as soon as <i>any</i> of them is exhausted. This modifier can also be used on individual containers, causing <code>each</code> to stop when <i>that</i> parameter is empty.</p>

<p>The optional <code>:finite</code> named parameter causes <code>each</code> to stop processing its input lists as long as only those which are known at run-time to represent infinite ranges are left.</p>

<p>For P5-like traversal, see <code>Hash::kv</code> or <code>Hash::pairs</code> instead, and put into <code>for</code> instead of <code>while</code>. Perhaps there is a <code>Perl5::p5each</code> emulation.</p>

<dt><a name="roundrobin"
>roundrobin</a></dt>

<dd>
<pre> our Lazy multi Container::roundrobin( Bool :$shortest, Bool :$finite, *@@list )</pre>

<p><code>roundrobin</code> is very similar to <code>each</code>, and in fact</p>

<pre> roundrobin( :shortest, @a; @b; @c );</pre>

<p>and</p>

<pre> each( :shortest, @a; @b; @c );</pre>

<p>Are exactly the same. The difference is that, by default <code>roundrobin</code> will not return <code>undef</code> as a &#34;spacer&#34; for an array that has been emptied. Thus:</p>

<pre> my @a = 1;
 my @b = 1..2;
 my @c = 1..3;
 for roundrobin( @a; @b; @c ) -&#62; $x { ... }</pre>

<p>will get the following values for <code>$x</code>: <code>1, 1, 1, 2, 2, 3</code></p>

<p><code>each</code> would get: <code>1, 1, 1, 2, 2, undef, 3, undef, undef</code></p>

<dt><a name="zip"
>zip</a></dt>

<dd>
<pre> our Iterator multi Container::zip ( Bool :$shortest, Bool :$finite, *@@list )
 our Iterator multi infix:Container::&#165; ( Bool :$shortest, Bool :$finite, *@@list )
 our Iterator multi infix:Container::Y ( Bool :$shortest, Bool :$finite, *@@list )</pre>

<p>zip takes any number of arrays and returns one tuple for every index. This is easier to read in an example:</p>

<pre> for zip(@a;@b;@c) -&#62; [$nth_a,$nth_b,$nth_c] {
   ...
 }</pre>

<p>mnemonic: the input arrays are &#34;zipped&#34; up like a zipper.</p>

<p>The optional <code>:shortest</code> named parameter causes <code>zip</code> to stop processing its input lists as soon as <i>any</i> of them is exhausted. This modifier can also be used on individual containers, causing <code>zip</code> to stop when <i>that</i> parameter is empty.</p>

<p>The optional <code>:finite</code> named parameter causes <code>zip</code> to stop processing its input lists as long as only those which are known at run-time to represent infinite ranges are left.</p>

<p><code>&#165;</code> (and its ASCII equivalent, <code>Y</code>) is an infix equivalent for zip:</p>

<pre> for @a &#165; @b &#165; @c -&#62; [$a,$b,$c] {...}</pre>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Array"
>Array</a></h2>

<dl>
<dt><a name="delete"
>delete</a></dt>

<dd>
<pre> our List multi method Array::delete (@array : *@indices )</pre>

<p>Sets elements specified by <code>@indices</code> in the invocant to a non-existent state, as if they never had a value. Deleted elements at the end of an Array shorten the length of the Array, unless doing so would violate an <code>is shape()</code> definition.</p>

<p><code>@indices</code> is interpreted the same way as subscripting is in terms of slices and multidimensionality. See Synopsis 9 for details.</p>

<p>Returns the value(s) previously held in deleted locations.</p>

<p>An unary form is expected. See <code>Hash::delete</code>.</p>

<dt><a name="exists"
>exists</a></dt>

<dd>
<pre> our Bool multi method Array::exists (@array : Int *@indices )</pre>

<p>True if the specified Array element has been assigned to. This is not the same as being defined.</p>

<p>Supplying a different number of indices than invocant has dimensions is an error.</p>

<p>An unary form is expected. See <code>Hash::delete</code>.</p>

<dt><a name="pop"
>pop</a></dt>

<dd>
<a href="#" onclick="return tog_quote(6);">
<div ID="header_shown_6" style="display: none;">
- Hide the snippet from t/builtins/arrays/pop.t (line 4 ~ line 84) -
</div>
<div ID="header_hidden_6" style="display: block;">
- Show the snippet from t/builtins/arrays/pop.t (line 4 ~ line 84) -
</div>
</a>
<div ID="hide_6" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Array&quot;/&quot;=item pop&quot;&gt;

=kwid 

Pop tests

=cut

plan 27;

{ # pop() elements into variables
&nbsp; &nbsp; my @pop = (1, 2, 3, 4);

&nbsp; &nbsp; is(+@pop, 4, 'we have 4 elements in the array');
&nbsp; &nbsp; my $a = pop(@pop);
&nbsp; &nbsp; is($a, 4, 'pop(@pop) works');

&nbsp; &nbsp; is(+@pop, 3, 'we have 3 elements in the array');
&nbsp; &nbsp; my $a = pop @pop;
&nbsp; &nbsp; is($a, 3, 'pop @pop works');

&nbsp; &nbsp; is(+@pop, 2, 'we have 2 elements in the array');
&nbsp; &nbsp; my $a = @pop.pop();
&nbsp; &nbsp; is($a, 2, '@pop.pop() works');

&nbsp; &nbsp; is(+@pop, 1, 'we have 1 element in the array');
&nbsp; &nbsp; my $a = @pop.pop;
&nbsp; &nbsp; is($a, 1, '@pop.pop works');

&nbsp; &nbsp; is(+@pop, 0, 'we have no more element in the array');
&nbsp; &nbsp; ok(!defined(pop(@pop)), 'after the array is exhausted pop() returns undef');
}

{ # pop() elements inline
&nbsp; &nbsp; my @pop = (1, 2, 3, 4);

&nbsp; &nbsp; is(+@pop, 4, 'we have 4 elements in the array');
&nbsp; &nbsp; is(pop(@pop), 4, 'inline pop(@pop) works');

&nbsp; &nbsp; is(+@pop, 3, 'we have 3 elements in the array');
&nbsp; &nbsp; is(pop @pop, 3, 'inline pop @pop works');

&nbsp; &nbsp; is(+@pop, 2, 'we have 2 elements in the array');
&nbsp; &nbsp; is(@pop.pop(), 2, 'inline @pop.pop() works');

&nbsp; &nbsp; is(+@pop, 1, 'we have 1 element in the array');
&nbsp; &nbsp; is(@pop.pop, 1, 'inline @pop.pop works');

&nbsp; &nbsp; is(+@pop, 0, 'we have no more element in the array');
&nbsp; &nbsp; ok(!defined(pop(@pop)), 'after the array is exhausted pop() returns undef');
}

# invocant syntax with inline arrays
{
&nbsp; &nbsp; is([1, 2, 3].pop, 3, 'this will return 3');
&nbsp; &nbsp; ok(!defined([].pop), 'this will return undef'); &nbsp; &nbsp;
}

# some edge cases

{
&nbsp; &nbsp; my @pop;
&nbsp; &nbsp; ok(!defined(@pop.pop()), 'pop on an un-initalized array returns undef');
}

# testing some error cases
{
&nbsp; &nbsp; my @pop = 1 .. 5;
&nbsp; &nbsp; dies_ok({ pop() &nbsp; &nbsp; &nbsp; &nbsp; }, 'pop() requires arguments'); &nbsp; &nbsp;
&nbsp; &nbsp; dies_ok({ pop(@pop, 10) }, 'pop() should not allow extra arguments'); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; dies_ok({ @pop.pop(10) &nbsp;}, 'pop() should not allow extra arguments'); &nbsp; &nbsp;
&nbsp; &nbsp; dies_ok({ 42.pop &nbsp; &nbsp; &nbsp; &nbsp;}, '.pop should not work on scalars');
}

# Pop with Inf arrays (waiting on answers from perl6-compiler email)
#{
# &nbsp; &nbsp;my @push = 1 .. Inf;
# &nbsp; &nbsp;# best not to uncomment this it just go on forever
# &nbsp; &nbsp;todo_throws_ok { 'pop @push' }, '?? what should this error message be ??', 'cannot push onto a Inf array';
#}</pre>
</div>


<pre> our Scalar multi Array::pop ( @array is rw )
 our Scalar multi method Array::pop ( @array: )</pre>

<p>Remove the last element of <code>@array</code> and return it.</p>

<dt><a name="push"
>push</a></dt>

<dd>
<a href="#" onclick="return tog_quote(5);">
<div ID="header_shown_5" style="display: none;">
- Hide the snippet from t/builtins/arrays/push.t (line 4 ~ line 130) -
</div>
<div ID="header_hidden_5" style="display: block;">
- Show the snippet from t/builtins/arrays/push.t (line 4 ~ line 130) -
</div>
</a>
<div ID="hide_5" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Array&quot;/&quot;=item push&quot;&gt;

=kwid

Push tests

=cut

plan 42;

# basic push tests
{
&nbsp; &nbsp; my @push = ();

&nbsp; &nbsp; is(+@push, 0, 'we have an empty array');

&nbsp; &nbsp; push(@push, 1);
&nbsp; &nbsp; is(+@push, 1, 'we have 1 element in the array');
&nbsp; &nbsp; is(@push[0], 1, 'we found the right element');

&nbsp; &nbsp; push(@push, 2);
&nbsp; &nbsp; is(+@push, 2, 'we have 2 elements in the array');
&nbsp; &nbsp; is(@push[1], 2, 'we found the right element');

&nbsp; &nbsp; push(@push, 3);
&nbsp; &nbsp; is(+@push, 3, 'we have 3 element in the array');
&nbsp; &nbsp; is(@push[2], 3, 'we found the right element');

&nbsp; &nbsp; push(@push, 4);
&nbsp; &nbsp; is(+@push, 4, 'we have 4 element in the array');
&nbsp; &nbsp; is(@push[3], 4, 'we found the right element');
}

# try other variations on calling push()
{
&nbsp; &nbsp; my @push = ();

&nbsp; &nbsp; my $val = 100;

&nbsp; &nbsp; push @push, $val;
&nbsp; &nbsp; is(+@push, 1, 'we have 1 element in the array');
&nbsp; &nbsp; is(@push[0], $val, 'push @array, $val worked');

&nbsp; &nbsp; @push.push(200);
&nbsp; &nbsp; is(+@push, 2, 'we have 2 elements in the array');
&nbsp; &nbsp; is(@push[1], 200, '@push.push(200) works');

&nbsp; &nbsp; @push.push(400);
&nbsp; &nbsp; is(+@push, 3, 'we have 3 elements in the array');
&nbsp; &nbsp; is(@push[2], 400, '@push.push(400) works');
}

# try pushing more than one element
{
&nbsp; &nbsp; my @push = ();

&nbsp; &nbsp; push @push, (1, 2, 3);
&nbsp; &nbsp; is(+@push, 3, 'we have 3 elements in the array');
&nbsp; &nbsp; is(@push[0], 1, 'got the expected element');
&nbsp; &nbsp; is(@push[1], 2, 'got the expected element');
&nbsp; &nbsp; is(@push[2], 3, 'got the expected element');

&nbsp; &nbsp; my @val2 = (4, 5);
&nbsp; &nbsp; push @push, @val2; &nbsp;
&nbsp; &nbsp; is(+@push, 5, 'we have 5 elements in the array');
&nbsp; &nbsp; is(@push[3], 4, 'got the expected element');
&nbsp; &nbsp; is(@push[4], 5, 'got the expected element');
&nbsp; &nbsp; 
&nbsp; &nbsp; push @push, 6, 7, 8; &nbsp;# push() should be slurpy
&nbsp; &nbsp; is(+@push, 8, 'we have 8 elements in the array');
&nbsp; &nbsp; is(@push[5], 6, 'got the expected element');
&nbsp; &nbsp; is(@push[6], 7, 'got the expected element'); &nbsp; &nbsp;
&nbsp; &nbsp; is(@push[7], 8, 'got the expected element'); &nbsp; &nbsp; &nbsp; &nbsp;
}

# now for the push() on an uninitialized array issue
{
&nbsp; &nbsp; my @push;

&nbsp; &nbsp; push @push, 42;
&nbsp; &nbsp; is(+@push, 1, 'we have 1 element in the array');
&nbsp; &nbsp; is(@push[0], 42, 'got the element expected');

&nbsp; &nbsp; @push.push(2000);
&nbsp; &nbsp; is(+@push, 2, 'we have 1 element in the array');
&nbsp; &nbsp; is(@push[0], 42, 'got the element expected');
&nbsp; &nbsp; is(@push[1], 2000, 'got the element expected');
}

# testing some edge cases
{
&nbsp; &nbsp; my @push = 0 .. 5;
&nbsp; &nbsp; is(+@push, 6, 'starting length is 6');
&nbsp; &nbsp; 
&nbsp; &nbsp; push(@push);
&nbsp; &nbsp; is(+@push, 6, 'length is still 6');
&nbsp; &nbsp; 
&nbsp; &nbsp; @push.push();
&nbsp; &nbsp; is(+@push, 6, 'length is still 6');
}

# testing some error cases
{
&nbsp; &nbsp; dies_ok({ push() &nbsp; &nbsp; }, 'push() requires arguments (1)');
&nbsp; &nbsp; # This one is okay, as push will push 0 elems to a rw arrayref.
&nbsp; &nbsp; lives_ok({ push([]) &nbsp;}, 'push() requires arguments (2)');
&nbsp; &nbsp; dies_ok({ 42.push(3) }, '.push should not work on scalars');
&nbsp; &nbsp; dies_ok({ my @r; @r.push&lt;hi&gt;; &nbsp;}, '.push&lt;hi&gt; should emit error.');
}

# Push with Inf arrays (waiting on answers to perl6-compiler email)
#{
# &nbsp; &nbsp;my @push = 1 .. Inf;
# &nbsp; &nbsp;# best not to uncomment this it just go on forever
# &nbsp; &nbsp;todo_throws_ok { 'push @push, 10' }, '?? what should this error message be ??', 'cannot push onto a Inf array';
#}

# nested arrayref
{
&nbsp; &nbsp; my @push;
&nbsp; &nbsp; push @push, [ 21 .. 25 ];

&nbsp; &nbsp; is(@push.elems, &nbsp; &nbsp; 1, 'nested arrayref, array length is 1');
&nbsp; &nbsp; is(@push[0].elems, &nbsp;5, 'nested arrayref, arrayref length is 5');
&nbsp; &nbsp; is(@push[0][0], &nbsp; &nbsp;21, 'nested arrayref, first value is 21');
&nbsp; &nbsp; is(@push[0][-1], &nbsp; 25, 'nested arrayref, last value is 25');
}</pre>
</div>


<pre> our Int multi Array::push ( @array is rw, *@values )
 our Int multi method Array::push ( @array: *@values )</pre>

<p>Add to the end of <code>@array</code>, all of the subsequent arguments.</p>

<dt><a name="shift"
>shift</a></dt>

<dd>
<a href="#" onclick="return tog_quote(4);">
<div ID="header_shown_4" style="display: none;">
- Hide the snippet from t/builtins/arrays/shift.t (line 4 ~ line 85) -
</div>
<div ID="header_hidden_4" style="display: block;">
- Show the snippet from t/builtins/arrays/shift.t (line 4 ~ line 85) -
</div>
</a>
<div ID="hide_4" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Array&quot;/&quot;=item shift&quot;&gt;

=kwid 

Shift tests

=cut

plan 27;

{

&nbsp; &nbsp; my @shift = (1, 2, 3, 4);

&nbsp; &nbsp; is(+@shift, 4, 'we have 4 elements in our array');
&nbsp; &nbsp; my $a = shift(@shift);
&nbsp; &nbsp; is($a, 1, 'shift(@shift) works');

&nbsp; &nbsp; is(+@shift, 3, 'we have 3 elements in our array');
&nbsp; &nbsp; $a = shift @shift;
&nbsp; &nbsp; is($a, 2, 'shift @shift works');

&nbsp; &nbsp; is(+@shift, 2, 'we have 2 elements in our array');
&nbsp; &nbsp; $a = @shift.shift();
&nbsp; &nbsp; is($a, 3, '@shift.shift() works');

&nbsp; &nbsp; is(+@shift, 1, 'we have 1 element in our array');
&nbsp; &nbsp; $a = @shift.shift;
&nbsp; &nbsp; is($a, 4, '@shift.shift() works');

&nbsp; &nbsp; is(+@shift, 0, 'we have no elements in our array');
&nbsp; &nbsp; ok(!defined(shift(@shift)), 'after the array is exhausted it give undef');

}

{
&nbsp; &nbsp; my @shift = (1, 2, 3, 4);

&nbsp; &nbsp; is(+@shift, 4, 'we have 4 elements in our array');
&nbsp; &nbsp; is(shift(@shift), 1, 'inline shift(@shift) works');

&nbsp; &nbsp; is(+@shift, 3, 'we have 3 elements in our array');
&nbsp; &nbsp; is(shift @shift, 2, 'inline shift @shift works');

&nbsp; &nbsp; is(+@shift, 2, 'we have 2 elements in our array');
&nbsp; &nbsp; is(@shift.shift(), 3, 'inline @shift.shift() works');

&nbsp; &nbsp; is(+@shift, 1, 'we have 1 elements in our array');
&nbsp; &nbsp; is(@shift.shift, 4, 'inline @shift.shift works');

&nbsp; &nbsp; is(+@shift, 0, 'we have no elements in our array');
&nbsp; &nbsp; ok(!defined(shift(@shift)), 'again, the array is exhausted and we get undef');
}

# invocant syntax with inline arrays
{
&nbsp; &nbsp; is([1, 2, 3].shift, 1, 'this will return 1');
&nbsp; &nbsp; ok(!defined([].shift), 'this will return undef'); &nbsp; &nbsp;
}

# testing some edge cases
{
&nbsp; &nbsp; my @shift;
&nbsp; &nbsp; ok(!defined(shift(@shift)), 'shift on an empty array returns undef');
}

# testing some error cases
{
&nbsp; &nbsp; my @shift = 1 .. 5;
&nbsp; &nbsp; dies_ok({ shift() &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }, 'shift() requires arguments'); &nbsp; &nbsp;
&nbsp; &nbsp; dies_ok({ shift(@shift, 10) }, 'shift() should not allow extra arguments'); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; dies_ok({ @shift.shift(10) &nbsp;}, 'shift() should not allow extra arguments'); &nbsp; &nbsp; 
&nbsp; &nbsp; dies_ok({ 42.shift &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}, '.shift should not work on scalars');
}

# Push with Inf arrays (waiting on answers to perl6-compiler email)
#{
# &nbsp; &nbsp;my @shift = 1 .. Inf;
# &nbsp; &nbsp;# best not to uncomment this it just go on forever
# &nbsp; &nbsp;todo_throws_ok { 'shift(@shift)' }, '?? what should this error message be ??', 'cannot shift off of a Inf array';
#}</pre>
</div>


<pre> our Scalar multi Array::shift ( @array is rw  )
 our Scalar multi method Array::shift ( @array:  )</pre>

<p>Remove the first element from <code>@array</code> and return it.</p>

<dt><a name="splice"
>splice</a></dt>

<dd>
<a href="#" onclick="return tog_quote(3);">
<div ID="header_shown_3" style="display: none;">
- Hide the snippet from t/builtins/arrays/splice.t (line 4 ~ line 138) -
</div>
<div ID="header_hidden_3" style="display: block;">
- Show the snippet from t/builtins/arrays/splice.t (line 4 ~ line 138) -
</div>
</a>
<div ID="hide_3" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Array&quot;/&quot;=item splice&quot;&gt;

=head1 DESCRIPTION

This test tests the C&lt;splice&gt; builtin, see S29 and Perl 5's perlfunc.

Ported from the equivalent Perl 5 test.

This test includes a test for the single argument form of
C&lt;splice&gt;. Depending on whether the single argument form
of C&lt;splice&gt; should survive or not, this test should be dropped.

&nbsp; my @a = (1..10);
&nbsp; splice @a;

is equivalent to:

&nbsp; my @a = (1..10);
&nbsp; @a = ();

=cut

plan 33;

my (@a,@b,@res);

# Somehow, this doesn't propagate array context
# to splice(). The intermediate array in the calls
# should be removed later

sub splice_ok (Array @got, Array @ref, Array @exp, Array @exp_ref, Str $comment) {
&nbsp; is &quot;[@got[]]&quot;, &quot;[@exp[]]&quot;, &quot;$comment - results match&quot;;
&nbsp; is @ref, @exp_ref, &quot;$comment - array got modified in-place&quot;;

&nbsp; # Once we get Test::Builder, this will be better:
&nbsp; #if ( (@got ~~ @exp) and (@ref ~~ @exp_ref)) {
&nbsp; # &nbsp;flunk($comment);
&nbsp; # &nbsp;if (@got !~~ @exp) {
&nbsp; # &nbsp; &nbsp;diag &quot;The returned result is wrong:&quot;;
&nbsp; # &nbsp; &nbsp;diag &quot; &nbsp;Expected: @exp&quot;;
&nbsp; # &nbsp; &nbsp;diag &quot; &nbsp;Got &nbsp; &nbsp; : @got&quot;;
&nbsp; # &nbsp;};
&nbsp; # &nbsp;if (@ref !~~ @exp_ref) {
&nbsp; # &nbsp; &nbsp;diag &quot;The modified array is wrong:&quot;;
&nbsp; # &nbsp; &nbsp;diag &quot; &nbsp;Expected: @exp_ref&quot;;
&nbsp; # &nbsp; &nbsp;diag &quot; &nbsp;Got &nbsp; &nbsp; : @exp&quot;;
&nbsp; # &nbsp;};
&nbsp; #} else {
&nbsp; # &nbsp;ok($comment);
&nbsp; #};
};

@a = (1..10);
@b = splice(@a,+@a,0,11,12);

is( @b, [], &quot;push-via-splice result works&quot; );
is( @a, ([1..12]), &quot;push-via-splice modification works&quot;);

@a &nbsp;= ('red', 'green', 'blue');
is( splice(@a, 1, 2), &quot;blue&quot;, &quot;splice() in scalar context returns last element of array&quot;);

# Test the single arg form of splice (which should die IMO)
@a = (1..10);
@res = splice(@a);
splice_ok( @res, @a, [1..10],[], &quot;Single-arg splice returns the whole array&quot; );

@a = (1..10);
@res = splice(@a,8,2);
splice_ok( @res, @a, [9,10], [1..8], &quot;3-arg positive indices work&quot;);

@a = (1..12);
splice_ok splice(@a,0,1), @a, [1], [2..12], &quot;Simple 3-arg splice&quot;;

@a = (1..10);
@res = splice(@a,8);
splice_ok @res, @a, [9,10], [1..8], &quot;2-arg positive indices work&quot;;

@a = (1..10);
@res = splice(@a,-2,2);
splice_ok @res, @a, [9,10], [1..8], &quot;3-arg negative indices work&quot;;

@a = (1..10);
@res = splice(@a,-2);
splice_ok @res, @a, [9,10], [1..8], &quot;2-arg negative indices work&quot;;

# to be converted into more descriptive tests
@a = (2..10);
splice_ok splice(@a,0,0,0,1), @a, [], [0..10], &quot;Prepending values works&quot;;

# Need to convert these
# skip 5, &quot;Need to convert more tests from Perl5&quot;;
@a = (0..11);
splice_ok splice(@a,5,1,5), @a, [5], [0..11], &quot;Replacing an element with itself&quot;;

@a = (0..11);
splice_ok splice(@a, @a, 0, 12, 13), @a, [], [0..13], &quot;Appending a array&quot;;

@a = (0..13);
@res = splice(@a, -@a, @a, 1, 2, 3);
splice_ok @res, @a, [0..13], [1..3], &quot;Replacing the array contents from right end&quot;;

@a = (1, 2, 3);
splice_ok splice(@a, 1, -1, 7, 7), @a, [2], [1,7,7,3], &quot;Replacing a array into the middle&quot;;

@a = (1,7,7,3);
splice_ok splice(@a,-3,-2,2), @a, [7], [1,2,7,3], &quot;Replacing negative count of elements&quot;;

# Test the identity of calls to splice:
# See also t/builtins/want.t, for the same test in a different
# setting
sub indirect_slurpy_context( *@got ) { @got };


# splice4 gets &quot;CxtItem _&quot; or &quot;CxtArray _&quot; instead of &quot;CxtSlurpy _&quot;
my @tmp = (1..10);
@a = splice @tmp, 5, 3;
@a = indirect_slurpy_context( @a );
@tmp = (1..10);
@b = indirect_slurpy_context( splice @tmp, 5, 3 );
is( @b, @a, &quot;Calling splice with immediate and indirect context returns consistent results&quot; );
is( @a, [6,7,8], &quot;Explicit call/assignment gives the expected results&quot;);
is( @b, [6,7,8], &quot;Implicit context gives the expected results&quot; );

my @tmp = (1..10);
@a = item splice @tmp, 5, 3;
is( @a, [8], &quot;Explicit scalar context returns the last element&quot;);

## test some error conditions

@a = splice([], 1);
is +@a, 0, '... empty arrays are not fatal anymore';
# But this should generate a warning, but unfortunately we can't test for
# warnings yet.

dies_ok({ 42.splice }, '.splice should not work on scalars', :todo&lt;bug&gt;);</pre>
</div>


<pre> our List multi Array::splice( @array is rw, Int $offset = 0, Int $size?, *@values )</pre>

<p><code>splice</code> fills many niches in array-management, but its fundamental behavior is to remove zero or more elements from an array and replace them with a new (and potentially empty) list. This operation can shorten or lengthen the target array.</p>

<p><code>$offset</code> is the index of the array element to start with. It defaults to <code>0</code>.</p>

<p><code>$size</code> is the number of elements to remove from <code>@array</code>. It defaults to removing the rest of the array from <code>$offset</code> on.</p>

<p>The slurpy list of values (if any) is then inserted at <code>$offset</code>.</p>

<p>Calling splice with a traditional parameter list, you must define <code>$offset</code> and <code>$size</code> if you wish to pass a replacement list of values. To avoid having to pass these otherwise optional parameters, use the piping operator(s):</p>

<pre> splice(@array,10) &#60;== 1..*;</pre>

<p>which replaces <code>@array[10]</code> and all subsequent elements with an infinite series starting at <code>1</code>.</p>

<p>This behaves similarly to Perl 5&#39;s <code>splice</code>.</p>

<p>If <code>@array</code> is multidimensional, <code>splice</code> operates only on the first dimension, and works with Array References.</p>

<dt><a name="unshift"
>unshift</a></dt>

<dd>
<a href="#" onclick="return tog_quote(2);">
<div ID="header_shown_2" style="display: none;">
- Hide the snippet from t/builtins/arrays/unshift.t (line 4 ~ line 137) -
</div>
<div ID="header_hidden_2" style="display: block;">
- Show the snippet from t/builtins/arrays/unshift.t (line 4 ~ line 137) -
</div>
</a>
<div ID="hide_2" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Array&quot;/&quot;=item unshift&quot;&gt;

=kwid

Unshift tests

=cut

plan 53;

# basic unshift tests

{
&nbsp; &nbsp; my @unshift = ();

&nbsp; &nbsp; is(+@unshift, 0, 'we have an empty array');

&nbsp; &nbsp; unshift(@unshift, 1);
&nbsp; &nbsp; is(+@unshift, 1, 'we have 1 element in the array');
&nbsp; &nbsp; is(@unshift[0], 1, 'we found the right element');

&nbsp; &nbsp; unshift(@unshift, 2);
&nbsp; &nbsp; is(+@unshift, 2, 'we have 2 elements in the array');
&nbsp; &nbsp; is(@unshift[0], 2, 'we found the right element');
&nbsp; &nbsp; is(@unshift[1], 1, 'we found the right element');

&nbsp; &nbsp; unshift(@unshift, 3);
&nbsp; &nbsp; is(+@unshift, 3, 'we have 3 element in the array');
&nbsp; &nbsp; is(@unshift[0], 3, 'we found the right element');
&nbsp; &nbsp; is(@unshift[1], 2, 'we found the right element');
&nbsp; &nbsp; is(@unshift[2], 1, 'we found the right element');

&nbsp; &nbsp; unshift(@unshift, 4);
&nbsp; &nbsp; is(+@unshift, 4, 'we have 4 element in the array');
&nbsp; &nbsp; is(@unshift[0], 4, 'we found the right element');
&nbsp; &nbsp; is(@unshift[1], 3, 'we found the right element');
&nbsp; &nbsp; is(@unshift[2], 2, 'we found the right element');
&nbsp; &nbsp; is(@unshift[3], 1, 'we found the right element');
}

# try other variations on calling unshift()

{
&nbsp; &nbsp; my @unshift = ();

&nbsp; &nbsp; my $val = 100;

&nbsp; &nbsp; unshift @unshift, $val;
&nbsp; &nbsp; is(+@unshift, 1, 'we have 1 element in the array');
&nbsp; &nbsp; is(@unshift[0], $val, 'unshift @array, $val worked');

&nbsp; &nbsp; @unshift.unshift(200);
&nbsp; &nbsp; is(+@unshift, 2, 'we have 2 elements in the array');
&nbsp; &nbsp; is(@unshift[0], 200, '@unshift.unshift(200) works');
&nbsp; &nbsp; is(@unshift[1], $val, 'unshift @array, $val worked');

&nbsp; &nbsp; @unshift.unshift(400);
&nbsp; &nbsp; is(+@unshift, 3, 'we have 3 elements in the array');
&nbsp; &nbsp; is(@unshift[0], 400, '@unshift.unshift(400) works');
&nbsp; &nbsp; is(@unshift[1], 200, '@unshift.unshift(200) works');
&nbsp; &nbsp; is(@unshift[2], $val, 'unshift @array, $val worked');
}

# try unshifting more than one element

{
&nbsp; &nbsp; my @unshift = ();

&nbsp; &nbsp; unshift @unshift, (1, 2, 3);
&nbsp; &nbsp; is(+@unshift, 3, 'we have 3 elements in the array');
&nbsp; &nbsp; is(@unshift[0], 1, 'got the expected element');
&nbsp; &nbsp; is(@unshift[1], 2, 'got the expected element');
&nbsp; &nbsp; is(@unshift[2], 3, 'got the expected element');

&nbsp; &nbsp; my @val2 = (4, 5);
&nbsp; &nbsp; unshift @unshift, @val2; &nbsp;
&nbsp; &nbsp; is(+@unshift, 5, 'we have 5 elements in the array');
&nbsp; &nbsp; is(@unshift[0], 4, 'got the expected element');
&nbsp; &nbsp; is(@unshift[1], 5, 'got the expected element');
&nbsp; &nbsp; is(@unshift[2], 1, 'got the expected element');
&nbsp; &nbsp; is(@unshift[3], 2, 'got the expected element');
&nbsp; &nbsp; is(@unshift[4], 3, 'got the expected element');
&nbsp; &nbsp; 
&nbsp; &nbsp; unshift @unshift, 6, 7, 8; &nbsp;
&nbsp; &nbsp; is(+@unshift, 8, 'we have 8 elements in the array');
&nbsp; &nbsp; is(@unshift[0], 6, 'got the expected element');
&nbsp; &nbsp; is(@unshift[1], 7, 'got the expected element');
&nbsp; &nbsp; is(@unshift[2], 8, 'got the expected element');
&nbsp; &nbsp; is(@unshift[3], 4, 'got the expected element');
&nbsp; &nbsp; is(@unshift[4], 5, 'got the expected element');
&nbsp; &nbsp; is(@unshift[5], 1, 'got the expected element');
&nbsp; &nbsp; is(@unshift[6], 2, 'got the expected element');
&nbsp; &nbsp; is(@unshift[7], 3, 'got the expected element'); &nbsp; &nbsp;
}

# now for the unshift() on an uninitialized array issue

{
&nbsp; &nbsp; my @unshift;

&nbsp; &nbsp; unshift @unshift, 42;
&nbsp; &nbsp; is(+@unshift, 1, 'we have 1 element in the array');
&nbsp; &nbsp; is(@unshift[0], 42, 'got the element expected');

&nbsp; &nbsp; unshift @unshift, 2000;
&nbsp; &nbsp; is(+@unshift, 2, 'we have 1 element in the array');
&nbsp; &nbsp; is(@unshift[0], 2000, 'got the element expected');
&nbsp; &nbsp; is(@unshift[1], 42, 'got the element expected');
}

# testing some edge cases
{
&nbsp; &nbsp; my @unshift = 0 .. 5;
&nbsp; &nbsp; is(+@unshift, 6, 'starting length is 6');
&nbsp; &nbsp; 
&nbsp; &nbsp; unshift(@unshift);
&nbsp; &nbsp; is(+@unshift, 6, 'length is still 6');
&nbsp; &nbsp; 
&nbsp; &nbsp; @unshift.push();
&nbsp; &nbsp; is(+@unshift, 6, 'length is still 6');
}

# testing some error cases
{
&nbsp; &nbsp; dies_ok({ unshift() &nbsp; &nbsp; }, 'unshift() requires arguments'); &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; dies_ok({ 42.unshift(3) }, '.unshift should not work on scalars');
}

# Push with Inf arrays (waiting on answers to perl6-compiler email)
#{
# &nbsp; &nbsp;my @unshift = 1 .. Inf;
# &nbsp; &nbsp;# best not to uncomment this it just go on forever
# &nbsp; &nbsp;todo_throws_ok { 'unshift @unshift, 10' }, '?? what should this error message be ??', 'cannot unshift onto a Inf array';
#}</pre>
</div>


<pre> our Int multi Array::unshift ( @array is rw, *@values )
 our Int multi method Array::unshift ( @array: *@values )</pre>

<p><code>unshift</code> adds the values onto the start of the <code>@array</code>.</p>

<dt><a name="keys"
>keys
<dt><a name="kv"
>kv
<dt><a name="pairs"
>pairs
<dt><a name="values"
>values</a></dt>

<dd>
<pre> multi Int|List Array::keys ( @array ; MatchTest *@indextests )
 multi Int|List Array::kv ( @array ; MatchTest *@indextests )
 multi Int|(List of Pair) Array::pairs  (@array ; MatchTest *@indextests )
 multi Int|List Array::values ( @array ; MatchTest *@indextests )</pre>

<p>(XXX these signatures are wrong. -luqui)</p>

<p>Iterates the elements of <code>@array</code>, in order.</p>

<p>If <code>@indextests</code> are provided, only elements whose indices match <code>$index ~~ any(@indextests)</code> are iterated.</p>

<p>What is returned at each element of the iteration varies with function. <code>values</code> returns the value of the associated element; <code>kv</code> returns a 2 element list in (index, value) order, <code>pairs</code> a <code>Pair(index, value)</code>.</p>

<p><code>@array</code> is considered single dimensional. If it is in fact multi-dimensional, the values returned will be array references to the sub array.</p>

<p>In Scalar context, they all return the count of elements that would have been iterated.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="List"
>List</a></h2>

<dl>
<dt><a name="grep"
>grep</a></dt>

<dd>
<pre> our Lazy multi Array::grep ( @values, Code *&#38;test )
 our Lazy multi Array::grep ( @values, MatchTest $test )
 our Lazy multi List::grep ( MatchTest $test, *@values )</pre>

<p><code>grep</code> takes a list or array of values and returns a lazily evaluated list comprised of all of the values from the original list for which the <code>$test</code> smart-matches as true.</p>

<p>Here is an example of its use:</p>

<pre> @friends = grep { .is_friend } @coworkers;</pre>

<p>This takes the array <code>@coworkers</code>, checks every element to see which ones return true for the <code>.is_friend</code> method, and returns the resulting list to store into <code>@friends</code>.</p>

<dt><a name="join"
>join</a></dt>

<dd>
<pre> our Str multi Array::join ( @values, Str $separator? )
 our Str multi List::join ( Str $separator?, *@values )</pre>

<p><code>join</code> returns a single string comprised of all of the elements of <code>@values</code>, separated by <code>$separator</code>. The separator defaults to a single space.</p>

<p>Given an empty list, <code>join</code> returns the empty string.</p>

<dt><a name="map"
>map</a></dt>

<dd>
<pre> our Lazy multi Array::map ( @values, Code *&#38;expression )
 our Lazy multi List::map ( Code $expression?, *@values )</pre>

<p><code>map</code> returns a lazily evaluated list which is comprised of the return value of the expression, evaluated once for every one of the <code>@values</code> that are passed in.</p>

<p>Here is an example of its use:</p>

<pre> @addresses = map { %addresses_by_name&#60;$_&#62; } @names;</pre>

<p>Here we take an array of names, and look each name up in <code>%addresses_by_name</code> in order to build the corresponding list of addresses.</p>

<p>If the expression returns no values or multiple values, then the resulting list may not be the same length as the number of values that were passed. For example:</p>

<pre> @factors = map { prime_factors($_) } @composites;</pre>

<dt><a name="reduce"
>reduce</a></dt>

<dd>
<pre> our Scalar multi Array::reduce ( @values ; Code *&#38;expression )
 our Scalar multi List::reduce ( Code $expression ; *@values )
   my $res;
   for @values -&#62; $cur {
     FIRST {$res = $cur; next;}
     $res = &#38;$expression($res, $cur);
   }
   $res;
 }</pre>

<dt><a name="reverse"
>reverse</a></dt>

<dd>
<a href="#" onclick="return tog_quote(1);">
<div ID="header_shown_1" style="display: none;">
- Hide the snippet from t/builtins/strings/reverse.t (line 4 ~ line 33) -
</div>
<div ID="header_hidden_1" style="display: block;">
- Show the snippet from t/builtins/strings/reverse.t (line 4 ~ line 33) -
</div>
</a>
<div ID="hide_1" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/List/&quot;=item reverse&quot;&gt;

=pod

Basic test for the reverse() builtin with a string (Str).

=cut

plan 8;

#as a function :
is( reverse('Pugs'), 'sguP', &quot;as a function&quot;);

#as a method :
is( &quot;&quot;.reverse, &quot;&quot;, &quot;empty string&quot; );
is( 'Hello World !'.reverse, '! dlroW olleH', &quot;literal&quot; );

#on a variable ?
my Str $a = 'Hello World !';
is( $a.reverse, '! dlroW olleH', &quot;with a Str variable&quot; );
is( $a, 'Hello World !', &quot;reverse should not be in-place&quot; );
is( $a .= reverse, '! dlroW olleH', &quot;after a .=reverse&quot; );

#multiple iterations (don't work in 6.2.12) :
is( 'Hello World !'.reverse.reverse, 'Hello World !', 
&nbsp; &nbsp; &nbsp; &nbsp; &quot;two reverse in a row.&quot; );
&nbsp; &nbsp; &nbsp; &nbsp; 
#reverse with unicode :
is( ''.reverse, &nbsp; '', &quot;some unicode characters&quot; );</pre>
</div>


<pre> our Hash multi Hash::reverse ( %hash ) {
   (my %result){%hash.values} = %hash.keys;
   %result;
 }

 multi Lazy Array::reverse ( @values )
 multi Lazy List::reverse ( *@values ) {
    gather {
        1 while take pop @values;
    }
 }

 multi Str Str::reverse ( $str ) {
    split(&#39;&#39;, $str).reverse.join
 )</pre>

<dt><a name="sort"
>sort</a></dt>

<dd>
<pre> subset KeyExtractor of Code(Any --&#62; Any);
 subset Comparator   of Code(Any, Any --&#62; Int );
 subset SortCriterion of KeyExtractor | Comparator | Pair(KeyExtractor, Comparator);

 our Array multi Array::sort( @values is rw, *&#38;by, Bit $inplace? )
 our Array multi Array::sort( @values is rw, SortCriterion @by, Bit $inplace? )
 our Array multi Array::sort( @values is rw, SortCriterion $by = &#38;infix:&#60;cmp&#62;, Bit $inplace? )

 our List multi List::sort( SortCriterion @by,  *@values )
 our List multi List::sort( SortCriterion $by = &#38;infix:&#60;cmp&#62;, *@values )</pre>

<p>Returns <code>@values</code> sorted, using criteria <code>$by</code> or <code>@by</code> for comparisons. <code>@by</code> differs from <code>$by</code> in that each criteria is applied, in order, until a non-zero (tie) result is achieved.</p>

<p>Criterion can take a few different forms:</p>

<dl>
<dt><a name="Comparator"
>Comparator</a></dt>

<dd>
<p>A closure with arity of 2, which returns negative/zero/positive, signaling the first argument should be before/tied with/after the second in the final ordering of the List. aka &#34;The Perl 5 way&#34;</p>

<dt><a name="KeyExtractor"
>KeyExtractor</a></dt>

<dd>
<p>A closure with arity of 1, which returns the &#34;key&#34; by which to sort. If the closure returns a Num, <code>&#60;=&#62;</code> is used for comparison, otherwise <code>cmp</code>.</p>

<dt><a name="Pair(KeyExtractor,_Comparator)"
>Pair(KeyExtractor, Comparator)</a></dt>

<dd>
<p>A combination of the two methods above, for when one wishes to take advantage of the internal caching of keys that is expected to happen, but wishes to compare them with something other than <code>&#60;=&#62;</code> or <code>cmp</code>.</p>
</dd>
</dl>

<p>Any Criterion may receive either or both of the traits <code>is descending</code> and <code>is insensitive</code> to reverse the order of sort, or the adjust the case sensitivity of <code>cmp</code> as a Comparator.</p>

<p>If all criteria are exhausted when comparing two elements, sort should return them in the same relative order they had in <code>@values</code>.</p>

<p>If <code>$inplace</code> is specified, the array is sorted in place.</p>

<p>See <a href="http://www.nntp.perl.org/group/perl.perl6.language/16578" class="podlinkurl"
>http://www.nntp.perl.org/group/perl.perl6.language/16578</a> for more details and examples.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Hash"
>Hash</a></h2>

<dl>
<dt><a name="delete"
>delete</a></dt>

<dd>
<pre> our List  multi method Hash::delete ( *@keys )
 our Scalar multi method Hash::delete ( $key ) is default</pre>

<p>Deletes the elements specified by <code>$key</code> or <code>$keys</code> from the invocant. returns the value(s) that were associated to those keys.</p>

<dl>
<dt><a name="Unary_Form"
>Unary Form</a></dt>

<dd>
<p>Implementations should create a suitable macro, or otherwise support the unary form <code>delete %hash{$key}</code> in all its forms. Below are some example translations. This list is <i>not</i> exhaustive.</p>

<pre> delete %hash{$key}                %hash.delete{$key}
 delete %hash&#60;key&#62;                 %hash.delete{&#39;key&#39;}
 delete %hash&#60;key1&#62;{@keys}         %hash&#60;key1&#62;.delete{@keys}</pre>
</dd>
</dl>

<dt><a name="exists"
>exists</a></dt>

<dd>
<pre> our Bool multi method Hash::exists ( $key )</pre>

<p>True if invocant has an element whose key matches <code>$key</code>, false otherwise.</p>

<p>A unary form is expected. See Hash::delete.</p>

<p>See also Code::exists to determine if a function has been declared. (Use defined() to determine whether the function body is defined. A body of ... counts as undefined.)</p>

<dt><a name="keys"
>keys
<dt><a name="kv"
>kv
<dt><a name="pairs"
>pairs
<dt><a name="values"
>values</a></dt>

<dd>
<pre> multi Int|List Hash::keys ( %hash ; MatchTest *@keytests )
 multi Int|List Hash::kv ( %hash ; MatchTest *@keytests )
 multi Int|(List of Pair) Hash::pairs  (%hash ; MatchTest *@keytests )
 multi Int|List Hash::values ( %hash ; MatchTest *@keytests )</pre>

<p>Iterates the elements of <code>%hash</code> in no apparent order, but the order will be the same between successive calls to these functions, as long as <code>%hash</code> doesn&#39;t change.</p>

<p>If <code>@keytests</code> are provided, only elements whose keys evaluate <code>$key ~~ any(@keytests)</code> as true are iterated.</p>

<p>What is returned at each element of the iteration varies with function. <code>keys</code> only returns the key; <code>values</code> the value; <code>kv</code> returns both as a 2 element list in (key, value) order, <code>pairs</code> a <code>Pair(key, value)</code>.</p>

<p>Note that <code>kv %hash</code> returns the same as <code>zip(keys %hash; values %hash)</code></p>

<p>In Scalar context, they all return the count of elements that would have been iterated.</p>

<p>The lvalue form of <code>keys</code> is not longer supported. Use the <code>.buckets</code> property instead.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Str"
>Str</a></h2>

<p>General notes about strings:</p>

<p>A Str can exist at several Unicode levels at once. Which level you interact with typically depends on what your current lexical context has declared the &#34;working Unicode level to be&#34;. Default is GChar.</p>

<p>[Q: Default can&#39;t be LChar because we don&#39;t go into &#34;language&#34; mode unless there&#39;s a specific language declaration saying either exactly what language we&#39;re going into, or what environmental parameter to pay attention to to select our language. So I believe the default should be GChar. -law]</p>

<p>Attempting to use a string at a level higher it can support is handled without warning. The current highest supported level of the string is simply mapped Char for Char to the new higher level. However, attempting to stuff something of a higher level a lower-level string is an error (for example, attempting to store Kanji in a Byte string). And explicit conversion function must be used to tell it how you want it encoded.</p>

<p>Attempting to use a string at a level lower than what it supports is not allowed.</p>

<p>If a function takes a <code>Str</code> and returns a <code>Str</code>, the returned <code>Str</code> will support the same levels as the input, unless specified otherwise.</p>

<dl>
<dt><a name="p5chop"
>p5chop</a></dt>

<dd>
<pre> our Char multi P5emul::Str::p5chop ( Str  $string is rw )
 our Char multi P5emul::Str::p5chop ( Str *@strings = ($+_) is rw )</pre>

<p>Trims the last character from <code>$string</code>, and returns it. Called with a list, it chops each item in turn, and returns the last character chopped.</p>

<dt><a name="chop"
>chop</a></dt>

<dd>
<pre> our Str method Str::chop ( Str  $string: )</pre>

<p>Returns string with one Char removed from the end.</p>

<dt><a name="p5chomp"
>p5chomp</a></dt>

<dd>
<a href="#" onclick="return tog_quote(24);">
<div ID="header_shown_24" style="display: none;">
- Hide the snippet from t/builtins/arrays/chomp.t (line 13 ~ line 37) -
</div>
<div ID="header_hidden_24" style="display: block;">
- Show the snippet from t/builtins/arrays/chomp.t (line 13 ~ line 37) -
</div>
</a>
<div ID="hide_24" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /chomp/&gt;
# Also see L&lt;<a href="http://use.perl.org/~autrijus/journal/25351">&quot;http://use.perl.org/~autrijus/journal/25351&quot;</a>&gt;
# &nbsp; &amp;chomp and &amp;wrap are now nondestructive; chomp returns the chomped part,
# &nbsp; which can be defined by the filehandle that obtains the default string at
# &nbsp; the first place. To get destructive behaviour, use the .= form.
# Since currently the behaviour with regards to arrays is not defined, I'm
# assuming the correct behaviour is an extension of the behaviour for
# a single string.

{
&nbsp; &nbsp; my @foo = (&quot;foo\n&quot;,&quot;bar\n&quot;,&quot;baz\n&quot;);
&nbsp; &nbsp; chomp(@foo);
&nbsp; &nbsp; is(@foo[0], &quot;foo\n&quot;, '1st element was not yet chomped');
&nbsp; &nbsp; is(@foo[1], &quot;bar\n&quot;, '2nd element was not yet chomped');
&nbsp; &nbsp; is(@foo[2], &quot;baz\n&quot;, '3rd element was not yet chomped');
&nbsp; &nbsp; @foo .= chomp;
&nbsp; &nbsp; is(@foo[0], 'foo', '1st element chomped correctly');
&nbsp; &nbsp; is(@foo[1], 'bar', '2nd element chomped correctly');
&nbsp; &nbsp; is(@foo[2], 'baz', '3rd element chomped correctly');
&nbsp; &nbsp; @foo .= chomp;
&nbsp; &nbsp; is(@foo[0], 'foo', '1st element is chomped again with no effect');
&nbsp; &nbsp; is(@foo[1], 'bar', '2nd element is chomped again with no effect');
&nbsp; &nbsp; is(@foo[2], 'baz', '3rd element is chomped again with no effect');
}</pre>
</div>


<a href="#" onclick="return tog_quote(22);">
<div ID="header_shown_22" style="display: none;">
- Hide the snippet from t/builtins/strings/chomp.t (line 13 ~ line 116) -
</div>
<div ID="header_hidden_22" style="display: block;">
- Show the snippet from t/builtins/strings/chomp.t (line 13 ~ line 116) -
</div>
</a>
<div ID="hide_22" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /chomp/&gt;
# Also see L&lt;<a href="http://use.perl.org/~autrijus/journal/25351">&quot;http://use.perl.org/~autrijus/journal/25351&quot;</a>&gt;
# &nbsp; &amp;chomp and &amp;wrap are now nondestructive; chomp returns the chomped part,
# &nbsp; which can be defined by the filehandle that obtains the default string at
# &nbsp; the first place. To get destructive behaviour, use the .= form.

{
&nbsp; &nbsp; my $foo = &quot;foo\n&quot;;
&nbsp; &nbsp; chomp($foo);
&nbsp; &nbsp; is($foo, &quot;foo\n&quot;, 'our variable was not yet chomped');
&nbsp; &nbsp; $foo .= chomp;
&nbsp; &nbsp; is($foo, 'foo', 'our variable is chomped correctly');
&nbsp; &nbsp; $foo .= chomp;
&nbsp; &nbsp; is($foo, 'foo', 'our variable is chomped again with no effect');
}

{
&nbsp; &nbsp; my $foo = &quot;foo\n\n&quot;;
&nbsp; &nbsp; $foo .= chomp;
&nbsp; &nbsp; is($foo, &quot;foo\n&quot;, 'our variable is chomped correctly');
&nbsp; &nbsp; $foo .= chomp;
&nbsp; &nbsp; is($foo, 'foo', 'our variable is chomped again correctly');
&nbsp; &nbsp; $foo .= chomp;
&nbsp; &nbsp; is($foo, 'foo', 'our variable is chomped again with no effect');
}

{
&nbsp; &nbsp; my $foo = &quot;foo\nbar\n&quot;;
&nbsp; &nbsp; $foo .= chomp;
&nbsp; &nbsp; is($foo, &quot;foo\nbar&quot;, 'our variable is chomped correctly');
&nbsp; &nbsp; $foo .= chomp;
&nbsp; &nbsp; is($foo, &quot;foo\nbar&quot;, 'our variable is chomped again with no effect');
}

{
&nbsp; &nbsp; my $foo = &quot;foo\n &quot;;
&nbsp; &nbsp; $foo .= chomp;
&nbsp; &nbsp; is($foo, &quot;foo\n &quot;, 'our variable is chomped with no effect');
}

{
&nbsp; &nbsp; my $foo = &quot;foo\n&quot;;
&nbsp; &nbsp; my $chomped_foo = try { chomp($foo).newline };
&nbsp; &nbsp; is($chomped_foo, &quot;\n&quot;, 'chomp(...).newline returns the chomped value', :todo&lt;feature&gt;);
&nbsp; &nbsp; is($foo, &quot;foo\n&quot;, 'and our variable was not chomped');
}

{
&nbsp; &nbsp; my $foo = &quot;foo\n&quot;;
&nbsp; &nbsp; $foo .= chomp;
&nbsp; &nbsp; my $chomped_foo = try { $foo.newline };
&nbsp; &nbsp; is($chomped_foo, &quot;\n&quot;, 'chomp(...).newline returns the chomped value', :todo&lt;feature&gt;);
&nbsp; &nbsp; is($foo, &quot;foo&quot;, 'and our variable was chomped');
}

{
&nbsp; &nbsp; my $foo = &quot;foo\n\n&quot;;
&nbsp; &nbsp; my $chomped = $foo.chomp;
&nbsp; &nbsp; is($foo, &quot;foo\n\n&quot;, &quot;.chomp has no effect on the original string&quot;);
&nbsp; &nbsp; is($chomped, &quot;foo\n&quot;, &quot;.chomp returns correctly chomped value&quot;);
&nbsp; &nbsp; 
&nbsp; &nbsp; # $chomped.chomp.newline

&nbsp; &nbsp; $chomped = $chomped.chomp;
&nbsp; &nbsp; is($chomped, &quot;foo&quot;, &quot;.chomp returns correctly chomped value again&quot;);
}

# chomp in list context
{
&nbsp; &nbsp; is_deeply(chomp(()), [], &quot;chomp on empty list&quot;);
&nbsp; &nbsp; is_deeply(chomp((&quot;abc\n&quot;)), (&quot;abc&quot;), &quot;one element list&quot;);
&nbsp; &nbsp; is_deeply(chomp((&quot;abc\n&quot;, &quot;bcd\n&quot;)), (&quot;abc&quot;, &quot;bcd&quot;), &quot;two element list&quot;);
&nbsp; &nbsp; is_deeply((&quot;abc\n&quot;, &quot;bcd\n&quot;).chomp, (&quot;abc&quot;, &quot;bcd&quot;), &quot;two element list&quot;);
}
{
&nbsp; &nbsp; my @foo = ();
&nbsp; &nbsp; my @bar = chomp @foo;
&nbsp; &nbsp; is_deeply(@bar, @foo, &quot;chomp empty array&quot;);
}
{
&nbsp; &nbsp; my @foo = (&quot;abc\n&quot;);
&nbsp; &nbsp; my @bar = chomp @foo;
&nbsp; &nbsp; my @baz = (&quot;abc&quot;);
&nbsp; &nbsp; is_deeply(@bar, @baz, &quot;chomp array with one element&quot;);
}
{
&nbsp; &nbsp; my @foo = (&quot;abc\n&quot;, &quot;bcd\n&quot;);
&nbsp; &nbsp; my @bar = chomp @foo;
&nbsp; &nbsp; my @baz = (&quot;abc&quot;, &quot;bcd&quot;);
&nbsp; &nbsp; is_deeply(@bar, @baz, &quot;chomp array with 2 elements&quot;);


&nbsp; &nbsp; @bar = @foo.chomp;
&nbsp; &nbsp; is_deeply(@bar, @baz, &quot;chomp array with 2 elements&quot;);

&nbsp; &nbsp; my @morgo = (&quot;abc\n\n&quot;, &quot;bcd\n\n&quot;);
&nbsp; &nbsp; my @hapci = chomp @morgo;
&nbsp; &nbsp; is_deeply(@hapci, @foo, &quot;chomp array with 2 elements with duplicate newlines&quot;);

&nbsp; &nbsp; my @szundi = @morgo.chomp;
&nbsp; &nbsp; is_deeply(@szundi, @foo, &quot;chomp array with 2 elements with duplicate newlines&quot;);
}</pre>
</div>


<pre> our Int multi P5emul::Str::p5chomp ( Str  $string is rw )
 our Int multi P5emul::Str::p5chomp ( Str *@strings = ($+_) is rw )</pre>

<p>Related to <code>p5chop</code>, only removes trailing chars that match <code>/\n/</code>. In either case, it returns the number of chars removed.</p>

<dt><a name="chomp"
>chomp</a></dt>

<dd>
<pre> our Str method Str::chomp ( Str $string: )</pre>

<p>Returns string with newline removed from the end. An arbitrary terminator can be removed if the input filehandle has marked the string for where the &#34;newline&#34; begins. (Presumably this is stored as a property of the string.) Otherwise a standard newline is removed.</p>

<p>Note: Most users should just let their I/O handles autochomp instead. (Autochomping is the default.)</p>

<dt><a name="crypt"
>crypt</a></dt>

<dd>
<pre> our Str multi Str::crypt ( Str $plaintext, Str $salt )
 our Str multi method Str::crypt ( Str $plaintext: Str $salt )</pre>

<p>Encrypts the string using a one-way hash function. This yields a string which cannot be &#34;decrypted&#34;. This is used for verifying strings such as passwords. The <code>$plaintext</code> is the text to be encrypted. The <code>$salt</code> is a string which controls how the encryption is done. Typically, this is a random string of two characters that matches the following pattern:</p>

<pre> token Str::CryptBasicSalt { &#60;[./0-9A-Za-z]&#62; **{2} }</pre>

<p>There are other formats of salt as well, though their use is not universal. Check your operating system&#39;s <b>crypt</b> function for more details. Often these other functions are used when strings of length greater than eight are to be used (the default crypt mode only recognizes the first eight characters of the string as significant).</p>

<p>If you have a previously encrypted string and a plaintext password, you can check to see of the password is correct like so:</p>

<pre> sub checkpw ( $encrypted, $plaintext ) {
   return crypt($plaintext, $encrypted) ~~ $encrypted;
 }</pre>

<p>This works because the first part of the encrypted form of the password is the salt, so an encrypted text can be passed in place of the salt (everything after the salt is ignored).</p>

<dt><a name="lc"
>lc</a></dt>

<dd>
<a href="#" onclick="return tog_quote(20);">
<div ID="header_shown_20" style="display: none;">
- Hide the snippet from t/builtins/strings/lc.t (line 7 ~ line 24) -
</div>
<div ID="header_hidden_20" style="display: block;">
- Show the snippet from t/builtins/strings/lc.t (line 7 ~ line 24) -
</div>
</a>
<div ID="hide_20" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /lc/&gt;

is(lc(&quot;Hello World&quot;), &quot;hello world&quot;, &quot;simple lc test&quot;);
is(lc(&quot;&quot;), &quot;&quot;, &quot;empty string&quot;);
is(lc(&quot;&quot;), &quot;&quot;, &quot;some finnish non-ascii chars&quot;);
is(lc(&quot;&quot;), &quot;&quot;, &quot;accented chars&quot;);

$_ = &quot;Hello World&quot;; 
my $x = .lc;
is($x, &quot;hello world&quot;, 'lc uses $_ as default');

{ # test invocant syntax for lc
&nbsp; &nbsp; my $x = &quot;Hello World&quot;;
&nbsp; &nbsp; is($x.lc, &quot;hello world&quot;, '$x.lc works');
&nbsp; &nbsp; is(&quot;Hello World&quot;.lc, &quot;hello world&quot;, '&quot;Hello World&quot;.lc works');
}

is(&quot;&quot;.lc, &quot;&quot;, &quot;.lc on Hungarian vowels&quot;);</pre>
</div>


<pre> our Str multi Str::lc ( Str $string )</pre>

<p>Returns the input string after converting each character to its lowercase form, if uppercase.</p>

<a href="#" onclick="return tog_quote(13);">
<div ID="header_shown_13" style="display: none;">
- Hide the snippet from t/builtins/strings/uc.t (line 8 ~ line 30) -
</div>
<div ID="header_hidden_13" style="display: block;">
- Show the snippet from t/builtins/strings/uc.t (line 8 ~ line 30) -
</div>
</a>
<div ID="hide_13" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot;/converting character to uppercase&gt;

is(uc(&quot;Hello World&quot;), &quot;HELLO WORLD&quot;, &quot;simple&quot;);
is(uc(&quot;&quot;), &quot;&quot;, &quot;empty string&quot;); 
is(uc(&quot;&quot;), &quot;&quot;, &quot;some finnish non-ascii chars&quot;);
is(uc(&quot;&quot;), &quot;&quot;, &quot;accented chars&quot;);

# given does not return proper value yet
$_ = &quot;Hello World&quot;;
my $x = .uc;
is $x, &quot;HELLO WORLD&quot;, 'uc uses the default $_';

{ &nbsp; 
&nbsp; &nbsp; my $x = &quot;Hello World&quot;;
&nbsp; &nbsp; is $x.uc, &quot;HELLO WORLD&quot;, '$x.uc works';
&nbsp; &nbsp; is &quot;Hello World&quot;.uc, &quot;HELLO WORLD&quot;, '&quot;Hello World&quot;.uc works';
}

# Bug: GERMAN SHARP S (&quot;&quot;) should uc() to &quot;SS&quot;, but it doesn't
# Compare with: perl -we 'use utf8; print uc &quot;&quot;'
is(uc(&quot;&quot;), &quot;SS&quot;, &quot;uc() of non-ascii chars may result in two chars&quot;);

is(&quot;&quot;.uc, &quot;&quot;, &quot;.uc on Hungarian vowels&quot;);</pre>
</div>


<dt><a name="lcfirst"
>lcfirst</a></dt>

<dd>
<a href="#" onclick="return tog_quote(19);">
<div ID="header_shown_19" style="display: none;">
- Hide the snippet from t/builtins/strings/lcfirst.t (line 7 ~ line 24) -
</div>
<div ID="header_hidden_19" style="display: block;">
- Show the snippet from t/builtins/strings/lcfirst.t (line 7 ~ line 24) -
</div>
</a>
<div ID="hide_19" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /lcfirst/&gt;

is lcfirst(&quot;HELLO WORLD&quot;), &quot;hELLO WORLD&quot;, &quot;simple&quot;;
is lcfirst(&quot;&quot;), &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&quot;&quot;, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&quot;empty string&quot;;
is lcfirst(&quot;&quot;), &nbsp; &nbsp; &nbsp; &nbsp;&quot;&quot;, &nbsp; &nbsp; &nbsp; &nbsp;&quot;umlaut&quot;;
is lcfirst(&quot;&quot;), &nbsp; &nbsp; &nbsp; &quot;&quot;, &nbsp; &nbsp; &nbsp; &quot;accented chars&quot;;

is &quot;HELLO WORLD&quot;.lcfirst, &nbsp;&quot;hELLO WORLD&quot;, &quot;simple.lcfirst&quot;;

my $str = &quot;Some String&quot;;
is $str.lcfirst, &nbsp; &nbsp;&quot;some String&quot;, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&quot;simple.lcfirst on scalar variable&quot;;
is &quot;Other String&quot;.lcfirst, &nbsp;&quot;other String&quot;, &quot;.lcfirst on &nbsp;literal string&quot;;

$_ = &quot;HELLO WORLD&quot;;
my $x = .lcfirst;
is $x, &quot;hELLO WORLD&quot;, 'lcfirst uses $_ as default'</pre>
</div>


<pre> our Str multi Str::lcfirst ( Str $string )</pre>

<p>Like <code>lc</code>, but only affects the first character.</p>

<dt><a name="uc"
>uc</a></dt>

<dd>
<pre> our Str multi Str::uc ( Str $string )</pre>

<p>Returns the input string after converting each character to its uppercase form, if lowercase. This is not a Unicode &#34;titlecase&#34; operation, but a full &#34;uppercase&#34;.</p>

<dt><a name="ucfirst"
>ucfirst</a></dt>

<dd>
<a href="#" onclick="return tog_quote(12);">
<div ID="header_shown_12" style="display: none;">
- Hide the snippet from t/builtins/strings/ucfirst.t (line 7 ~ line 12) -
</div>
<div ID="header_hidden_12" style="display: block;">
- Show the snippet from t/builtins/strings/ucfirst.t (line 7 ~ line 12) -
</div>
</a>
<div ID="hide_12" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /ucfirst/&gt;

is ucfirst(&quot;hello world&quot;), &quot;Hello world&quot;, &quot;simple&quot;;
is ucfirst(&quot;&quot;), &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&quot;&quot;, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&quot;empty string&quot;;
is ucfirst(&quot;&quot;), &nbsp; &nbsp; &nbsp; &nbsp;&quot;&quot;, &nbsp; &nbsp; &nbsp; &nbsp;&quot;umlaut&quot;;
is ucfirst(&quot;&quot;), &nbsp; &nbsp; &nbsp; &nbsp;&quot;&quot;, &nbsp; &nbsp; &nbsp; &nbsp;&quot;accented chars&quot;;</pre>
</div>


<pre> our Str multi Str::ucfirst ( Str $string )</pre>

<p>Performs a Unicode &#34;titlecase&#34; operation on the first character of the string.</p>

<dt><a name="capitalize"
>capitalize</a></dt>

<dd>
<a href="#" onclick="return tog_quote(23);">
<div ID="header_shown_23" style="display: none;">
- Hide the snippet from t/builtins/strings/capitalize.t (line 7 ~ line 27) -
</div>
<div ID="header_hidden_23" style="display: block;">
- Show the snippet from t/builtins/strings/capitalize.t (line 7 ~ line 27) -
</div>
</a>
<div ID="hide_23" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /capitalize/&gt;

is capitalize(&quot;&quot;), &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;&quot;, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;capitalize('') works&quot;;
is capitalize(&quot;puGS Is cOOl!&quot;), &quot;Pugs Is Cool!&quot;, &quot;capitalize('...') works&quot;;
is &quot;puGS Is cOOl!&quot;.capitalize, &nbsp;&quot;Pugs Is Cool!&quot;, &quot;'...'.capitalize works&quot;;

my $a = &quot;&quot;;
is capitalize($a), &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;&quot;, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;capitalize empty string&quot;;
$a = &quot;puGS Is cOOl!&quot;;
is capitalize($a), &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;Pugs Is Cool!&quot;, &nbsp;&quot;capitalize string works&quot;;
is $a, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;puGS Is cOOl!&quot;, &nbsp;&quot;original srting not touched&quot;;
is $a.capitalize, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&quot;Pugs Is Cool!&quot;, &nbsp;&quot;capitalize string works&quot;;
is $a, &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;puGS Is cOOl!&quot;, &nbsp;&quot;original srting not touched&quot;;
is &quot;ab cD Ef&quot;.capitalize, &nbsp; &nbsp; &nbsp;&quot;Ab Cd Ef&quot;, &nbsp; &nbsp; &nbsp; &quot;works on ordenary string&quot;;


$_ = &quot;puGS Is cOOl!&quot;;
is .capitalize, &quot;Pugs Is Cool!&quot;, 'capitalize() uses \$_ as default';

# Non-ASCII chars:
is capitalize(&quot; abc&quot;), &quot; Abc&quot;, &quot;capitalize() works on non-ASCII chars&quot;;</pre>
</div>


<pre> our Str multi Str::capitalize ( Str $string )</pre>

<p>Has the effect of first doing an <code>lc</code> on the entire string, then performing a <code>s:g/(\w+)/{ucfirst $1}/</code> on it.</p>

<dt><a name="length"
>length</a></dt>

<dd>
<p>This word is banned in Perl 6. You must specify units.</p>

<dt><a name="index"
>index</a></dt>

<dd>
<a href="#" onclick="return tog_quote(21);">
<div ID="header_shown_21" style="display: none;">
- Hide the snippet from t/builtins/strings/index.t (line 4 ~ line 67) -
</div>
<div ID="header_hidden_21" style="display: block;">
- Show the snippet from t/builtins/strings/index.t (line 4 ~ line 67) -
</div>
</a>
<div ID="hide_21" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/Str/&quot;=item index&quot;&gt;

plan 31;

# Simple - with just a single char

is(index(&quot;Hello World&quot;, &quot;H&quot;), 0, &quot;One char, at beginning&quot;);
is(index(&quot;Hello World&quot;, &quot;l&quot;), 2, &quot;One char, in the middle&quot;);
is(index(&quot;Hello World&quot;, &quot;d&quot;), 10, &quot;One char, in the end&quot;);
is(index(&quot;Hello World&quot;, &quot;x&quot;), -1, &quot;One char, no match&quot;);

is(index(&quot;Hello World&quot;, &quot;l&quot;, 0), 2, &quot;One char, find first match, pos = 0&quot;);
is(index(&quot;Hello World&quot;, &quot;l&quot;, 2), 2, &quot;- 1. match again, pos @ match&quot;);
is(index(&quot;Hello World&quot;, &quot;l&quot;, 3), 3, &quot;- 2. match&quot;);
is(index(&quot;Hello World&quot;, &quot;l&quot;, 4), 9, &quot;- 3. match&quot;);
is(index(&quot;Hello World&quot;, &quot;l&quot;, 10), -1, &quot;- no more matches&quot;);

# Simple - with a string

is(index(&quot;Hello World&quot;, &quot;Hello&quot;), 0, &quot;Substr, at beginning&quot;);
is(index(&quot;Hello World&quot;, &quot;o W&quot;), 4, &quot;Substr, in the middle&quot;);
is(index(&quot;Hello World&quot;, &quot;World&quot;), 6, &quot;Substr, at the end&quot;);
is(index(&quot;Hello World&quot;, &quot;low&quot;), -1, &quot;Substr, no match&quot;);
is(index(&quot;Hello World&quot;, &quot;Hello World&quot;), 0, &quot;Substr eq Str&quot;);

# Empty strings

is(index(&quot;Hello World&quot;, &quot;&quot;), 0, &quot;Substr is empty&quot;);
is(index(&quot;&quot;, &quot;&quot;), 0, &quot;Both strings are empty&quot;);
is(index(&quot;&quot;, &quot;Hello&quot;), -1, &quot;Only main-string is empty&quot;);
is(index(&quot;Hello&quot;, &quot;&quot;, 3), 3, &quot;Substr is empty, pos within str&quot;);
is(index(&quot;Hello&quot;, &quot;&quot;, 5), 5, &quot;Substr is empty, pos at end of str&quot;);
is(index(&quot;Hello&quot;, &quot;&quot;, 999), 5, &quot;Substr is empty, pos &gt; length of str&quot;);

# More difficult strings

is(index(&quot;ababcabcd&quot;, &quot;abcd&quot;), 5, &quot;Start-of-substr matches several times&quot;); &nbsp;

is(index(&quot;uuuu&quot;, &quot;u&quot;), 4, &quot;Accented chars&quot;);
is(index(&quot;mlaut&quot;, &quot;&quot;), 0, &quot;Umlaut&quot;);


# &nbsp;call directly with the .notation

is(&quot;Hello&quot;.index(&quot;l&quot;), 2, &quot;.index on string&quot;);

# work on variables

my $a = &quot;word&quot;;
is($a.index(&quot;o&quot;), 1, &quot;.index on scalar variable&quot;);

my @a = &lt;Hello World&gt;;
is(index(@a[0], &quot;l&quot;), 2, &quot;on array element&quot;);
is(@a[0].index(&quot;l&quot;), 2, &quot;.index on array element&quot;);

# index on junctions, maybe this should be moved to t/junctions/ ?

my $j = (&quot;Hello&quot;|&quot;World&quot;);
ok(index($j, &quot;l&quot;) == 2, &quot;index on junction&quot;);
ok(index($j, &quot;l&quot;) == 3, &quot;index on junction&quot;);
ok($j.index(&quot;l&quot;) &nbsp;== 2, &quot;.index on junction&quot;);
ok($j.index(&quot;l&quot;) &nbsp;== 3, &quot;.index on junction&quot;);</pre>
</div>


<pre> our StrPos multi Str::index( Str $string, Str $substring, StrPos $pos = 0 )</pre>

<a href="#" onclick="return tog_quote(14);">
<div ID="header_shown_14" style="display: none;">
- Hide the snippet from t/builtins/strings/substr.t (line 7 ~ line 125) -
</div>
<div ID="header_hidden_14" style="display: block;">
- Show the snippet from t/builtins/strings/substr.t (line 7 ~ line 125) -
</div>
</a>
<div ID="hide_14" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /substr/&gt;

{ # read only
&nbsp; &nbsp; my $str = &quot;foobar&quot;;

&nbsp; &nbsp; is(substr($str, 0, 1), &quot;f&quot;, &quot;first char&quot;);
&nbsp; &nbsp; is(substr($str, -1), &quot;r&quot;, &quot;last char&quot;);
&nbsp; &nbsp; is(substr($str, -4, 2), &quot;ob&quot;, &quot;counted from the end&quot;);
&nbsp; &nbsp; is(substr($str, 1, 2), &quot;oo&quot;, &quot;arbitrary middle&quot;);
&nbsp; &nbsp; is(substr($str, 3), &quot;bar&quot;, &quot;length omitted&quot;);
&nbsp; &nbsp; is(substr($str, 3, 10), &quot;bar&quot;, &quot;length goes past end&quot;);
&nbsp; &nbsp; is(substr($str, 20, 5), undef, &quot;substr outside of string&quot;);
&nbsp; &nbsp; is(substr($str, -100, 10), undef, &quot;... on the negative side&quot;);

&nbsp; &nbsp; is(substr($str, 0, -2), &quot;foob&quot;, &quot;from beginning, with negative length&quot;);
&nbsp; &nbsp; is(substr($str, 2, -2), &quot;ob&quot;, &quot;in middle, with negative length&quot;);
&nbsp; &nbsp; is(substr($str, 3, -3), &quot;&quot;, &quot;negative length - gives empty string&quot;);

&nbsp; &nbsp; is($str, &quot;foobar&quot;, &quot;original string still not changed&quot;);
};

skip 4, &quot;more discussion needed&quot;;

=begin more-discussion-needed

{ # replacement
&nbsp; &nbsp; my $str = &quot;foobar&quot;;

&nbsp; &nbsp; substr($str, 2, 1, &quot;i&quot;);
&nbsp; &nbsp; is($str, &quot;foibar&quot;, &quot;fourth arg to substr replaced part&quot;);

&nbsp; &nbsp; substr($str, -1, 1, &quot;blah&quot;);
&nbsp; &nbsp; is($str, &quot;foibablah&quot;, &quot;longer replacement expands string&quot;);

&nbsp; &nbsp; substr($str, 1, 3, &quot;&quot;);
&nbsp; &nbsp; is($str, &quot;fablah&quot;, &quot;shorter replacement shrunk it&quot;);

&nbsp; &nbsp; substr($str, 1, -1, &quot;aye&quot;);
&nbsp; &nbsp; is($str, &quot;fayeh&quot;, &quot;replacement with negative length&quot;);
};

=end more-discussion-needed

=cut

# as lvalue, XXX: not sure this should work, as that'd be action at distance:
# &nbsp; my $substr = \substr($str, ...);
# &nbsp; ...;
# &nbsp; some_func $substr; # manipulates $substr
# &nbsp; # $str altered!
# But one could think that's the wanted behaviour, so I leave the test in.
{
&nbsp; &nbsp; my $str = &quot;gorch ding&quot;;

&nbsp; &nbsp; substr($str, 0, 5) = &quot;gloop&quot;;
&nbsp; &nbsp; is($str, &quot;gloop ding&quot;, &quot;lvalue assignment modified original string&quot;);

&nbsp; &nbsp; my $r = \substr($str, 0, 5);
&nbsp; &nbsp; ok(~ref($r), '$r is a reference');
&nbsp; &nbsp; is($$r, &quot;gloop&quot;, '$r referent is eq to the substring');

&nbsp; &nbsp; $$r = &quot;boing&quot;;
&nbsp; &nbsp; is($str, &quot;boing ding&quot;, &quot;assignment to reference modifies original&quot;, :todo);
&nbsp; &nbsp; is($$r, &quot;boing&quot;, '$r is consistent');

&nbsp; &nbsp; my $o = \substr($str, 3, 2);
&nbsp; &nbsp; is($$o, &quot;ng&quot;, &quot;other ref to other lvalue&quot;, :todo);
&nbsp; &nbsp; $$r = &quot;foo&quot;;
&nbsp; &nbsp; is($str, &quot;foo ding&quot;, &quot;lvalue ref size varies but still works&quot;, :todo);
&nbsp; &nbsp; is($$o, &quot; d&quot;, &quot;other lvalue wiggled around&quot;, :todo);
};

{ # as lvalue, should work
&nbsp; &nbsp; my $str = &quot;gorch ding&quot;;

&nbsp; &nbsp; substr($str, 0, 5) = &quot;gloop&quot;;
&nbsp; &nbsp; is($str, &quot;gloop ding&quot;, &quot;lvalue assignment modified original string&quot;);
};

{ # as lvalue, using :=, should work
&nbsp; &nbsp; my $str = &quot;gorch ding&quot;;

&nbsp; &nbsp; substr($str, 0, 5) = &quot;gloop&quot;;
&nbsp; &nbsp; is($str, &quot;gloop ding&quot;, &quot;lvalue assignment modified original string&quot;);

&nbsp; &nbsp; my $r := substr($str, 0, 5);
&nbsp; &nbsp; is($r, &quot;gloop&quot;, 'bound $r is eq to the substring');

&nbsp; &nbsp; $r = &quot;boing&quot;;
&nbsp; &nbsp; is($str, &quot;boing ding&quot;, &quot;assignment to bound var modifies original&quot;);
&nbsp; &nbsp; is($r, &quot;boing&quot;, 'bound $r is consistent', :todo&lt;bug&gt;);

&nbsp; &nbsp; my $o := substr($str, 3, 2);
&nbsp; &nbsp; is($o, &quot;ng&quot;, &quot;other bound var to other lvalue&quot;);
&nbsp; &nbsp; $r = &quot;foo&quot;;
&nbsp; &nbsp; is($str, &quot;foo ding&quot;, &quot;lvalue ref size varies but still works&quot;);
&nbsp; &nbsp; is($o, &quot; d&quot;, &quot;other lvalue wiggled around&quot;, :todo&lt;bug&gt;);
};

{ 
# from L&lt;S09/&quot;Junctions&quot; /Each of the resulting set of calls is then recursively autothreaded/&gt;
# See also t/junctions/s09eg.t
# This test is not working as-is
# &nbsp; &nbsp;eval_is('substr(&quot;camel&quot;, 0|1, 2&amp;3)', ((&quot;ca&quot;|&quot;am&quot;) &amp; (&quot;cam&quot;|&quot;ame&quot;)), &quot;junctive substr&quot;, :todo);
}


{ # misc
&nbsp; &nbsp; my $str = &quot;hello foo and bar&quot;;
&nbsp; &nbsp; is(substr($str, 6, 3), &quot;foo&quot;, &quot;substr&quot;);
&nbsp; &nbsp; is($str.substr(6, 3), &quot;foo&quot;, &quot;.substr&quot;);
&nbsp; &nbsp; is(substr(&quot;hello foo bar&quot;, 6, 3), &quot;foo&quot;, &quot;substr on literal string&quot;);
&nbsp; &nbsp; is(&quot;hello foo bar&quot;.substr(6, 3), &quot;foo&quot;, &quot;.substr on literal string&quot;);
&nbsp; &nbsp; is(&quot;hello foo bar&quot;.substr(6, 3).uc, &quot;FOO&quot;, &quot;.substr.uc on literal string&quot;);
&nbsp; &nbsp; is(&quot;hello foo bar and baz&quot;.substr(6, 10).capitalize, &quot;Foo Bar An&quot;, &quot;.substr.capitalize on literal string&quot;);
&nbsp; &nbsp; is(&quot;hello  foo&quot;.substr(6, 2), &quot;&quot;, &quot;.substr on unicode string&quot;);
&nbsp; &nbsp; is(&quot; &quot;.substr(4, 4), &quot; &quot;, &quot;.substr on Hebrew text&quot;);
}</pre>
</div>


<p><code>index</code> searches for the first occurrence of <code>$substring</code> in <code>$string</code>, starting at <code>$pos</code>.</p>

<p>If the substring is found, then the position of the first character of the substring is returned. If the substring is not found, then undef is returned.</p>

<dt><a name="pack"
>pack</a></dt>

<dd>
<pre> our Str multi Str::pack( Str::Encoding $encoding,  Pair *@items )
 our Str multi Str::pack( Str::Encoding $encoding,  Str $template, *@items )
 our buf8 multi Str::pack( Pair *@items )
 our buf8 multi Str::pack( Str $template, *@items )</pre>

<p><code>pack</code> takes a list of pairs and formats the values according to the specification of the keys. Alternately, it takes a string <code>$template</code> and formats the rest of its arguments according to the specifications in the template string. The result is a sequence of bytes.</p>

<p>An optional <code>$encoding</code> can be used to specify the character encoding to use in interpreting the result as a <code>Str</code>, otherwise the return value will simply be a <code>buf</code> containing the bytes generated by the template(s) and value(s). Note that no guarantee is made in terms of the final, internal representation of the string, only that the generated sequence of bytes will be interpreted as a string in the given encoding, and a string containing those graphemes will be returned. If the sequence of bytes represents an invalid string according to <code>$encoding</code>, an exception is generated.</p>

<p>Templates are strings of the form:</p>

<pre>  grammar Str::PackTemplate {
   regex template  { [ &#60;group&#62; | &#60;specifier&#62; &#60;count&#62;? ]* }
   token group     { \( &#60;template&#62; \) }
   token specifier { &#60;[aAZbBhHcCsSiIlLnNvVqQjJfdFDpPuUwxX\@]&#62; \!? }
   token count     { \* |
             \[ [ \d+ | &#60;specifier&#62; ] \] |
             \d+ }
 }</pre>

<p>In the pairwise mode, each key must contain a single <code>&#60;group&#62;</code> or <code>&#60;specifier&#62;</code>, and the values must be either scalar arguments or arrays.</p>

<p>[ Note: Need more documentation and need to figure out what Perl 5 things no longer make sense. Does Perl 6 need any extra formatting</p>

<pre>        features? -ajs ]</pre>

<dt><a name="pos"
>pos
<dt><a name="quotemeta"
>quotemeta</a></dt>

<dd>
<a href="#" onclick="return tog_quote(18);">
<div ID="header_shown_18" style="display: none;">
- Hide the snippet from t/builtins/strings/quotemeta.t (line 31 ~ line 134) -
</div>
<div ID="header_hidden_18" style="display: block;">
- Show the snippet from t/builtins/strings/quotemeta.t (line 31 ~ line 134) -
</div>
</a>
<div ID="hide_18" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Str&quot; /quotemeta/&gt;

is(quotemeta(&quot;HeLLo World-72_1&quot;), &quot;HeLLo\\ World\\-72_1&quot;, &quot;simple lc test&quot;);
is(quotemeta(&quot;&quot;), &quot;&quot;, &quot;empty string&quot;);

$_ = &quot;HeLLo World-72_1&quot;; 
my $x = .quotemeta;
is($x, &quot;HeLLo\\ World\\-72_1&quot;, 'quotemeta uses $_ as default');

{ # test invocant syntax for quotemeta
&nbsp; &nbsp; my $x = &quot;HeLLo World-72_1&quot;;
&nbsp; &nbsp; is($x.quotemeta, &quot;HeLLo\\ World\\-72_1&quot;, '$x.quotemeta works');
&nbsp; &nbsp; is(&quot;HeLLo World-72_1&quot;.quotemeta, &quot;HeLLo\\ World\\-72_1&quot;, '&quot;HeLLo World-72_1&quot;.quotemeta works');
}


if (%Config&lt;ebcdic&gt; eq 'define') {
&nbsp; &nbsp; $_ = (129 .. 233).map({ chr($_); }).join('');
&nbsp; &nbsp; is($_.chars, 96, &quot;quotemeta starting string&quot;);
&nbsp; &nbsp; 
&nbsp; &nbsp; # 105 characters - 52 letters = 53 backslashes
&nbsp; &nbsp; # 105 characters + 53 backslashes = 158 characters
&nbsp; &nbsp; $_ = quotemeta $_;
&nbsp; &nbsp; is($_.chars, 158, &quot;quotemeta string&quot;);
&nbsp; &nbsp; # 53 backslashed characters + 1 &quot;original&quot; backslash
&nbsp; &nbsp; is($_.split('').grep({ $_ eq &quot;\x5c&quot; }).elems, 54, &quot;count backslashes&quot;);
}
else {
&nbsp; &nbsp; $_ = (0 .. 255).map({ chr($_); }).join('');
&nbsp; &nbsp; is($_.chars, 256, &quot;quotemeta starting string&quot;);
&nbsp; &nbsp; 
&nbsp; &nbsp; # Original test in Perl 5.9.3:
&nbsp; &nbsp; # 96 characters - 52 letters - 10 digits - 1 underscore = 33 backslashes
&nbsp; &nbsp; # 96 characters + 33 backslashes = 129 characters
&nbsp; &nbsp; # 
&nbsp; &nbsp; # Then added remaining 32 + 128, all escaped:
&nbsp; &nbsp; # 129 + (32 + 128) * 2 = 449
&nbsp; &nbsp; #
&nbsp; &nbsp; # Total backslashed chars are 33 + 32 + 128 = 193
&nbsp; &nbsp; # Total backslashes are 1 + 193 = 194
&nbsp; &nbsp; $_ = quotemeta $_;
&nbsp; &nbsp; is($_.chars, 449, &quot;quotemeta string&quot;);
&nbsp; &nbsp; # 33 backslashed characters + 1 &quot;original&quot; backslash
&nbsp; &nbsp; is($_.split('').grep({ $_ eq &quot;\x5c&quot; }).elems, 194, &quot;count backslashes&quot;);
}

# Current quotemeta implementation mimics that for Perl 5, avoiding
# to escape Unicode characters beyond 256th
is(quotemeta(&quot;\x[263a]&quot;), &quot;\x[263a]&quot;, &quot;quotemeta Unicode&quot;);
is(quotemeta(&quot;\x[263a]&quot;).chars, 1, &quot;quotemeta Unicode length&quot;);

=begin from_perl5


plan tests =&gt; 22;

if ($Config{ebcdic} eq 'define') {
&nbsp; &nbsp; $_ = join &quot;&quot;, map chr($_), 129..233;

&nbsp; &nbsp; # 105 characters - 52 letters = 53 backslashes
&nbsp; &nbsp; # 105 characters + 53 backslashes = 158 characters
&nbsp; &nbsp; $_ = quotemeta $_;
&nbsp; &nbsp; is(length($_), 158, &quot;quotemeta string&quot;);
&nbsp; &nbsp; # 104 non-backslash characters
&nbsp; &nbsp; is(tr/\\//cd, 104, &quot;tr count non-backslashed&quot;);
} else { # some ASCII descendant, then.
&nbsp; &nbsp; $_ = join &quot;&quot;, map chr($_), 32..127;

&nbsp; &nbsp; # 96 characters - 52 letters - 10 digits - 1 underscore = 33 backslashes
&nbsp; &nbsp; # 96 characters + 33 backslashes = 129 characters
&nbsp; &nbsp; $_ = quotemeta $_;
&nbsp; &nbsp; is(length($_), 129, &quot;quotemeta string&quot;);
&nbsp; &nbsp; # 95 non-backslash characters
&nbsp; &nbsp; is(tr/\\//cd, 95, &quot;tr count non-backslashed&quot;);
}

is(length(quotemeta &quot;&quot;), 0, &quot;quotemeta empty string&quot;);

is(&quot;aA\UbB\LcC\EdD&quot;, &quot;aABBccdD&quot;, 'aA\UbB\LcC\EdD');
is(&quot;aA\LbB\UcC\EdD&quot;, &quot;aAbbCCdD&quot;, 'aA\LbB\UcC\EdD');
is(&quot;\L\upERL&quot;, &quot;Perl&quot;, '\L\upERL');
is(&quot;\u\LpERL&quot;, &quot;Perl&quot;, '\u\LpERL');
is(&quot;\U\lPerl&quot;, &quot;pERL&quot;, '\U\lPerl');
is(&quot;\l\UPerl&quot;, &quot;pERL&quot;, '\l\UPerl');
is(&quot;\u\LpE\Q#X#\ER\EL&quot;, &quot;Pe\\#x\\#rL&quot;, '\u\LpE\Q#X#\ER\EL');
is(&quot;\l\UPe\Q!x!\Er\El&quot;, &quot;pE\\!X\\!Rl&quot;, '\l\UPe\Q!x!\Er\El');
is(&quot;\Q\u\LpE.X.R\EL\E.&quot;, &quot;Pe\\.x\\.rL.&quot;, '\Q\u\LpE.X.R\EL\E.');
is(&quot;\Q\l\UPe*x*r\El\E*&quot;, &quot;pE\\*X\\*Rl*&quot;, '\Q\l\UPe*x*r\El\E*');
is(&quot;\U\lPerl\E\E\E\E&quot;, &quot;pERL&quot;, '\U\lPerl\E\E\E\E');
is(&quot;\l\UPerl\E\E\E\E&quot;, &quot;pERL&quot;, '\l\UPerl\E\E\E\E');

is(quotemeta(&quot;\x{263a}&quot;), &quot;\x{263a}&quot;, &quot;quotemeta Unicode&quot;);
is(length(quotemeta(&quot;\x{263a}&quot;)), 1, &quot;quotemeta Unicode length&quot;);

$a = &quot;foo|bar&quot;;
is(&quot;a\Q\Ec$a&quot;, &quot;acfoo|bar&quot;, '\Q\E');
is(&quot;a\L\Ec$a&quot;, &quot;acfoo|bar&quot;, '\L\E');
is(&quot;a\l\Ec$a&quot;, &quot;acfoo|bar&quot;, '\l\E');
is(&quot;a\U\Ec$a&quot;, &quot;acfoo|bar&quot;, '\U\E');
is(&quot;a\u\Ec$a&quot;, &quot;acfoo|bar&quot;, '\u\E');

=end from_perl5

=cut</pre>
</div>


<pre> our Str multi Str::quotemeta ( Str $string )</pre>

<p>Returns the input string with all non-&#34;word&#34; characters back-slashed. That is, all characters not matching &#34;/[A-Za-z_0-9]/&#34; will be preceded by a backslash in the returned string, regardless of any locale settings.</p>

<dt><a name="rindex"
>rindex</a></dt>

<dd>
<a href="#" onclick="return tog_quote(17);">
<div ID="header_shown_17" style="display: none;">
- Hide the snippet from t/builtins/strings/rindex.t (line 4 ~ line 60) -
</div>
<div ID="header_hidden_17" style="display: block;">
- Show the snippet from t/builtins/strings/rindex.t (line 4 ~ line 60) -
</div>
</a>
<div ID="hide_17" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/Str/&quot;=item rindex&quot;&gt;

plan 30;

# Simple - with just a single char

is(rindex(&quot;Hello World&quot;, &quot;H&quot;), 0, &quot;One char, at beginning&quot;);
is(rindex(&quot;Hello World&quot;, &quot;l&quot;), 9, &quot;One char, in the middle&quot;);
is(rindex(&quot;Hello World&quot;, &quot;d&quot;), 10, &quot;One char, in the end&quot;);
is(rindex(&quot;Hello World&quot;, &quot;x&quot;), -1, &quot;One char, no match&quot;);

is(rindex(&quot;Hello World&quot;, &quot;l&quot;, 10), 9, &quot;One char, first match, pos @ end&quot;);
is(rindex(&quot;Hello World&quot;, &quot;l&quot;, 9), 9, &quot;- 1. match again, pos @ match&quot;);
is(rindex(&quot;Hello World&quot;, &quot;l&quot;, 8), 3, &quot;- 2. match&quot;);
is(rindex(&quot;Hello World&quot;, &quot;l&quot;, 2), 2, &quot;- 3. match&quot;);
is(rindex(&quot;Hello World&quot;, &quot;l&quot;, 1), -1, &quot;- no more matches&quot;);

# Simple - with a string

is(rindex(&quot;Hello World&quot;, &quot;Hello&quot;), 0, &quot;Substr, at beginning&quot;);
is(rindex(&quot;Hello World&quot;, &quot;o W&quot;), 4, &quot;Substr, in the middle&quot;);
is(rindex(&quot;Hello World&quot;, &quot;World&quot;), 6, &quot;Substr, at the end&quot;);
is(rindex(&quot;Hello World&quot;, &quot;low&quot;), -1, &quot;Substr, no match&quot;);
is(rindex(&quot;Hello World&quot;, &quot;Hello World&quot;), 0, &quot;Substr eq Str&quot;);

# Empty strings

is(rindex(&quot;Hello World&quot;, &quot;&quot;), 11, &quot;Substr is empty&quot;);
is(rindex(&quot;&quot;, &quot;&quot;), 0, &quot;Both strings are empty&quot;);
is(rindex(&quot;&quot;, &quot;Hello&quot;), -1, &quot;Only main-string is empty&quot;);
is(rindex(&quot;Hello&quot;, &quot;&quot;, 3), 3, &quot;Substr is empty, pos within str&quot;);
is(rindex(&quot;Hello&quot;, &quot;&quot;, 5), 5, &quot;Substr is empty, pos at end of str&quot;);
is(rindex(&quot;Hello&quot;, &quot;&quot;, 999), 5, &quot;Substr is empty, pos &gt; length of str&quot;);

# More difficult strings

is(rindex(&quot;abcdabcab&quot;, &quot;abcd&quot;), 0, &quot;Start-of-substr matches several times&quot;); &nbsp;

is(rindex(&quot;uuuu&quot;, &quot;u&quot;), 4, &quot;Accented chars&quot;);
is(rindex(&quot;mlaut&quot;, &quot;&quot;), 0, &quot;Umlaut&quot;);

is(rindex(&quot;what are these   unicode characters for ?&quot;, &quot;uni&quot;), 19, &quot;over unicode characters&quot;);

# .rindex use
is(&quot;Hello World&quot;.rindex(&quot;l&quot;), 9, &quot;.rindex on string&quot;);
is(&quot;Hello World&quot;.rindex(''), 11, &quot;.rindex('') on string gives string length in bytes&quot;);

# on scalar variable
my $s = &quot;Hello World&quot;;
is(rindex($s, &quot;o&quot;), 7, &quot;rindex on scalar variable&quot;);
is($s.rindex(&quot;o&quot;), 7, &quot;.rindex on scalar variable&quot;);

is(rindex(uc($s), &quot;O&quot;), 7, &quot;rindex on uc&quot;);
is($s.uc.rindex(&quot;O&quot;), 7, &quot;.uc.rindex &quot;);

# ideas for deeper chained . calls ?</pre>
</div>


<pre> our StrPos multi Str::index( Str $string, Str $substring, StrPos $pos? )</pre>

<p>Returns the position of the last <code>$substring</code> in <code>$string</code>. If <code>$pos</code> is specified, then the search starts at that location in <code>$string</code>, and works backwards. See <code>index</code> for more detail.</p>

<dt><a name="split"
>split</a></dt>

<dd>
<a href="#" onclick="return tog_quote(16);">
<div ID="header_shown_16" style="display: none;">
- Hide the snippet from t/builtins/strings/split.t (line 5 ~ line 118) -
</div>
<div ID="header_hidden_16" style="display: block;">
- Show the snippet from t/builtins/strings/split.t (line 5 ~ line 118) -
</div>
</a>
<div ID="hide_16" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/Str/&quot;=item split&quot;&gt;

# XXX - this needs to be updated when Str.split(Str) works again
# this test really wants is_deeply()
plan 94;

# split on an empty string

my %ords = (
&nbsp; 1 =&gt; 'first',
&nbsp; 2 =&gt; 'second',
&nbsp; 3 =&gt; 'third',
&nbsp; 4 =&gt; 'fourth',
&nbsp; 5 =&gt; 'fifth',
&nbsp; 6 =&gt; 'sixth',
&nbsp; 7 =&gt; 'seventh',
&nbsp; 8 =&gt; 'eighth',
&nbsp; 9 =&gt; 'ninth',
);

sub split_test(@splitted, @expected, Str $desc, $todo = 0) {
&nbsp; is +@splitted, +@expected,
&nbsp; &nbsp; &quot;split created the correct value amount for: $desc&quot;, :todo($todo);
&nbsp; is @splitted[$_], @expected[$_],
&nbsp; &nbsp; &quot;the %ords{$_ + 1} value matched for: $desc&quot;, :todo($todo)
&nbsp; &nbsp; for 0 .. @splitted.end;
&nbsp; is_deeply @splitted, @expected, &quot;values match&quot;, todo($todo); 
}

split_test split(&quot;&quot;, &quot;forty-two&quot;),
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qw/f o r t y - t w o/,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; q{split &quot;&quot;, Str};

# split on a space
split_test split(' ', 'split this string'),
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qw/split this string/,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; q{split ' ', Str};

# split on a single character delimiter
split_test split('$', 'try$this$string'),
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qw/try this string/,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; q{split '$', Str};

# split on a multi-character delimiter
split_test split(', ', &quot;comma, separated, values&quot;),
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qw/comma separated values/,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; q{split ', ', Str};

# split on a variable delimiter

my $delimiter = '::';
split_test split($delimiter, &quot;Perl6::Pugs::Test&quot;),
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qw/Perl6 Pugs Test/,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; q{split $delimiter, Str};

# split with a reg-exp
split_test split(rx:Perl5 {,}, &quot;split,me&quot;),
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qw/split me/,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; q(split rx:Perl5 {,}, Str);

# split on multiple space characters
split_test split(rx:Perl5 {\s+}, &quot;Hello World &nbsp; &nbsp;Goodbye &nbsp; Mars&quot;),
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qw/Hello World Goodbye Mars/,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; q(split rx:Perl5 {\s+}, Str);

split_test split(rx:Perl5 {(\s+)}, &quot;Hello test&quot;),
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ('Hello', (&quot;Hello test&quot; ~~ rx:Perl5 {(\s+)}), 'test'),
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; q/split rx:Perl5 {(\s+)}, Str/;

split_test &quot;to be || ! to be&quot;.split(' '),
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qw/to be || ! to be/,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; q/Str.split(' ')/;

split_test &quot;this will be split&quot;.split(rx:Perl5 { }),
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; qw/this will be split/,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; q/Str.split(rx:Perl5 { })/;

# split on multiple space characters
split_test split(rx:Perl5 {\s+}, &quot;Hello World &nbsp; &nbsp;Goodbye &nbsp; Mars&quot;, 3),
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ( qw/Hello World/, &quot;Goodbye &nbsp; Mars&quot; ),
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; q(split rx:Perl5 {\s+}, Str, limit);

split_test split(&quot; &quot;, &quot;Hello World &nbsp; &nbsp;Goodbye &nbsp; Mars&quot;, 3),
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ( qw/Hello World/, &quot; &nbsp; Goodbye &nbsp; Mars&quot; ),
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; q(split &quot; &quot;, Str, limit);

split_test &nbsp;&quot;Hello World &nbsp; &nbsp;Goodbye &nbsp; Mars&quot;.split(rx:Perl5 {\s+}, 3),
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ( qw/Hello World/, &quot;Goodbye &nbsp; Mars&quot; ),
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; q/Str.split(rx:Perl5 {\s+}, limit)/;

split_test &nbsp;&quot;Hello World &nbsp; &nbsp;Goodbye &nbsp; Mars&quot;.split(&quot; &quot;, 3),
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ( qw/Hello World/, &quot; &nbsp; Goodbye &nbsp; Mars&quot; ),
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; q/Str.split(&quot; &quot;, limit)/;

split_test &nbsp;&quot;Word&quot;.split(&quot;&quot;, 3), qw(W o rd),
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; q/Str.split(&quot;&quot;, limit)/;

# XXX: S29 split is not specified. :-(

# XXX: Here Pugs emulates p5 default awk field splitting behaviour.
split_test &nbsp;&quot; &nbsp;abc &nbsp;def &nbsp;&quot;.split(), qw/abc def/,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; q/Str.split()/;
# ... yet how do you do this with p6 function form of split?
# Note that split(' ', $x) special casing of ' ' pattern (a la p5)
# is not implemented in Pugs. Should it be?

# This one returns an empty list
split_test &nbsp;&quot;&quot;.split(), (),
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; q/&quot;&quot;.split()/;

# ... yet this one does not (different to p5).
# blessed by $Larry at Message-ID: &lt;20060118191046.GB32562@wall.org&gt;
split_test &nbsp;&quot;&quot;.split(':'), (&quot;&quot;),
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; q/&quot;&quot;.split(':')/;</pre>
</div>


<pre> our List multi Str::split ( Str $delimiter ,  Str $input_, Int $limit = inf )
 our List multi Str::split ( Rule $delimiter = /\s+/,  Str $input, Int $limit = inf )
 our List multi Str::split ( Str $input ;  Str $delimiter          , Int $limit = inf )
 our List multi Str::split ( Str $input ; Rule $delimiter          , Int $limit = inf )</pre>

<p>String delimiters must not be treated as rules but as constants. The default is no longer &#39;&#160;&#39; since that would be interpreted as a constant. P5&#39;s <code>split(&#39;&#160;&#39;)</code> will translate to <code>.words</code> or some such. Null trailing fields are no longer trimmed by default. We might add some kind of :trim flag or introduce a trimlist function of some sort.</p>

<dt><a name="sprintf"
>sprintf</a></dt>

<dd>
<pre> our Str multi method Str::sprintf ( Str $format: *@args )
 our Str multi Str::sprintf ( Str $format, *@args )</pre>

<p>This function is mostly identical to the C library sprintf function.</p>

<a href="#" onclick="return tog_quote(15);">
<div ID="header_shown_15" style="display: none;">
- Hide the snippet from t/builtins/strings/sprintf.t (line 7 ~ line 22) -
</div>
<div ID="header_hidden_15" style="display: block;">
- Show the snippet from t/builtins/strings/sprintf.t (line 7 ~ line 22) -
</div>
</a>
<div ID="hide_15" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/Str/&quot;identical to&quot; &quot;C library sprintf&quot;&gt;

is sprintf(&quot;Hi&quot;), &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &quot;Hi&quot;, &nbsp; &nbsp; &quot;sprintf() works with zero args&quot;;
is sprintf(&quot;%03d&quot;, &nbsp; &nbsp; &nbsp;3), &nbsp; &nbsp; &nbsp; &quot;003&quot;, &nbsp; &nbsp;&quot;sprintf() works with one arg&quot;;
is sprintf(&quot;%03d %02d&quot;, 3, 1), &nbsp; &nbsp;&quot;003 01&quot;, &quot;sprintf() works with two args&quot;;
is sprintf(&quot;%d %d %d&quot;, &nbsp;3,1,4), &nbsp; &quot;3 1 4&quot;, &nbsp;&quot;sprintf() works with three args&quot;;
is sprintf(&quot;%d%d%d%d&quot;, &nbsp;3,1,4,1), &quot;3141&quot;, &nbsp; &quot;sprintf() works with four args&quot;;

eval_ok('sprintf(&quot;%b&quot;,1)', &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;'eval of sprintf() with %b');

is sprintf(&quot;%04b&quot;,3), &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; '0011', &nbsp; '0-padded sprintf() with %b';
is sprintf(&quot;%4b&quot;,3), &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;' &nbsp;11', &nbsp; '&quot; &quot;-padded sprintf() with %b';
is sprintf(&quot;%b&quot;,30), &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;'11110', &nbsp;'longer string, no padding';
is sprintf(&quot;%2b&quot;,30), &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; '11110', &nbsp;'padding specified, not needed';
is sprintf(&quot;%03b&quot;,7), &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; '111', &nbsp; &nbsp;'0 padding, longer string';
is sprintf(&quot;%b %b&quot;,3,3), &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;'11 11', &nbsp;'two args %b';</pre>
</div>


<p>The <code>$format</code> is scanned for <code>%</code> characters. Any <code>%</code> introduces a format token. Format tokens have the following grammar:</p>

<pre> grammar Str::SprintfFormat {
  regex format_token { \%: &#60;index&#62;? &#60;precision&#62;? &#60;modifier&#62;? &#60;directive&#62; }
  token index { \d+ \$ }
  token precision { &#60;flags&#62;? &#60;vector&#62;? &#60;precision_count&#62; }
  token flags { &#60;[\ +0\#\-]&#62;+ }
  token precision_count { [ &#60;[1-9]&#62;\d* | \* ]? [ \. [ \d* | \* ] ]? }
  token vector { \*? v }
  token modifier { ll | &#60;[lhmVqL]&#62; }
  token directive { &#60;[\%csduoxefgXEGbpniDUOF]&#62; }
 }</pre>

<p>Directives guide the use (if any) of the arguments. When a directive (other than <code>%</code>) are used, they indicate how the next argument passed is to be formatted into the string.</p>

<p>The directives are:</p>

<pre> %   a literal percent sign
 c   a character with the given codepoint
 s   a string
 d   a signed integer, in decimal
 u   an unsigned integer, in decimal
 o   an unsigned integer, in octal
 x   an unsigned integer, in hexadecimal
 e   a floating-point number, in scientific notation
 f   a floating-point number, in fixed decimal notation
 g   a floating-point number, in %e or %f notation
 X   like x, but using upper-case letters
 E   like e, but using an upper-case &#34;E&#34;
 G   like g, but with an upper-case &#34;E&#34; (if applicable)
 b   an unsigned integer, in binary
 C   special: invokes the arg as code, see below</pre>

<p>Compatibility:</p>

<pre> i   a synonym for %d
 D   a synonym for %ld
 U   a synonym for %lu
 O   a synonym for %lo
 F   a synonym for %f</pre>

<p>Perl 5 compatibility:</p>

<pre> n   produces a runtime exception (see below)
 p   produces a runtime exception</pre>

<p>The special format directive, <code>%C</code> invokes the target argument as code, passing it the result string that has been generated thus far and the argument array.</p>

<p>Here&#39;s an example of its use:</p>

<pre> sprintf &#34;%d%C is %d digits long&#34;,
    $num,
    sub($s,@args is rw) {@args[2]=$s.elems},
    0;</pre>

<p>The special directive, <code>%n</code> does not work in Perl 6 because of the difference in parameter passing conventions, but the example above simulates its effect using <code>%C</code>.</p>

<p>Modifiers change the meaning of format directives. The most important being support for complex numbers (a basic type in Perl). Here are all of the modifiers and what they modify:</p>

<pre> h interpret integer as native &#34;short&#34; (typically int16)
 l interpret integer as native &#34;long&#34; (typically int32 or int64)
 ll interpret integer as native &#34;long long&#34; (typically int64)
 L interpret integer as native &#34;long long&#34; (typically uint64)
 q interpret integer as native &#34;quads&#34; (typically int64 or larger)
 m interpret value as a complex number</pre>

<p>The <code>m</code> modifier works with <code>d,u,o,x,F,E,G,X,E</code> and <code>G</code> format directives, and the directive applies to both the real and imaginary parts of the complex number.</p>

<p>Examples:</p>

<pre> sprintf &#34;%ld a big number, %lld a bigger number, %mf complexity\n&#34;,
        4294967295, 4294967296, Complex.new(1,2);</pre>

<dt><a name="substr"
>substr</a></dt>

<dd>
<pre> our Str multi substr (Str $s, StrPos $start, StrLen $length?) is rw
 our Str multi substr (Str $s, StrPos $start, StrPos $end?) is rw</pre>

<p><code>substr</code> returns part of an existing string. You control what part by passing a starting position and optionally either an end position or length. If you just pass two numbers, positionally, then they will be used as the start and length.</p>

<p>Here is an example of its use:</p>

<pre> $initials = substr($first_name,0,1) ~ substr($last_name,0,1);</pre>

<p>Optionally, you can use substr on the left hand side of an assignment like so:</p>

<pre> substr($string, 1, 5) = &#34;fred&#34;;</pre>

<p>If the replacement string is longer or shorter than the matched sub-string, then the original string will be dynamically resized.</p>

<p>[ Note: Is the word &#34;length&#34; a problem, here, given Perl 6&#39;s general desire to stop using length with respect to strings? -ajs ]</p>

<dt><a name="unpack"
>unpack
<dt><a name="vec"
>vec</a></dt>

<dd>
<p>Should replace vec with declared arrays of bit, uint2, uint4, etc.</p>

<dt><a name="words"
>words</a></dt>

<dd>
<pre> our List multi Str::words ( Rule $matcher = /\S+/,  Str $input, Int $limit = inf )
 our List multi Str::words ( Str $input ; Rule $matcher = /\S+/, Int $limit = inf )</pre>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Control::Basic"
>Control::Basic</a></h2>

<dl>
<dt><a name="caller"
>caller</a></dt>

<dd>
<p>TODO</p>

<dt><a name="eval"
>eval</a></dt>

<dd>
<pre> multi Control::Basic::eval ( Str $code, Grammar :$lang = CALLER::&#60;$?PARSER&#62;)</pre>

<p>Execute <code>$code</code> as if it were code written in <code>$lang</code>. The default is the language in effect at the exact location of the eval call.</p>

<p>Returns whatever <code>$code</code> returns, or undef on error.</p>

<dt><a name="evalfile"
>evalfile</a></dt>

<dd>
<pre> multi Control::Basic::evalfile (Str $filename ; Grammar :$lang = Perl6)</pre>

<p>Behaves like, and replaces Perl 5 <code>do EXPR</code>, with optional <code>$lang</code> support.</p>

<dt><a name="exit"
>exit</a></dt>

<dd>
<pre> multi Control::Basic::exit ( Int $status = 0)</pre>

<p>Stops all program execution, and returns <code>$status</code> to the calling environment.</p>

<dt><a name="nothing"
>nothing</a></dt>

<dd>
<a href="#" onclick="return tog_quote(38);">
<div ID="header_shown_38" style="display: none;">
- Hide the snippet from t/builtins/control_flow/nothing.t (line 11 ~ line 21) -
</div>
<div ID="header_hidden_38" style="display: block;">
- Show the snippet from t/builtins/control_flow/nothing.t (line 11 ~ line 21) -
</div>
</a>
<div ID="hide_38" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Control::Basic&quot; /nothing/&gt;

plan 2;

lives_ok { nothing }, &quot;nothing() works&quot;;

# Probably the most commonly used form:
my $var;
nothing while $var++ &lt; 3;
# We're still here, so pass().
pass &quot;nothing() works in while&quot;;</pre>
</div>


<pre> multi Control::Basic::nothing ()</pre>

<p>No operation. Literally does nothing.</p>

<dt><a name="sleep"
>sleep</a></dt>

<dd>
<pre> our Num multi Control::Basic::sleep ( Num $for = Inf )</pre>

<p>Attempt to sleep for up to <code>$for</code> seconds. Implementations are obligated to support sub-second resolutions if that is at all possible.</p>

<p>This is exactly the same as:</p>

<pre> $$.sleep($for)</pre>

<p>See <code>Synopsis 17: Concurrency</code> for more details.</p>

<dt><a name="want"
>want</a></dt>

<dd>
<p>TODO</p>

<dt><a name="word"
>word</a></dt>

<dd>
<p><code>word</code> is almost exactly the same as <code>macro</code>, only defines macros which take no arguments. For example:</p>

<pre> word foo { &#34;&#39;foo&#39;.say&#34; }
 foo;</pre>

<p>[ Refs: Message-ID: &#60;20050614164447.GA14958@wall.org&#62;</p>

<pre>    Date: Tue, 14 Jun 2005 09:44:47 -0700  (12:44 EDT)
    From: Larry Wall &#60;larry@wall.org&#62;
    To: perl6-language@perl.org
]</pre>

<dt><a name="die"
>die
<dt><a name="fail"
>fail</a></dt>

<dd>
<p><b>TODO</b>: Research the exception handling system.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Conversions"
>Conversions</a></h2>

<dl>
<dt><a name="bless"
>bless</a></dt>

<dd>
<pre> our Object multi method Class::bless( Object::RepCandidate $candidate )
 our Object multi method Class::bless( *%args )</pre>

<p><code>bless</code> is only available as a method which can be called on a class object like so:</p>

<pre> $object = $class.bless(k1 =&#62; $v1, k2 =&#62; $v2, ...);</pre>

<p>A newly created object, based on either the <code>$candidate</code> representation or a newly created representation (initialized with the <code>%args</code> that are passed in) when the second form is used.</p>

<p>It automatically calls all appropriate BUILD routines by calling the BUILDALL routine for the current class, which initializes the object in least-derived to most-derived order. See <a href="http://search.cpan.org/perldoc?S12#Objects" class="podlinkpod"
>&#34;Objects&#34; in S12</a> for more detailed information on object creation.</p>

<a href="#" onclick="return tog_quote(9);">
<div ID="header_shown_9" style="display: none;">
- Hide the snippet from t/builtins/strings/ord_and_chr.t (line 11 ~ line 136) -
</div>
<div ID="header_hidden_9" style="display: block;">
- Show the snippet from t/builtins/strings/ord_and_chr.t (line 11 ~ line 136) -
</div>
</a>
<div ID="hide_9" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Conversions&quot; /ord/&gt;
# L&lt;S29/&quot;Conversions&quot; /chr/&gt;

# What is the best way to test 0 through 31??
my @maps = (
&nbsp; &quot; &quot;, &nbsp; &nbsp;32,
&nbsp; &quot;!&quot;, &nbsp; &nbsp;33,
&nbsp; &quot;\&quot;&quot;, &nbsp; 34,
&nbsp; &quot;#&quot;, &nbsp; &nbsp;35,
&nbsp; &quot;$&quot;, &nbsp; &nbsp;36,
&nbsp; &quot;%&quot;, &nbsp; &nbsp;37,
&nbsp; &quot;&amp;&quot;, &nbsp; &nbsp;38,
&nbsp; &quot;\'&quot;, &nbsp; 39,
&nbsp; &quot;(&quot;, &nbsp; &nbsp;40,
&nbsp; &quot;)&quot;, &nbsp; &nbsp;41,
&nbsp; &quot;*&quot;, &nbsp; &nbsp;42,
&nbsp; &quot;+&quot;, &nbsp; &nbsp;43,
&nbsp; &quot;,&quot;, &nbsp; &nbsp;44,
&nbsp; &quot;-&quot;, &nbsp; &nbsp;45,
&nbsp; &quot;.&quot;, &nbsp; &nbsp;46,
&nbsp; &quot;/&quot;, &nbsp; &nbsp;47,
&nbsp; &quot;0&quot;, &nbsp; &nbsp;48,
&nbsp; &quot;1&quot;, &nbsp; &nbsp;49,
&nbsp; &quot;2&quot;, &nbsp; &nbsp;50,
&nbsp; &quot;3&quot;, &nbsp; &nbsp;51,
&nbsp; &quot;4&quot;, &nbsp; &nbsp;52,
&nbsp; &quot;5&quot;, &nbsp; &nbsp;53,
&nbsp; &quot;6&quot;, &nbsp; &nbsp;54,
&nbsp; &quot;7&quot;, &nbsp; &nbsp;55,
&nbsp; &quot;8&quot;, &nbsp; &nbsp;56,
&nbsp; &quot;9&quot;, &nbsp; &nbsp;57,
&nbsp; &quot;:&quot;, &nbsp; &nbsp;58,
&nbsp; &quot;;&quot;, &nbsp; &nbsp;59,
&nbsp; &quot;&lt;&quot;, &nbsp; &nbsp;60,
&nbsp; &quot;=&quot;, &nbsp; &nbsp;61,
&nbsp; &quot;&gt;&quot;, &nbsp; &nbsp;62,
&nbsp; &quot;?&quot;, &nbsp; &nbsp;63,
&nbsp; &quot;@&quot;, &nbsp; &nbsp;64,
&nbsp; &quot;A&quot;, &nbsp; &nbsp;65,
&nbsp; &quot;B&quot;, &nbsp; &nbsp;66,
&nbsp; &quot;C&quot;, &nbsp; &nbsp;67,
&nbsp; &quot;D&quot;, &nbsp; &nbsp;68,
&nbsp; &quot;E&quot;, &nbsp; &nbsp;69,
&nbsp; &quot;F&quot;, &nbsp; &nbsp;70,
&nbsp; &quot;G&quot;, &nbsp; &nbsp;71,
&nbsp; &quot;H&quot;, &nbsp; &nbsp;72,
&nbsp; &quot;I&quot;, &nbsp; &nbsp;73,
&nbsp; &quot;J&quot;, &nbsp; &nbsp;74,
&nbsp; &quot;K&quot;, &nbsp; &nbsp;75,
&nbsp; &quot;L&quot;, &nbsp; &nbsp;76,
&nbsp; &quot;M&quot;, &nbsp; &nbsp;77,
&nbsp; &quot;N&quot;, &nbsp; &nbsp;78,
&nbsp; &quot;O&quot;, &nbsp; &nbsp;79,
&nbsp; &quot;P&quot;, &nbsp; &nbsp;80,
&nbsp; &quot;Q&quot;, &nbsp; &nbsp;81,
&nbsp; &quot;R&quot;, &nbsp; &nbsp;82,
&nbsp; &quot;S&quot;, &nbsp; &nbsp;83,
&nbsp; &quot;T&quot;, &nbsp; &nbsp;84,
&nbsp; &quot;U&quot;, &nbsp; &nbsp;85,
&nbsp; &quot;V&quot;, &nbsp; &nbsp;86,
&nbsp; &quot;W&quot;, &nbsp; &nbsp;87,
&nbsp; &quot;X&quot;, &nbsp; &nbsp;88,
&nbsp; &quot;Y&quot;, &nbsp; &nbsp;89,
&nbsp; &quot;Z&quot;, &nbsp; &nbsp;90,
&nbsp; &quot;[&quot;, &nbsp; &nbsp;91,
&nbsp; &quot;\\&quot;, &nbsp; 92,
&nbsp; &quot;]&quot;, &nbsp; &nbsp;93,
&nbsp; &quot;^&quot;, &nbsp; &nbsp;94,
&nbsp; &quot;_&quot;, &nbsp; &nbsp;95,
&nbsp; &quot;`&quot;, &nbsp; &nbsp;96,
&nbsp; &quot;a&quot;, &nbsp; &nbsp;97,
&nbsp; &quot;b&quot;, &nbsp; &nbsp;98,
&nbsp; &quot;c&quot;, &nbsp; &nbsp;99,
&nbsp; &quot;d&quot;, &nbsp; &nbsp;100,
&nbsp; &quot;e&quot;, &nbsp; &nbsp;101,
&nbsp; &quot;f&quot;, &nbsp; &nbsp;102,
&nbsp; &quot;g&quot;, &nbsp; &nbsp;103,
&nbsp; &quot;h&quot;, &nbsp; &nbsp;104,
&nbsp; &quot;i&quot;, &nbsp; &nbsp;105,
&nbsp; &quot;j&quot;, &nbsp; &nbsp;106,
&nbsp; &quot;k&quot;, &nbsp; &nbsp;107,
&nbsp; &quot;l&quot;, &nbsp; &nbsp;108,
&nbsp; &quot;m&quot;, &nbsp; &nbsp;109,
&nbsp; &quot;n&quot;, &nbsp; &nbsp;110,
&nbsp; &quot;o&quot;, &nbsp; &nbsp;111,
&nbsp; &quot;p&quot;, &nbsp; &nbsp;112,
&nbsp; &quot;q&quot;, &nbsp; &nbsp;113,
&nbsp; &quot;r&quot;, &nbsp; &nbsp;114,
&nbsp; &quot;s&quot;, &nbsp; &nbsp;115,
&nbsp; &quot;t&quot;, &nbsp; &nbsp;116,
&nbsp; &quot;u&quot;, &nbsp; &nbsp;117,
&nbsp; &quot;v&quot;, &nbsp; &nbsp;118,
&nbsp; &quot;w&quot;, &nbsp; &nbsp;119,
&nbsp; &quot;x&quot;, &nbsp; &nbsp;120,
&nbsp; &quot;y&quot;, &nbsp; &nbsp;121,
&nbsp; &quot;z&quot;, &nbsp; &nbsp;122,
&nbsp; &quot;|&quot;, &nbsp; &nbsp;124,
&nbsp; &quot;}&quot;, &nbsp; &nbsp;125,
&nbsp; &quot;~&quot;, &nbsp; &nbsp;126,

&nbsp; # Unicode tests
&nbsp; &quot;&quot;, &nbsp; &nbsp;228,
&nbsp; &quot;&quot;, &nbsp; &nbsp;8364,
&nbsp; &quot;&quot;, &nbsp; &nbsp;187,
&nbsp; &quot;&quot;, &nbsp; &nbsp;171,

&nbsp; # Special chars
&nbsp; &quot;\o00&quot;, 0,
&nbsp; &quot;\o01&quot;, 1,
&nbsp; &quot;\o03&quot;, 3,
);

plan 32+@maps;

for @maps -&gt; $char, $code {
&nbsp; my $descr = &quot;\\{$code}{$code &gt;= 32 ?? &quot; == '{$char}'&quot; !! &quot;&quot;}&quot;;
&nbsp; is ord($char), $code, &quot;ord() works for $descr&quot;;
&nbsp; is chr($code), $char, &quot;chr() works for $descr&quot;;
}

for 0..31 -&gt; $code {
&nbsp; my $char = chr($code);
&nbsp; is ord($char), $code, &quot;ord(chr($code)) is $code&quot;;
}</pre>
</div>


<dt><a name="chr"
>chr</a></dt>

<dd>
<a href="#" onclick="return tog_quote(10);">
<div ID="header_shown_10" style="display: none;">
- Hide the snippet from t/builtins/strings/ord_and_chr.t (line 12 ~ line 136) -
</div>
<div ID="header_hidden_10" style="display: block;">
- Show the snippet from t/builtins/strings/ord_and_chr.t (line 12 ~ line 136) -
</div>
</a>
<div ID="hide_10" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/&quot;Conversions&quot; /chr/&gt;

# What is the best way to test 0 through 31??
my @maps = (
&nbsp; &quot; &quot;, &nbsp; &nbsp;32,
&nbsp; &quot;!&quot;, &nbsp; &nbsp;33,
&nbsp; &quot;\&quot;&quot;, &nbsp; 34,
&nbsp; &quot;#&quot;, &nbsp; &nbsp;35,
&nbsp; &quot;$&quot;, &nbsp; &nbsp;36,
&nbsp; &quot;%&quot;, &nbsp; &nbsp;37,
&nbsp; &quot;&amp;&quot;, &nbsp; &nbsp;38,
&nbsp; &quot;\'&quot;, &nbsp; 39,
&nbsp; &quot;(&quot;, &nbsp; &nbsp;40,
&nbsp; &quot;)&quot;, &nbsp; &nbsp;41,
&nbsp; &quot;*&quot;, &nbsp; &nbsp;42,
&nbsp; &quot;+&quot;, &nbsp; &nbsp;43,
&nbsp; &quot;,&quot;, &nbsp; &nbsp;44,
&nbsp; &quot;-&quot;, &nbsp; &nbsp;45,
&nbsp; &quot;.&quot;, &nbsp; &nbsp;46,
&nbsp; &quot;/&quot;, &nbsp; &nbsp;47,
&nbsp; &quot;0&quot;, &nbsp; &nbsp;48,
&nbsp; &quot;1&quot;, &nbsp; &nbsp;49,
&nbsp; &quot;2&quot;, &nbsp; &nbsp;50,
&nbsp; &quot;3&quot;, &nbsp; &nbsp;51,
&nbsp; &quot;4&quot;, &nbsp; &nbsp;52,
&nbsp; &quot;5&quot;, &nbsp; &nbsp;53,
&nbsp; &quot;6&quot;, &nbsp; &nbsp;54,
&nbsp; &quot;7&quot;, &nbsp; &nbsp;55,
&nbsp; &quot;8&quot;, &nbsp; &nbsp;56,
&nbsp; &quot;9&quot;, &nbsp; &nbsp;57,
&nbsp; &quot;:&quot;, &nbsp; &nbsp;58,
&nbsp; &quot;;&quot;, &nbsp; &nbsp;59,
&nbsp; &quot;&lt;&quot;, &nbsp; &nbsp;60,
&nbsp; &quot;=&quot;, &nbsp; &nbsp;61,
&nbsp; &quot;&gt;&quot;, &nbsp; &nbsp;62,
&nbsp; &quot;?&quot;, &nbsp; &nbsp;63,
&nbsp; &quot;@&quot;, &nbsp; &nbsp;64,
&nbsp; &quot;A&quot;, &nbsp; &nbsp;65,
&nbsp; &quot;B&quot;, &nbsp; &nbsp;66,
&nbsp; &quot;C&quot;, &nbsp; &nbsp;67,
&nbsp; &quot;D&quot;, &nbsp; &nbsp;68,
&nbsp; &quot;E&quot;, &nbsp; &nbsp;69,
&nbsp; &quot;F&quot;, &nbsp; &nbsp;70,
&nbsp; &quot;G&quot;, &nbsp; &nbsp;71,
&nbsp; &quot;H&quot;, &nbsp; &nbsp;72,
&nbsp; &quot;I&quot;, &nbsp; &nbsp;73,
&nbsp; &quot;J&quot;, &nbsp; &nbsp;74,
&nbsp; &quot;K&quot;, &nbsp; &nbsp;75,
&nbsp; &quot;L&quot;, &nbsp; &nbsp;76,
&nbsp; &quot;M&quot;, &nbsp; &nbsp;77,
&nbsp; &quot;N&quot;, &nbsp; &nbsp;78,
&nbsp; &quot;O&quot;, &nbsp; &nbsp;79,
&nbsp; &quot;P&quot;, &nbsp; &nbsp;80,
&nbsp; &quot;Q&quot;, &nbsp; &nbsp;81,
&nbsp; &quot;R&quot;, &nbsp; &nbsp;82,
&nbsp; &quot;S&quot;, &nbsp; &nbsp;83,
&nbsp; &quot;T&quot;, &nbsp; &nbsp;84,
&nbsp; &quot;U&quot;, &nbsp; &nbsp;85,
&nbsp; &quot;V&quot;, &nbsp; &nbsp;86,
&nbsp; &quot;W&quot;, &nbsp; &nbsp;87,
&nbsp; &quot;X&quot;, &nbsp; &nbsp;88,
&nbsp; &quot;Y&quot;, &nbsp; &nbsp;89,
&nbsp; &quot;Z&quot;, &nbsp; &nbsp;90,
&nbsp; &quot;[&quot;, &nbsp; &nbsp;91,
&nbsp; &quot;\\&quot;, &nbsp; 92,
&nbsp; &quot;]&quot;, &nbsp; &nbsp;93,
&nbsp; &quot;^&quot;, &nbsp; &nbsp;94,
&nbsp; &quot;_&quot;, &nbsp; &nbsp;95,
&nbsp; &quot;`&quot;, &nbsp; &nbsp;96,
&nbsp; &quot;a&quot;, &nbsp; &nbsp;97,
&nbsp; &quot;b&quot;, &nbsp; &nbsp;98,
&nbsp; &quot;c&quot;, &nbsp; &nbsp;99,
&nbsp; &quot;d&quot;, &nbsp; &nbsp;100,
&nbsp; &quot;e&quot;, &nbsp; &nbsp;101,
&nbsp; &quot;f&quot;, &nbsp; &nbsp;102,
&nbsp; &quot;g&quot;, &nbsp; &nbsp;103,
&nbsp; &quot;h&quot;, &nbsp; &nbsp;104,
&nbsp; &quot;i&quot;, &nbsp; &nbsp;105,
&nbsp; &quot;j&quot;, &nbsp; &nbsp;106,
&nbsp; &quot;k&quot;, &nbsp; &nbsp;107,
&nbsp; &quot;l&quot;, &nbsp; &nbsp;108,
&nbsp; &quot;m&quot;, &nbsp; &nbsp;109,
&nbsp; &quot;n&quot;, &nbsp; &nbsp;110,
&nbsp; &quot;o&quot;, &nbsp; &nbsp;111,
&nbsp; &quot;p&quot;, &nbsp; &nbsp;112,
&nbsp; &quot;q&quot;, &nbsp; &nbsp;113,
&nbsp; &quot;r&quot;, &nbsp; &nbsp;114,
&nbsp; &quot;s&quot;, &nbsp; &nbsp;115,
&nbsp; &quot;t&quot;, &nbsp; &nbsp;116,
&nbsp; &quot;u&quot;, &nbsp; &nbsp;117,
&nbsp; &quot;v&quot;, &nbsp; &nbsp;118,
&nbsp; &quot;w&quot;, &nbsp; &nbsp;119,
&nbsp; &quot;x&quot;, &nbsp; &nbsp;120,
&nbsp; &quot;y&quot;, &nbsp; &nbsp;121,
&nbsp; &quot;z&quot;, &nbsp; &nbsp;122,
&nbsp; &quot;|&quot;, &nbsp; &nbsp;124,
&nbsp; &quot;}&quot;, &nbsp; &nbsp;125,
&nbsp; &quot;~&quot;, &nbsp; &nbsp;126,

&nbsp; # Unicode tests
&nbsp; &quot;&quot;, &nbsp; &nbsp;228,
&nbsp; &quot;&quot;, &nbsp; &nbsp;8364,
&nbsp; &quot;&quot;, &nbsp; &nbsp;187,
&nbsp; &quot;&quot;, &nbsp; &nbsp;171,

&nbsp; # Special chars
&nbsp; &quot;\o00&quot;, 0,
&nbsp; &quot;\o01&quot;, 1,
&nbsp; &quot;\o03&quot;, 3,
);

plan 32+@maps;

for @maps -&gt; $char, $code {
&nbsp; my $descr = &quot;\\{$code}{$code &gt;= 32 ?? &quot; == '{$char}'&quot; !! &quot;&quot;}&quot;;
&nbsp; is ord($char), $code, &quot;ord() works for $descr&quot;;
&nbsp; is chr($code), $char, &quot;chr() works for $descr&quot;;
}

for 0..31 -&gt; $code {
&nbsp; my $char = chr($code);
&nbsp; is ord($char), $code, &quot;ord(chr($code)) is $code&quot;;
}</pre>
</div>


<dt><a name="ord"
>ord</a></dt>

<dd>
<pre> our Uni multi Str::chr( Uni $codepoint )
 our Uni multi Str::ord( Uni $character )
 multi Str::ord( Str $string )</pre>

<p>These functions are available for purposes of backward compatibility. <code>chr</code> takes a <code>Uni</code> and returns the exact same value with no change. This is because, in Perl 6, a Uni is both an integer codepoint when numified and a single character when stringified. Thus, chr is just:</p>

<pre> our Uni multi Str::chr( Uni $codepoint) { $codepoint; }</pre>

<p><code>ord</code> is almost the same, but it also has a form that takes a string. In a scalar context, the return value is the <code>Uni</code> representing the first codepoint in the string. In a list context, the return value is the list of <code>Uni</code>s representing the entire string.</p>

<p>An integer can be passed to <code>chr</code>, but it will automatically be upgraded to a Uni (by interpreting it as a Unicode codepoint).</p>

<p>Be aware that the stringification of certain <code>Uni</code>s will fail because they have no stand-alone stringified interpretation. Similarly, the creation of a <code>Uni</code> from an integer might fail due to the integer being out of range. If that happens, an undefined <code>Uni</code> is always returned. Similarly, <code>chr(undef)</code> or <code>ord(undef)</code> will force the reutrn of an undefined <code>Uni</code>.</p>

<dt><a name="list"
>list</a></dt>

<dd>
<pre> our List multi Conversions::List::list ( *@list )</pre>

<p>Forces List Context on it&#39;s arguments, and returns them.</p>

<dt><a name="item"
>item</a></dt>

<dd>
<pre> our Item multi Conversions::Item::item ( $item )</pre>

<p>Forces generic Item context on its argument, and returns it.</p>

<dt><a name=":16,_:8,_:2,_:10"
>:16, :8, :2, :10</a></dt>

<dd>
<pre> our Num multi prefix:&#60;:16&#62; ( Str $hexstr )</pre>

<a href="#" onclick="return tog_quote(8);">
<div ID="header_shown_8" style="display: none;">
- Hide the snippet from t/syntax/numbers/hexadecimal.t (line 13 ~ line 61) -
</div>
<div ID="header_hidden_8" style="display: block;">
- Show the snippet from t/syntax/numbers/hexadecimal.t (line 13 ~ line 61) -
</div>
</a>
<div ID="hide_8" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/Conversions/&quot;prefix:&lt;:16&gt;&quot;&gt;
# L&lt;S02/Literals/&quot;:16&lt;DEAD_BEEF&gt;&quot;&gt;

# 0 - 9 is the same int
is(:16(0), 0, 'got the correct int value from hex 0');
is(:16(1), 1, 'got the correct int value from hex 1');
is(:16(2), 2, 'got the correct int value from hex 2');
is(:16(3), 3, 'got the correct int value from hex 3');
is(:16(4), 4, 'got the correct int value from hex 4');
is(:16(5), 5, 'got the correct int value from hex 5');
is(:16(6), 6, 'got the correct int value from hex 6');
is(:16(7), 7, 'got the correct int value from hex 7');
is(:16(8), 8, 'got the correct int value from hex 8');
is(:16(9), 9, 'got the correct int value from hex 9');

# check uppercase vals
is(:16(&quot;A&quot;), 10, 'got the correct int value from hex A');
is(:16(&quot;B&quot;), 11, 'got the correct int value from hex B');
is(:16(&quot;C&quot;), 12, 'got the correct int value from hex C');
is(:16(&quot;D&quot;), 13, 'got the correct int value from hex D');
is(:16(&quot;E&quot;), 14, 'got the correct int value from hex E');
is(:16(&quot;F&quot;), 15, 'got the correct int value from hex F');

# check lowercase vals
is(:16(&quot;a&quot;), 10, 'got the correct int value from hex a');
is(:16(&quot;b&quot;), 11, 'got the correct int value from hex b');
is(:16(&quot;c&quot;), 12, 'got the correct int value from hex c');
is(:16(&quot;d&quot;), 13, 'got the correct int value from hex d');
is(:16(&quot;e&quot;), 14, 'got the correct int value from hex e');
is(:16(&quot;f&quot;), 15, 'got the correct int value from hex f');

# check 2 digit numbers
is(:16(10), 16, 'got the correct int value from hex 10');
is(:16(20), 32, 'got the correct int value from hex 20');
is(:16(30), 48, 'got the correct int value from hex 30');
is(:16(40), 64, 'got the correct int value from hex 40');
is(:16(50), 80, 'got the correct int value from hex 50');

# check 3 digit numbers
is(:16(100), 256, 'got the correct int value from hex 100');

# check some weird versions
is(:16(&quot;FF&quot;), 255, 'got the correct int value from hex FF');
is(:16(&quot;fF&quot;), 255, 'got the correct int value from (mixed case) hex fF');

# some random mad up hex strings (these values are checked against perl5)
is :16(&quot;FFACD5FE&quot;), 4289517054, 'got the correct int value from hex FFACD5FE';
is :16(&quot;AAA4872D&quot;), 2862909229, 'got the correct int value from hex AAA4872D';
is :16&lt;DEAD_BEEF&gt;, 0xDEADBEEF, 'got the correct int value from hex DEAD_BEEF';</pre>
</div>


<pre> our Num multi prefix:&#60;:8&#62; ( Str $octstr )</pre>

<a href="#" onclick="return tog_quote(7);">
<div ID="header_shown_7" style="display: none;">
- Hide the snippet from t/syntax/numbers/octal.t (line 13 ~ line 38) -
</div>
<div ID="header_hidden_7" style="display: block;">
- Show the snippet from t/syntax/numbers/octal.t (line 13 ~ line 38) -
</div>
</a>
<div ID="hide_7" style="display:none; border:1px solid">
<pre style="margin-left: 6px"># L&lt;S29/Conversions/&quot;prefix:&lt;:8&gt;&quot;&gt;
# L&lt;S02/Literals/&quot;:8&lt;177777&gt;&quot;&gt;

# 0 - 7 is the same int
is(:8(0), 0, 'got the correct int value from oct 0');
is(:8(1), 1, 'got the correct int value from oct 1');
is(:8(2), 2, 'got the correct int value from oct 2');
is(:8(3), 3, 'got the correct int value from oct 3');
is(:8(4), 4, 'got the correct int value from oct 4');
is(:8(5), 5, 'got the correct int value from oct 5');
is(:8(6), 6, 'got the correct int value from oct 6');
is(:8(7), 7, 'got the correct int value from oct 7');

# check 2 digit numbers
is(:8(10), 8, 'got the correct int value from oct 10');
is(:8(20), 16, 'got the correct int value from oct 20');
is(:8(30), 24, 'got the correct int value from oct 30');
is(:8(40), 32, 'got the correct int value from oct 40');
is(:8(50), 40, 'got the correct int value from oct 50');

# check 3 digit numbers
is(:8(100), 64, 'got the correct int value from oct 100');

# check some weird versions
is(:8(&quot;77&quot;), 63, 'got the correct int value from oct 77');
is(:8&lt;177777&gt;, 65535, 'got the correct int value from oct 177777');</pre>
</div>


<pre> our Num multi prefix:&#60;:2&#62; ( Str $binstr )
 our Num multi prefix:&#60;:10&#62; ( Str $decstr )
 etc.</pre>

<p>Interprets string as a number, with a default hexadecimal/octal/binary/decimal radix. Any radix prefix (0b, 0d, 0x, 0o) mentioned inside the string will override this operator (this statement is true: 10 == :8(&#34;0d10&#34;)), except 0b and 0d will be interpreted as hex digits by :16 (<code>hex(&#34;0d10&#34;) == :16 &#34;0d10&#34;</code>). <code>fail</code>s on failure.</p>

<p>These aren&#39;t really functions, syntactically, but adverbial forms that just happen to allow a parenthesize argument. But more typically you&#39;ll see</p>

<pre>    :4&#60;222&#62;
    :16&#60;deadbeef&#62;</pre>

<p>and such.</p>

<p>Replaces Perl 5 <code>hex</code> and <code>oct</code>.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Time"
>Time</a></h2>

<dl>
<dt><a name="gmtime"
>gmtime</a></dt>

<dd>
<pre> our Time multi Time::gmtime ( Time $time? )
 our Time multi method Time::gmtime ( Time $time: )</pre>

<p>Identical to:</p>

<pre> Time::localtime(:$time,:tz&#60;GMT&#62;)</pre>

<dt><a name="localtime"
>localtime</a></dt>

<dd>
<pre> our Time multi Time::localtime ( Time $time?, Time::Zone $tz? )
 our Time multi method Time::localtime ( Time $time: Time::Zone $tz? )</pre>

<p>Returns a time object whose default timezone is <code>$tz</code> (or the system&#39;s default timezone if none is provided).</p>

<p>If used as a function, and no time is provided, the current time is used.</p>

<p>Note that no matter what, <code>$time</code>&#39;s concept of &#34;its timezone&#34; is discarded in favor of something new.</p>

<dt><a name="time"
>time</a></dt>

<dd>
<pre> our Time multi Time::time()</pre>

<p>Returns a <code>Time</code> object. There are a number of uses for this object, all of which can be found in the documentation for <code>Time</code>.</p>

<p>There is, by default, no timezone associated with this Time object, so whatever default the system has will take over if timezone-specific data is accessed.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="OS"
>OS</a></h2>

<dl>
<dt><a name="getpw"
>getpw</a></dt>

<dd>
<pre> our OS::PW multi OS::getpw()
 our OS::PW multi OS::getpw( Int $uid )
 our OS::PW multi OS::getpw( Str $name )

 our OS::PW multi method OS::PWEnt::getpw( OS::PWEnt $pw: )
 our OS::PW multi method OS::PWEnt::getpw( OS::PWEnt $pw: Int $uid )
 our OS::PW multi method OS::PWEnt::getpw( OS::PWEnt $pw: Str $name )</pre>

<p>The <code>getpw</code> function operates on system login information, returning data about users in the form of an <code>OS::PW</code> object (&#34;PW&#34; refers to the historical <code>getpw*</code> functions that are part of the POSIX standard, and stands for &#34;password&#34;).</p>

<p>When given no parameters, the &#34;next&#34; user entry is returned (<code>undef</code> is returned when the list of users has been exhausted).</p>

<p>When <code>$uid</code> is provided, a user with the given UID is found and returned. <code>undef</code> is returned if no matching entry is found.</p>

<p>When <code>$name</code> is provided, a user with the matching name is found and returned. <code>undef</code> is returned if no matching entry is found.</p>

<p>The return value is an object that represents the system-specific information about the user. When numified, this object returns the UID of the user. When stringified, this object returns the username.</p>

<p>Therefore, the typical convention of:</p>

<pre>  my Int $uid = getpw(~$name);</pre>

<p>and</p>

<pre>  my Str $name = getpw(+$uid);</pre>

<p>Will work as expected.</p>

<p>See the documentation for the <code>OS::PW</code> and <code>OS::PWEnt</code> classes for more information and the equivalent of the Perl 5 setpwent / endpwent functions.</p>

<p>WARNING: Even when used as a method on an <code>OS::PWEnt</code> object, there may be system-specific, global state associated with the implementation of these routines.</p>

<p>[Note: TODO setpgrp setpriority times -ajs ]</p>

<dt><a name="chroot"
>chroot</a></dt>

<dd>
<pre> our Bool multi OS::chroot ( Str $path = CALLER::&#60;$_&#62; )</pre>

<p>On POSIX systems, changes the context of the current process such that the &#34;root&#34; directory becomes <code>$path</code> and all rooted paths (those that begin with a leading path separator) are relative to that path. For security reasons, many operating systems limit this functionality to the superuser. The return value will be true on success.</p>

<dt><a name="getlogin"
>getlogin</a></dt>

<dd>
<pre> our Str multi OS::getlogin ()</pre>

<p>Returns the username of the account running the program. This may not be as secure as using <code>getpwuid</code> on some platforms.</p>

<dt><a name="kill"
>kill</a></dt>

<dd>
<pre> our Bool multi OS::kill ( OS::Signal $signal, Bool :$group, *@pids )
 our Bool multi method Conc::Proc::kill ( Conc::Proc $pid: OS::Signal $signal?, Bool :$group )</pre>

<p>Sends the given <code>$signal</code> to the process(es) given and returns a boolean value indicating success (true) if all of the processes existed and were sent the signal and failure (false) if any of the processes did not exist or the signal could not be delivered to them.</p>

<p>The <code>$signal</code> can be initialized from an integer signal number or a string. Common signals are:</p>

<pre> KILL - stop the process, do not allow it to exit gracefully
 TERM - stop the process, allow it to exit gracefully
 HUP  - Hangup, often used as a request to re-run from scratch
 STOP - Pause execution
 CONT - Continue after a STOP</pre>

<p>Consult your operating system documentation for the full list of signal names and numbers. For compatibility, a signal name may be prefixed with &#34;SIG&#34;.</p>

<p>The method form may omit the signal. In this case, the default signal is <code>&#39;TERM&#39;</code>.</p>

<p>If the <code>:group</code> named parameter is passed, <code>kill</code> will attempt to send the signal to a process <i>group</i> rather than a single process. This functionality is platform-specific.</p>

<p>The special signal <code>0</code> can be sent which does not actually deliver a signal at all, and is used to determine if processes are still running:</p>

<pre>  say &#34;Still running&#34; if $proc.kill(0);</pre>

<dt><a name="run"
>run</a></dt>

<dd>
<pre> our Conc::Proc::Status multi OS::run ( ; Str $command )
 our Conc::Proc::Status multi OS::run ( ; Str $path, *@args )
 our Conc::Proc::Status multi OS::run ( Str @path_and_args )

 our Conc::Proc multi OS::run ( ; Str $command, Bool :$bg! )
 our Conc::Proc multi OS::run ( ; Str $path, Bool :$bg!, *@args )
 our Conc::Proc multi OS::run ( Str @path_and_args, Bool :$bg! )</pre>

<p><code>run</code> executes an external program, and returns control to the caller once the program has exited.</p>

<p>The default form expects a single string argument which contains the full command-line. This command-line will be scanned for special characters that the operating system&#39;s shell might interpret such as <code>;</code> or embedded quotes. If any are found, the command will be run through a sub-shell in an operating system specific fashion (on POSIX systems, this means <code>sh -c</code>).</p>

<p>If called like this:</p>

<pre> run( :path&#60;&#39;/some/path&#39;&#62;, &#39;arg1&#39;, &#39;arg2&#39;, ... )</pre>

<p>or with a single array (containing both the path and arguments), then the path given is executed directly with no shell interpretation.</p>

<p>The return value is the exit status of the program, and can be evaluated in the following contexts:</p>

<pre> Bool - True = success; False = failure
 Int  - Exit status (per the .exit method)</pre>

<p>See <code>wait</code> for more detail on how the <code>Conc::Proc::Status</code> object is used.</p>

<p>On failure to execute, an undefined value is returned.</p>

<p>If the <code>:bg</code> named parameter is passed, the program will be executed in the background, and the run command will return as soon as the child process is created. This means that the object returned is actually a <code>Conc::Proc</code>, which represents the created process.</p>

<p>[ Note: should the :bg form take rw filehandles or is that over-overloading the functionality of run? Should run be the new open with</p>

<pre>        respect to executing external code? -ajs ]</pre>

<p>[ Note: system() should be renamed to sys() or sh() or run() or some such to avoid P5-induced boolean inversion confusion, plus Huffmanize it a little better. I&#39;m thinking run() might be best for MMD reasons. --law</p>

<p>Note: exec should also be renamed to something clearer and &#34;final&#34; and huffmanly longer. I&#39;m thinking runinstead(). And maybe the function behind qq:x should be rungather() rather than readpipe(). -law ]</p>

<dt><a name="runinstead"
>runinstead</a></dt>

<dd>
<pre> multi OS::runinstead ( ; Str $path, *@args )
 multi OS::runinstead ( ; Str $command )</pre>

<p>Identical to <code>run</code> except that it never returns. The executed program replaces the currently running program in memory.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Concurrency"
>Concurrency</a></h2>

<p>There are higher-level models of concurrency management in Perl (see <a href="http://search.cpan.org/perldoc?S17#Concurrency" class="podlinkpod"
>&#34;Concurrency&#34; in S17</a>). These functions are simply the lowest level tools</p>

<dl>
<dt><a name="fork"
>fork</a></dt>

<dd>
<pre> our Conc::Proc sub Conc::Processes::fork()</pre>

<p>Creates a copy of the current process. Both processes return from <code>fork</code>. The original process returns the <i>child</i> process as a <code>Conc::Proc</code> object. The newly created process returns the <i>parent</i> process as a <code>Conc::Proc</code> object. As with any Conc::Proc object, the child process object numifies to the process ID (OS dependent integer). However, the parent process object numifies to <code>0</code> so that the child and parent can distinguish each other.</p>

<p>Typical usage would be:</p>

<pre> if !defined(my $pid = fork) {
   die &#34;Error calling fork: $!&#34;;
 } elsif $pid == 0 {
   say &#34;I am the new child!&#34;;
   exit 0;
 } else {
   say &#34;I am the parent of {+$pid}&#34;;
   wait();
 }</pre>

<dt><a name="wait"
>wait</a></dt>

<dd>
<pre> our Conc::Proc::Status multi method Conc::Processes::wait( Conc::Proc $process: *%options )

 our Conc::Proc::Status multi Conc::Processes::wait ( Conc::Proc $process = -1, *%options )</pre>

<p>Waits for a child process to terminate and returns the status object for the child. This status object will numify to the process ID of the child that exited.</p>

<p>Important Conc::Proc::Status methods:</p>

<pre> .exit - Numeric exit value
 .pid - Process ID
 .signal - Signal number if any, otherwise 0</pre>

<p>For historical reasons there is a <code>.status</code> method which is equal to:</p>

<pre> ($status.exit +&#60; 8) +| $status.signal</pre>

<p>If <code>$process</code> is supplied, then wait will only return when the given process has exited. Either a full <code>Conc::Proc</code> object can be passed, or just a numeric process ID. A <code>-1</code> explicitly indicates that wait should return immediately if any child process exits.</p>

<p>When called in this way, the returned <code>Conc::Proc::Status</code> object will have a <code>.pid</code> of <code>-1</code> (which is also what it numifies to) if there was no such process to wait for.</p>

<p>The named options include:</p>

<dl>
<dt><a name="blocking"
>blocking</a></dt>

<dd>
<p>Defaults to true. If set to false, this forces wait to return immediately.</p>

<dt><a name="WNOHANG"
>WNOHANG</a></dt>

<dd>
<p>Exists for historical compatibility. <code>WNOHANG =</code> 1&#62; is identical to <code>blocking =</code> False&#62;.</p>
</dd>
</dl>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Obsolete"
>Obsolete</a></h2>

<dl>
<dt><a name="dbmopen,_dbmclose"
>dbmopen, dbmclose</a></dt>

<dd>
<pre> use DB_File;</pre>

<dt><a name="dump"
>dump</a></dt>

<dd>
<p>Dumped.</p>

<dt><a name="format,_formline,_write"
>format, formline, write</a></dt>

<dd>
<p>See Exegesis 7.</p>

<dt><a name="/[msg|sem|shm].*/"
>/[msg|sem|shm].*/</a></dt>

<dd>
<pre> use IPC::SysV;</pre>

<dt><a name="local"
>local</a></dt>

<dd>
<p>Replaced by <code>temp</code> which, unlike <code>local</code>, defaults to not changing the value.</p>

<dt><a name="lock"
>lock</a></dt>

<dd>
<p>See <a href="http://search.cpan.org/perldoc?S17#Concurrency" class="podlinkpod"
>&#34;Concurrency&#34; in S17</a>. <code>lock</code> has been replaced by <code>is atomic</code>.</p>

<dt><a name="ref"
>ref</a></dt>

<dd>
<p>There is no ref() any more, since it was almost always used to get the type name in Perl 5. If you really want the type name, you can use <code>$var.meta.name</code> or <code>$var.^name</code>. If you really want P5 ref semantics, use <code>Perl5::p5ref</code>.</p>

<p>But if you&#39;re just wanting to test against a type, you&#39;re likely better off performing an <code>isa</code> or <code>does</code> or <code>can</code>, or just <code>$var ~~ TYPE</code>.</p>

<dt><a name="reset"
>reset</a></dt>

<dd>
<p>Was there a <i>good</i> use for this?</p>

<dt><a name="prototype"
>prototype</a></dt>

<dd>
<pre> &#38;func.meta.signature;
 &#38;func.^signature;</pre>

<dt><a name="study"
>study</a></dt>

<dd>
<p>Algorithm was too Anglo-centric. Could be brought back if generalized somehow.</p>

<dt><a name="waitpid"
>waitpid</a></dt>

<dd>
<p><code>wait</code> can now be called with or without an optional process/pid.</p>

<dt><a name="%"
>%</a></dt>

<dd>
<pre> $num1 % $num2</pre>

<p>Does a floating point modulus operation, i.e. 5.5 % 1 == 0.5 and 5 % 2.5 == 0.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Pending_Apocalypse"
>Pending Apocalypse</a></h2>

<p>The following functions are classified by Apocalypse/Synopsis numbers.</p>

<dl>
<dt><a name="A/S14:_Tied_Variables"
>A/S14: Tied Variables</a></dt>

<dd>
<p>tie tied untie (now implemented as container classes? my $foo is ....? is tie the meta operation on the container type for &#39;rebless&#39; - macro tie ( $var, $class, *@args ) { CODE { variable($var).meta.rebless( $class, *@args ) } } )</p>

<p>These are replaced by container types. The compiler is free to assume that any lexical variable is never going to change its container type unless some representation is made to that effect in the declaration. Note: P5&#39;s tied() is roughly replaced by P6&#39;s variable().</p>

<dt><a name="A/S16:_IPC_/_IO_/_Signals"
>A/S16: IPC / IO / Signals</a></dt>

<dd>
<p>-X accept alarm bind binmode chown close closedir connect eof fcntl fileno flock getc getpeername /[get|set][host|net|proto|serv|sock].*/ glob ioctl link listen lstat mkdir open opendir pipe print printf read readdir readline readlink readpipe recv rename rewinddir rmdir seek seekdir select(both) send setsockopt shutdown slurp socket socketpair stat symlink syscall sysopen sysread sysseek syswrite tell telldir truncate umask unlink utime warn</p>

<dt><a name="A/S??:_OS_Interaction"
>A/S??: OS Interaction</a></dt>

<dd>
<p>chroot crypt getlogin /[get|set][pw|gr].*/ kill setpgrp setpriority times</p>

<p>... These are probably going to be part of POSIX, automatically imported to GLOBAL <b>if</b> the platform is the right one</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Unfiled"
>Unfiled</a></h1>

<dl>
<dt><a name="say"
>say</a></dt>

<dd>
<p>This is a version of print() that auto-appends a newline:</p>

<pre>    Was:    print &#34;Hello, world!\n&#34;;
    Now:    say   &#34;Hello, world!&#34;;</pre>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Additions"
>Additions</a></h1>

<p>Please post errors and feedback to perl6-language. If you are making a general laundry list, please separate messages by topic.</p>

<!-- end doc -->

</body></html>
